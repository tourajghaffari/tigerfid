//------------------------------------------------------------------------------
// V1.61    Has fix for config rdr for ext. ID - changed '< 255' to '<=255' for
//          all ext. condition. Modified reset Reader to block ID > 255
//
// V1.62    Added new code to support Enable/Disable tag LED for Call tag, Query
//          tag, Enable tag and disable tag. Tag LED Configuration screen was
//          created for this version, but is diabled.
//
// V1.63    Added a warning message box for commands containing ANY_TAG, ANY_ID.
//          Added new feature in reader to configure reader transmit time.
//          Added Reset command when configuraing the reader in config reader
//          screen to make the reader to start with new configuration.
//
// V1.64    Added new code to support Low battery indication in query screen.
//          added a new list box to query screen to display tag information upon
//          a tag quey command. Changed the GUI for the Output relay screen.
//          Added new screen to encrypt hex files for downloading firmware to
//          reader and smart field generator.
//          Addded new code to support Tag Speaker. Added Gui to call, query,
//          enable and disable tag to support the speaker. Added new code and
//          new GUI to LED/Speaker screen to support configuraing tag speaker.
//          Added new screen for downloading firmware for 3 reader processes.
//          Added RSSI functionality - Detected list view will show the RSSI
//          value base on TAG_DETECTED_RSSI and the reader configuration has
//          the ability to set the RSSI in the reader config byte.
//
// V1.65    (a) Added support for Broadcast to all readers rdr=0 and all rdr command
//              and tag command. Smart Fgen dose not support broadcast reader.
//          (b) Modified Config LED/Speaker screen to display all tags LED and
//              speaker configuration.
//          (c) Fixed the bug for Query Smart Field Generator for processor and code
//              version to diaplay correct date and revision.
//          (d) Added RESET_READER to the assign reader so it would reset and
//              power up the reader with the new reader id.
//
// V1.66   (a) Added Get Field strength Button to the "Set Field Strength" screen
//             for the reader to display current DPOT value for the reader.
//         (b) Fixed the bug for field strength in "Set Field Strength" screen
//             in reader. Used to show big number and not calculating only five bits
//             for depot value.
//         (c) Added new option to the "Configure Standard Field Generator" screen
//             TagReaderID Assign CheckBox. If checked the std field gen set the reader
//             tag id with incoming reader ID.
//         (d) Added Modify checkbox to the Inputstatus screen to replace "No Change"
//             Option.
//         (e) Removed "Enable Transmitter" button from the reader command list.
//         (f) Implemented Tag Range for all Tag commands and added GUI for support.
//         (g) Fixed the bug for Read & Write Memory to reenable the button when
//             an 0xFF is send for end of broadcast.
//         (h) Changed the GUI for "Config Tag RND" and "Assign reader Tag" to look
//             more the same like other tag screens.
//
//  V1.67  (a) Bug: Config Tag LED/Speaker Screen - double clicking on TagList
//             Shoulf transfer tag ID & tag type to their corresponding fields. Fixed.
//         (b) BUG: Set Field Strength Screen - INC, Dec and Get works now for
//             sockets. Fixed.
//         (c) BUG: Config LED/Speaker static button - Could not switch the
//             TempList to TagList. Fixed.
//         (d) BUG: Smart FGen Call - Powerup command from SFGen would clear the
//             host id for Reset, Quary and CallTag HostID field. Fixed.
//         (e) BUG: Changing the Baudrate do not get saved in the registry. Fixed.
//         (f) BUG: Reader Config Screen - Enable Active hi/low do not work. Fixed.
//         (g) New Feature: Raeder Config Screen - Enable the reader type and
//             checkbox. Implemented.
//         (h) Spelling Error: TX Time - if no value msg "Forever" one word. Fixed.
//         (i) New Feature: Smart FGen Call Tag Screen - LED & Spaeaker support.
//             Implemented.
//         (j) Bug: Field Strength Page (reader) - Get command do not a beep. Fixed.
//         (k) Bug: Tag list do not sort the fields properly. Fixed.
//         (1) Bug: Assign rdr to tag screen - RA bit is not set in the tag type
//             byte.Fixed.
//         (m) Bug: Tag Configuration screen - RA bit in tag type should not be
//             set. Fixed
//
//  V1.68  (a) New Feature: Added support for writing large data to the tag - this
//             could be a temp feature requested from one of the customer.
//
//  V1.69  (a) New Feature: Added support for writing large data and verifying it with
//             readback.
//
//  V1.70  (a) New Feature: Added support for reading large data from the tag
//         (b) Fixed the problem with enabling commands for Smart FGen and STD FGen
//             when the radio button is clicked on the commands GroupBox
//
//  V1.71  (a) New Feature: Added support Smart FGen long/short Range for field strength
//         (b) Modified TagConfiguration for GetTagConfig function for tamper switch
//             to consider 000 00 000 for setting tamper to disable (00, 01 tamper disabled)
//
//  V1.72  (a) Fixed the problem for calculating FS for Smart Fgen for Config Smart FGen,
//             Query SFGen windows.
//         (b) Added support for displaying "Reader Offline" when there is no response for
//             all the reader and tag commands.
//
//  V1.73 (a) Fixed the problem for crashing when configuring tag. Problem with calculating
//            tag type in packetParser for config_tag.
//
//  V1.74 (a) Increase the time for reporting reader Offline to 5000 msc.
//        (b) Fixed the problem with ReadMemory read count.
//        (c) Fixed the problem with selecting items in the IPListView to
//            stay checked when calling diffrent commands.
//        (d) Fixed problem with specific tag id vs all tag id in the config tag
//            random number screen.
//        (e) Fixed the problem with configuring input port.
//        (f) Fixed the problem with setting lower and upper limit for the configuring
//            tag temperature.
//        (g) Fixed the problem with powerup command for STD field gen. Also changed
//            the CheckHostID() to support powerup from std fgen.
//
//  V1.75 (a) Fixed the bug in Smart FGen Call tag page for setting and displaying
//            correct Field Strength (dpot)
//  V1.77 (a) Modify the tag tempereture for negative values and also Num read / Ave
//            to include 1 and 2.
//  V1.78 (a) Modify the tag tempereture periodic Report Time limit setting for hours and minutes
//
//  V1.79 (a) Added new option for Motion detector in STD FGen, Enable Internal Sensor
//        (b) Added new option in STD FGen Config for LED and Spk.
//        (c) Modified #Read for Tag Report Control in Tag Temp Config. Exclude value
//            8 from the combobox.
//        (d) Added temp logging in tag config temperature screen.
//
//  V1.80 (a) Added support for configuring hold time in Config & Query STD FGen
//        (b) Fixed the reader in Reader Configuration when in network mod to not
//            switched back to different reader ID when GetConfig command is executed.
//        (c) Fixed the problem with curruption of tag when configuring tag type and
//            TIF/GC or Tamper switch.
//        (d) Wrong value for Tx Time in the Config STD FGen when checking external
//            motion sensor.
//
//  V1.82 (a) Added TimeStamp button for Tag Report Control for logging tag temperature
//            in Configuring Tag Temperature.
//        (b) Added fix TagID and TagType for Std Fgen config page when the refreshing
//            screen.
//        TimeStamp format 0x0180 => day xxxx x000
//        TimeStamp format 0x0180 => Mon 0000 0xxx
//        TimeStamp format 0x0181 => Mon x000 0000
//        TimeStamp format 0x0181 => Yr  0xxx xxx0
//        TimeStamp format 0x0181 => Hr  0000 000x
//        TimeStamp format 0x0182 => Hr  xxxx 0000
//        TimeStamp format 0x0182 => min 0000 xxxx
//        TimeStamp format 0x0183 => min xx00 0000
//        TimeStamp format 0x0183 => sec 00xx xxxx
//
//  V1.83 (a) STD FGen Config - Fixed the Tag Type, LED and SPK problem. They did
//        display the correct value when Get command was send to the tag.
//        (b) STD FGen Config - Removed checkbox for each HoldTime and WaitTime
//        and set the default time type to second for wait time.
//
//  V1.84 (a) Reader - Set Field Strength - Fixed the problem with getting right
//         value for FieldStrength and range type when Get command is sent.
//
//  V1.85 (a) Implementing support for Low Battery when the tag sends it unsolicited.
//
//  V1.86 (a) Std Fgen configuration - When configuring both FGen ID and Assigned rdr ID
//        only Assigned Rdr ID gets configured and FGen ID does not change and at the
//        next power up The pkt length change from 0x0D to 0x0E when query the FGen and
//        that will not populate the screen with params correctly. Workaround is to prevent
//        for both params to get configured at the same time.
//  V1.86 (b) Std FGen if fgen id configured greater than 128 the at net power up the FGen
//        displayed large number.
//  V1.87 Fix timestamp logging on tag, timestamp structure was being built imporperly
//  V1.88 Fix waittime bug - was reading wrong address in recieve buffer
//------------------------------------------------------------------------------

#include <vcl.h>
#include <stdio.h>
#include <io.h>
#include <math.h>
#include <mmSystem.h>
#include <Registry.hpp>
#pragma hdrstop

#include "ProgStationUnit.h"
#include "DiagnosticUnit.h"
#include "AboutUnit.h"
#include "AboutUnitNoLogo.h"
#include "ComConfigPage.h"
#include "ReaderIDDefUnit.h"
#include "FileSysMsgUnit.h"
#include "ConfigProgStationUnit.h"
//#include "ReadLargeDataUnit.h"
//#include "TCPIPUnit.h"
#include "Commands.h"
#include "scanUnit.h"

#include "NetworkUnit.h"
#include "AWSocketUnit.h"
#include "Rijndael.h"

//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TProgStationForm *ProgStationForm;
TCommConfigDlg *comConfigDialog = NULL;
AnsiString comStatusStr;
//----------COMMUNICATION----------------------------------------------------
static UINT chksumError = 0;
static UINT frameError  = 0;
BOOL chksumErrorFlag = false;
BOOL frameErrorFlag = false;
BOOL CRCErrorFlag = false;
HANDLE comPortID = 0;
BOOL pollComm = false;
BOOL connected = false;
int listViewItemCount = 0;
//#define MAXWORD 256
char recvBuf[260];
static char recvBufCpy[260];
static char plainText[260];
static char TagIDSend[4];
unsigned char XBuf[260];
char encryptedtext[260];
static unsigned char XBufLast[260];
static unsigned char WXBufLast[260];
static unsigned char Timer3XBuf[260];
static OVERLAPPED overlapRead  = {0};
static OVERLAPPED overlapWrite = {0};
static OVERLAPPED overlapWaitObj = {0};
static DCB oldDCBStruct = {0};
static DCB comDCB = {0};
static HANDLE hCommWatchThread;
static UINT bytesRead = 0;
static BOOL noCommChar = false;
String sysMsgTx = "";
bool gotResponse = false;
UINT pktCounter = 0;
UINT txPktCounter = 0;
int PktLength = 0;
int crc = 0xFFFF;
unsigned int pktLen = 0;
int elapsedTime = 0;
//bool displayElapsedTime = false;
int numWritePkts = 0;
int numWriteRetry = 0;
int writeDigitNum = 0;

bool largDataWriteAck = false;
bool largDataReadAck = false;
static unsigned char largeDataLastWriteBuf[50];
static unsigned char largeDataLastReadBuf[50];
static unsigned char largeDataReadBuf[50][100];
static unsigned char largeDataLastSent[12];
static unsigned char largeDataLastRead[12];
int largeDataReadRetryCt = 0;
int largeDataWriteRetryCt = 0;
bool largeDataReadRetry = false;
bool largeDataWriteRetry = false;
bool largeDataWriteAck = false;
bool largeDataReadAck = false;
int largeDataReadAckCounter = 0;
int largeDataWriteAckCounter = 0;
unsigned char wPktID = 1;
bool networkOffline = false;

#define IN_QUE_SIZE        1024
#define OUT_QUE_SIZE       1024
#define READ_TIMEOUT 1000    //millisecond
#define WRITE_TIMEOUT 1000   //millisecond

//--------------------------------------------------------
//   Encryption
//--------------------------------------------------------

int Encrypt(char *plaintext, int len, char *ciphertext, int method);
int Decrypt(char *ciphertext, int len, char *plaintext, int method);
unsigned char key[16] = { 0x19, 0x11, 0x3b, 0x63, 0x67, 0x8a, 0x00, 0xf7, 0x05,
                          0x77, 0x0a, 0xfb, 0x0c, 0x5d, 0x01, 0x0f }; //encryption key
char pstate=0;
char pstatd=0;		      //Encryption and decryption state variable
char shared_key[33];	      // 2 byte version of key
int (*blockEncrypt)(char *iv, char *key, int bytes, char *text, char method);  //Pointer to VC_blockEncrypt() function
char ive[16], ivd[16];	      //Pointer to initial

//-----------Encryption-----------------------------------

//--------------------------------------------------------
//   BOOTLOADER
//--------------------------------------------------------
#define	CHOSEN_MARKER	        215	 // 0xD7
#define IMAGE_BFR_LEN	        8192
#define PROG_LOC_ERASED		0x3FFF
#define NUM_OF_DISP_LINES	16
#define SHOW_STR_LEN		160
#define NUM_OF_PROCESSORS	6	 // now with TCop and SFGen included
#define CMD_ACK			0x80
#define TICKS_2WAIT_4ACK	8
#define CRC_INITIALIZE		0xFFFF
#define HDLC_FLAG		0x7E
#define HOST2_XREADER_PTYPE	0x1E	// 00 001 110
#define HOST2_READER_PTYPE	0x0A	// 00 001 010
#define HOST2_FGEN_PTYPE	0x08	// 00 001 000
#define CRC_MAGIC_HI		0x84
#define CRC_MAGIC_LO		0x08
#define NUM_OF_READERS		1
#define	RDR_CMD_TAG_DETECTED	0x31
#define HST_CMD_DWNLD_RDR	0x6C
#define HST_CMD_BOOT_QUERY	0x6F
#define	CTRL_FILE		"BootLdr.ctr"	// the name of the control file
#define LINE_FEED		0x0A
#define CARRIDGE_RETURN		0x0D
#define CIRC_BFR_LEN		128
#define MAX_ENCRYPT_SIZE        1500

void imbed_the_proc( char *str );
unsigned char str2byte( char *str );
UINT str2int( char *str );
FILE *fptr;
FILE *fp;
UINT abort_thread;
UINT bload_proc;
char proc_letter[] = {'C','D','E','T','J','K'};
short unsigned int prog_image[ IMAGE_BFR_LEN ];
char rsbuf[ NUM_OF_DISP_LINES ][ SHOW_STR_LEN ];
UINT tag_rcvd_count;
UINT bl_ending_state;
bool now_bootloading = false;
UINT record_num = 0;
bool boot_proc_new = false;
UINT proc_addrs = 0;
char fbuf[90];
// the processor structure
typedef struct
{
   bool been_booted;
   bool got_ex_cksm;		       // flags
   char code_revsion;
   char ucode_day;
   char ucode_mnyr;		       // micro-code date code, day, month & year
   short unsigned int max_cksm_loc;    // the maximum location to form the checksum over
   short unsigned int bl_checksum;     // the checksum I formed during boot-loading
   short unsigned int exec_checksum;   // the checksum he formed during initialization
} proc_t;
proc_t procs[NUM_OF_PROCESSORS];       // an array of processor structures
bool first_bload_cmd = false;
UINT cleanup_scheduled = 0;
bool waiting4_reader_ack = false;
bool bload_update = false;
void generate_crc(char ascii);
//char send_buf[80];
bool boot4_real = true;
UINT diagnostic_mode = 0;
UINT something2_send = 0;
UINT wait4_ack_timer = 0;
char host_id = 0;
bool use_edit_rdr_id = true;
short unsigned int e16b_value = 0;
// the reader structure
typedef struct
{
   bool rxtnd;
   bool rleds_on;
   char renbld;
   char rrevsn;
   char rly_status;
   char rbit_sws;
   char ralive;
   short unsigned int raddr;
} reader_t;
reader_t rdrs[NUM_OF_READERS + 2];	// an array of reader structures
UINT currnt_rdr = 0;
char fgen_id = 3;
bool itsan_ext_reader = false;
bool in_bps = false;
char fsbuf[NUM_OF_DISP_LINES * SHOW_STR_LEN];
bool got_last_bload_ack = false;
AnsiString m_cksmc_str;
AnsiString m_cksmd_str;
AnsiString m_cksme_str;
AnsiString m_cksm_str;
bool lastDownloadPkt = false;
short unsigned int ecksm = 0;
int numLines = 0;
bool got_rdr_bquery = false;
static OVERLAPPED overlapRS232Write = {0};
char *mn[] = {"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"};
char delim[] = "\t ", circ_recv_buf[CIRC_BFR_LEN];
char encryptBuf[MAX_ENCRYPT_SIZE][50];
unsigned int encIndex = 0;
unsigned int currIndex = 0;
bool nextPkt = false;

//BOOTLAOD--------------------------------------------------------

DWORD FAR PASCAL WatchCommThread (LPSTR );
UINT ReadBytes();

UINT txCommand;
int txLen;
//unsigned char* txBuf;


/////////////////////////SOCKET//////////////////////////
bool startNetworkComm = false;
int numIpSelected = 0;
AnsiString comConnectStr;
bool comPortOK = false;
struct networkInfoStruct *networkInfo;
unsigned short int numOpenedSocket = 0;
bool RS232On = false;
bool networkOn = false;
extern bool tcipWindow;
extern SOCKET sock;	    // Socket ids
extern struct sockaddr_in peer;
SOCKET activeSock[MAX_DESCRIPTOR][3];
//sockaddr_in* peerSock[MAX_DESCRIPTOR];
char ipAddr[MAX_DESCRIPTOR][20];
//ListViewInfoStruct listViewInfo[MAX_DESCRIPTOR];
//TCP/IP -------------------
DWORD FAR PASCAL TCPIPCommThread (LPSTR );
HANDLE hTCPIPCommThread; //static
//struct sockaddr_in peer;
//LTX_SOCKET openSock;

TTAWSocket* AWSockets[MAX_DESCRIPTOR];

//unsigned char Setup[SETUP_RECORDS];

int numIpAvail = 0;

//int TCPEncrypt(char* encryText, int len, char* plaintext, int method);
//int TCPDecrypt(char* encryText, int len, char*  plaintext, int method);
//int read_socket(SOCKET sock, char* rbuf, int len, struct sockaddr_in* from);

/*static unsigned char key[16] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                                 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f }; // Encryption key
int (*blockEncrypt)(char *iv, char *key, int bytes, char *text, char method);	  //Pointer to VC_blockEncrypt() function
int (*ltx_encrypt)(char* ,int ,char*, int);  //Pointer to encryption method routine ()
int (*ltx_decrypt)(char* ,int ,char*, int);  //Pointer to decryption method routine ()
char initVectorEncrypt[16], initVectorDecrypt[16];	  //Pointer to initialization vectors
int encryption = 2;	  //Encryption method (None, TwoFish or Rijndael)

char pstate, pstatd;	  //Encryption and decryption state variable
static char shared_key[33];	 // 2 byte version of key

char ive[16], ivd[16]; */
#define SOCKBUFSIZE 256



///////////SOCKET///////////////////////////////////////////////////////////////
//------------------------------------------------------------------------------
static int ReaderID[2] = {0x00, 0x01};
static int ReaderType[1] = {0x02};
char DiagnosticByte;
AnsiString AssignedReaderID;
AnsiString AssignedHostID;
unsigned short dlgRet = 0;
extern bool multiDisplayTagDetect = false;
extern bool duplicateTagFGenDetect = false;
extern bool duplicateTagGIDDetect = false;

//-------------------------------------------------------

//extern AnsiString demoTitle = "Demo";
//static int TagID[4] = {0x00, 0x00, 0x00, 0xAB};


//TEMPS ************************************************************************
//CHINA DEMO
//unsigned short demoTags[5][2] = {0,0,0,0,0,0,0,0,0,0};

int ttpop = 0; //take out for testing only
int command = 0;  //tcpip
FILE* wfPtr = NULL;
//TEMPS*************************************************************************

__fastcall TProgStationForm::TProgStationForm(TComponent* Owner)
        : TForm(Owner)
{
    ProgStationForm = this;
    modifyComm = false;
    RS232On = false;
    networkOn = false;
    pktLenToTransmit = 0;
    int i;
    mouseClicked = false;
    tagTempCalibDiff = 0.0;
    first = false;
    listViewItemCount = 0;
    maxConnectRetry = 1;
    broadcastNum = 0;
    bootloading = false;
    sendBootQuery = false;
    writeTagData = false;
    displayElapsedTime = false;
    numTagTypes = 0;
    tagTypesUpdated = false;
    rdrWentOffline = false;
    networkOffline = false;

    //large read data
    gotFF = false;
    startAddress = 0x00;
    lastNumReadLargeData = 0;
    MaxReadLargeData = 0;
    numReadLargeData = 0;
    readLargeDataCounter = 0;
    rPktID = 1;
    lastRPktID = 0;
    readBufIndex = 0;
    noResponseCounter = 0;
    largeDataDlg = NULL;
    powerupQueryFGen = false;

    /*int size = sizeof(networkInfoStruct)+7;
    networkInfo = (networkInfoStruct*)malloc(size*(MAX_DESCRIPTOR+1));
    if (networkInfo == NULL)
    {
       ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Failed to allocate memory for networking",
       ( LPCSTR )"Comm Information Dialog",
       MB_OK | MB_ICONEXCLAMATION | MB_TOPMOST  , LANG_ENGLISH );
       return;
    }*/

    /*int size = sizeof(socketInfoStruct)+1;
    socketInfo = (socketInfoStruct*)malloc(size*(MAX_DESCRIPTOR+1));
    if (socketInfo == NULL)
    {
       ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Failed to allocate memory for networking",
       ( LPCSTR )"Comm Information Dialog",
       MB_OK | MB_ICONEXCLAMATION | MB_TOPMOST  , LANG_ENGLISH );
       return;
    }*/

    for (int i=0; i<MAX_DESCRIPTOR; i++)
       sockConnectQue[i].connect = false;

    numSockConnected = 0;
    numSockPoll = 0;
    sockConnectQueIndex = 0;
    numSelectedSockConnect = 0;

    listViewInfo = new ListViewInfoStruct[MAX_DESCRIPTOR];
    //for (int i=0; i<MAX_DESCRIPTOR; i++)
       //AWSockets[i] = new TTAWSocket(this); //[MAX_DESCRIPTOR];
    /*int size = sizeof(ListViewInfoStruct)+1;
    listViewInfoMem = (ListViewInfoStruct *)malloc(size*MAX_DESCRIPTOR);
    if (listViewInfoMem == NULL)
    {
       ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Failed to allocate memory for networking",
       ( LPCSTR )"Comm Information Dialog",
       MB_OK | MB_ICONEXCLAMATION | MB_TOPMOST  , LANG_ENGLISH );
       return;
    }*/



      //Load the DLL
      hDLL = LoadLibrary("cbx_enc");
      if (hDLL != NULL)
      {
         //Find the VC_blockEncrypt() function
         blockEncrypt = (int (*)(char *, char *, int , char *, char)) GetProcAddress(hDLL, "VC_blockEncrypt");
         if (!blockEncrypt)
         {
            FreeLibrary(hDLL);
            return;
         }
     }

      int j;
      //Convert HEX key to 2 byte hex sequence
      for (i = 0, j = 0; i < sizeof(key); i++, j+= 2)
      {
         sprintf(&shared_key[j], "%.2X", key[i]);
      }

    srand( (unsigned)time(NULL));
    for (int j=0; j<16; j++)
      ive[j] = ivd[j] = rand();

    //Caption = demoTitle;

    //*******TEMP  China demo --------------------
    /*closeChinaDemo = false;
    chinaDemoON = false;
    timeCheckTags = 60;   //1 min
    timeSendStatus = 180; //3 min
    relay1On = false;
    relay2On = false;*/
    //--------------------------------------------

    lastFieldGenID = 0;
    ProgStationForm = this;
    Activated = false;
    comPanelRect = false;
    MultiTagType = false;
    resetPowerup = false;
    fileHandle = 0;
    recording = false;
    DecButtonClicked = false;
    HexButtonClicked = false;
    tagIDMouseDown = false;
    prevIDMouseDown = false;
    factoryIDMouseDown = false;
    columnToSort = 0;
    alreadyDisplayed = false;
    alreadyDisplayed1 = false;
    global = false;
    newListItem = false;
    nDuplicates = 0;
    numReaderIDList = 0;
    numFgenIDList = 0;
    numSFgenIDList = 0;
    updateIpList = false;
    ConnectingSockets = false;

    /*int unit = MainStatusBar->Width/20;
    MainStatusBar->Panels->Items[0]->Width = unit*3;
    MainStatusBar->Panels->Items[1]->Width = unit*7;
    MainStatusBar->Panels->Items[2]->Width = unit*5;
    MainStatusBar->Panels->Items[3]->Width = unit*4;
    MainStatusBar->Panels->Items[4]->Width = unit*1;*/
    recNum = 0;
    //RecCounter = 0;
    sockQueIndex = 0;
    pktCounter = 0;
    txRxCounter = 0;
    tagDetectCount = 0;
    tagTempCount =  0;
    TempStatusStaticText->Caption = "";
    readTemp = false;
    StopTX = false;
    StopRX = false;
    HexFormat = true;
    displayRx = true;
    displayTx = true;
    MainStatusBar->Panels->Items[4]->Text =  "Version 1.91";
    version = "Version 1.91";

    displayLowBattery = false;

   //Registry-----------------------------
   TRegistry* Reg = new TRegistry;
   Reg->RootKey = HKEY_CURRENT_USER;
   bool b1;
   if (Reg->KeyExists("Software"))
   {
      Reg->OpenKey("Software", false);
      if (!Reg->KeyExists("Active Wave"))
         Reg->CreateKey("Active Wave");

      Reg->OpenKey("Active Wave", false);

      if (!Reg->KeyExists("Programming Station"))
      {
         Reg->CreateKey("Programming Station");
         Reg->OpenKey("Programming Station", false);
         Reg->WriteInteger("Com", 1);
         Reg->WriteInteger("Baud", 115200);
         Reg->WriteInteger("Reader", 2);
         Reg->WriteInteger("Host", 1);
         Reg->WriteString("HostName", "");
         Reg->WriteInteger("PortID", 0);
         Reg->WriteString("CommType", "RS232");
         Reg->WriteBool("AllHostID", true);
         Reg->WriteBool("DisplayLowBattery", false);
         Reg->WriteFloat("TagTempCalib", 0.0);
         comPort = 1;
         baudRate = 115200;
         curBaudrate = lastBaudrate = baudRate;
         lastReaderID = 2;
         lastHostID = sysHostID = 1;
         lastIPAddress = "000.000.000.000";
         lastHostName = "";
         lastPortID = 0;
         lastCommType = "RS232";
         allHostID = true;
         displayLowBattery = false;
         numIps = 0;
         //tagTempCalib = 0.0;
      }
      else  //programming station exist
      {
         Reg->OpenKey("Programming Station", false);
         comPort = Reg->ReadInteger("Com");
         baudRate = Reg->ReadInteger("Baud");
         curBaudrate = lastBaudrate = baudRate;
         if (!Reg->ValueExists("Reader"))
            Reg->WriteInteger("Reader", 2);
         if (!Reg->ValueExists("Host"))
            Reg->WriteInteger("Host", 1);
         if (!Reg->ValueExists("HostName"))
            Reg->WriteString("HostName", "");
         if (!Reg->ValueExists("PortID"))
            Reg->WriteInteger("PortID", 0);
         if (!Reg->ValueExists("CommType"))
            Reg->WriteString("CommType", "RS232");
         if (!Reg->ValueExists("AllHostID"))
            Reg->WriteBool("AllHostID", true);
         if (!Reg->ValueExists("DisplayLowBattery"))
            Reg->WriteBool("DisplayLowBattery", false);
         if (!Reg->ValueExists("TagTempCalibC"))
            Reg->WriteFloat("TagTempCalibC", 0.00);
         lastReaderID = Reg->ReadInteger("Reader");
         sysHostID = Reg->ReadInteger("Host");
         lastHostID = sysHostID;
         //lastIPAddress = Reg->ReadString("IPAddress");
         lastHostName = Reg->ReadString("HostName");
         lastPortID = Reg->ReadInteger("PortID");
         lastCommType = Reg->ReadString("CommType");
         allHostID = Reg->ReadBool("AllHostID");
         displayLowBattery = Reg->ReadBool("DisplayLowBattery");
         numIps = Reg->ReadInteger("PortID");
         tagTempCalibC = Reg->ReadFloat("TagTempCalibC");

         tagTempCalibF = ((tagTempCalibC/5.0)*9.0); // + 32.0;

      } //programing station exists

      //Tag type definition
        Reg->OpenKey("Active Wave", false);
        Reg->OpenKey("Programming Station", false);

        if (Reg->ValueExists("Type01"))
        {
            tagTypes[0] = Reg->ReadString("Type01");
            if (tagTypes[0].data() != NULL)
            {
                numTagTypes += 1;
                if (Reg->ValueExists("Type01Abr"))
                    tagTypesAbr[0] = Reg->ReadString("Type01Abr");
            }
        }
        else
        {
            Reg->WriteString("Type01", "");
            Reg->WriteString("Type01Abr", "");
        }

        if (Reg->ValueExists("Type02"))
        {
            tagTypes[1] = Reg->ReadString("Type02");
            if (tagTypes[1].data() != NULL)
            {
                numTagTypes += 1;
                if (Reg->ValueExists("Type02Abr"))
                    tagTypesAbr[1] = Reg->ReadString("Type02Abr");
            }
        }
        else
        {
            Reg->WriteString("Type02", "");
            Reg->WriteString("Type02Abr", "");
        }

        if (Reg->ValueExists("Type03"))
        {
            tagTypes[2] = Reg->ReadString("Type03");
            if (tagTypes[2].data() != NULL)
            {
                numTagTypes += 1;
                if (Reg->ValueExists("Type03Abr"))
                    tagTypesAbr[2] = Reg->ReadString("Type03Abr");
            }
        }
        else
        {
            Reg->WriteString("Type03", "");
            Reg->WriteString("Type03Abr", "");
        }

        if (Reg->ValueExists("Type04"))
        {
            tagTypes[3] = Reg->ReadString("Type04");
            if (tagTypes[3].data() != NULL)
            {
                numTagTypes += 1;
                if (Reg->ValueExists("Type04Abr"))
                    tagTypesAbr[3] = Reg->ReadString("Type04Abr");
            }
        }
        else
        {
            Reg->WriteString("Type04", "");
            Reg->WriteString("Type04Abr", "");
        }

        if (Reg->ValueExists("Type05"))
        {
            tagTypes[4] = Reg->ReadString("Type05");
            if (tagTypes[4].data() != NULL)
            {
                numTagTypes += 1;
                if (Reg->ValueExists("Type05Abr"))
                    tagTypesAbr[4] = Reg->ReadString("Type05Abr");
            }
        }
        else
        {
            Reg->WriteString("Type05", "");
            Reg->WriteString("Type05Abr", "");
        }

        if (Reg->ValueExists("Type06"))
        {
            tagTypes[5] = Reg->ReadString("Type06");
            if (tagTypes[5].data() != NULL)
            {
                numTagTypes += 1;
                if (Reg->ValueExists("Type06Abr"))
                    tagTypesAbr[5] = Reg->ReadString("Type06Abr");
            }
        }
        else
        {
            Reg->WriteString("Type06", "");
            Reg->WriteString("Type06Abr", "");
        }

      //update comboxes
      UpdateTagTypesComboBox();
   }

   delete Reg;

   //Communication------------------------
    comPortOK = false;
    //comPort = 1;
    //baudRate = 19200;
    dataBits = 8;
    stopBits = ONESTOPBIT;
    parity = NOPARITY;
    FlowCtrl = 0;  //none
    readerOffLine = true;
    fieldGenOffLine = true;
    fieldGenOnLine = false;
    readerOnLine = false;
    uninitReader = false;

    for (i=0; i<MAX_DESCRIPTOR; i++)
      justStartedUp[i] = false;

    for (i=0; i<MAX_DESCRIPTOR; i++)
    {
       sockPollQue[i].ip = "";
       sockPollQue[i].txFlag = false;
       sockPollQue[i].reader = 0;
       sockPollQue[i].host = 0;
       sockPollQue[i].txLen = 0;
       for (int i=0; i<255; i++)
          sockPollQue[i].XBuf[i] = '\0';

    }
    numSockPoll = 0;

    /*for (i=0; i<MAX_DESCRIPTOR; i++)
    {
          networkInfo[i].activeSock = 0x00;
          networkInfo[i].peerSock = NULL;
          networkInfo[i].reader = 0;
          networkInfo[i].host = 0;
          strcpy(networkInfo[i].status, "Offline");
          networkInfo[i].active = false;
          networkInfo[i].selected = false;
          networkInfo[i].validRec = false;
          strcpy(networkInfo[i].ipAddr, "          ");
    }*/

    if (lastCommType == "RS232")
    {
       if (OpenSerial(comPort, baudRate))
           PlaySound("Ding.wav", NULL, SND_ASYNC );
       PortOpen = true;
    }
    else
       comStatusStr = "No Connection";

   //-----------------------------------------------------------------------

   int BarWidth = ProgStationForm->Width / 21;
   MainStatusBar->Panels->Items[0]->Width = BarWidth * 3; //gereral info
   MainStatusBar->Panels->Items[1]->Width = BarWidth * 4; //reader On
   MainStatusBar->Panels->Items[2]->Width = BarWidth * 4; //com
   MainStatusBar->Panels->Items[3]->Width = BarWidth * 3; //time
   MainStatusBar->Panels->Items[4]->Width = BarWidth * 3; //version
   MainStatusBar->Panels->Items[5]->Width = BarWidth * 3; //host ID
   MainStatusBar->Panels->Items[6]->Width = BarWidth * 1; //light

   TxClearTagCtrls();
   RxClearTagCtrls();

   for (i=0; i<MAX_TAG_DETECTED; i++)
   {
      tagDetectedArray[i].tagID = 0;
      tagDetectedArray[i].tagType = 6;
      tagDetectedArray[i].fGenID = 0xFF;
      tagDetectedArray[i].gID = false;
      tagDetectedArray[i].cmd = 0;
      tagDetectedArray[i].lastDetectTime = Now();

      tagTempArray[i].tagID = 0;
      tagTempArray[i].tagType = 6;
      tagTempArray[i].fGenID = 0xFF;
      tagTempArray[i].gID = false;
      tagTempArray[i].lastDetectTime = Now();
      tagTempArray[i].timeValue = 0;
   }

   ReaderTypeComboBox->ItemIndex = 0;

   hostIDStr = "Host ID: ";
   hostIDStr += sysHostID;
   MainStatusBar->Panels->Items[5]->Text =  hostIDStr;

   //--------------------------------
   if (ReaderIDComboBox->Items->IndexOf(lastReaderID) == -1 )
   {
      ReaderIDComboBox->Items->Add(lastReaderID);
      //readerIDList[numReaderIDList++] = lastReaderID;
   }
   ReaderIDComboBox->Text = lastReaderID;
   HostIDEdit->Text = lastHostID;
   //--------------------------------

   //reset reader Group Box
   if (ResetReaderIDComboBox->Items->IndexOf(lastReaderID) == -1 )
   {
      ResetReaderIDComboBox->Items->Add(lastReaderID);
      readerIDList[numReaderIDList++] = lastReaderID;
   }
   ResetReaderIDComboBox->Text = lastReaderID;
   ResetHostIDEdit->Text = sysHostID; //lastHostID;

   for (i=1; i<=60; i++)
      TxTimeComboBox->Items->Add(i);

   for (i=1; i<=60; i++)
      WaitTimeComboBox->Items->Add(i);

   for (i=1; i<=31; i++)
      FGenConfigTxTimeComboBox->Items->Add(i);

   for (i=0; i<=60; i++)
      FGenConfigWaitTimeComboBox->Items->Add(i);

   int k=0;
   for (i = 1; i < WriteMemoryStringGrid->ColCount; i++)
       WriteMemoryStringGrid->Cells[i][0] = IntToStr(++k);

   for (i = 1, k=0; i < WriteMemoryStringGrid->RowCount; i++)
       WriteMemoryStringGrid->Cells[0][i] = IntToStr(++k);

   for (i = 1, k=0; i < ReadMemoryStringGrid->ColCount; i++)
       ReadMemoryStringGrid->Cells[i][0] = IntToStr(++k);

   for (i = 1, k=0; i < ReadMemoryStringGrid->RowCount; i++)
       ReadMemoryStringGrid->Cells[0][i] = IntToStr(++k);

   msgDisplayed = false;
   eTagType01Count = 0;
   eTagType02Count = 0;
   eTagType03Count = 0;
   eTagType04Count = 0;
   eTagType05Count = 0;
   eTagType06Count = 0;
   eTagFactCount = 0;
   eTagTotalCount = 0;
   arrayIndexEnabled = 0;

   dTagType01Count = 0;
   dTagType02Count = 0;
   dTagType03Count = 0;
   dTagType04Count = 0;
   dTagType05Count = 0;
   dTagType06Count = 0;
   dTagFactCount = 0;
   dTagTotalCount = 0;
   arrayIndexDisabled = 0;

   receivedResponse = false;

   waitingForRespone = false;
   waitResetRdrACK = false;

   ResetReaderGroupBox->Visible = true;
   GeneralGroupBox->Visible = false;
   //WriteComm(RESET_DEVICE, 0, NULL, 0);

   writeFormat = "HEX";
   readFormat = "HEX";
   clicked = false;
   readerFgenButtonActivated = false;
   int numLines = 0;

   //TBorderIcons tempBI = BorderIcons;
   //tempBI << biMinimize;
   //BorderIcons = tempBI;

   // BOOTLOADER
   /////////////////////////////////////////////////////////
   overlapRS232Write.hEvent = CreateEvent(NULL, false, false, NULL);
   if (overlapRS232Write.hEvent == NULL)
   {
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"ERROR: Creating write RS232 overlapped event.",
                    ( LPCSTR )"Programming Station Information Dialog", MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
   }

   //DataCodeVerLabel->Caption = "";
   //ProgCodeVerLabel->Caption = "";
   //HostCodeVerLabel->Caption = "";
   RdrCodeVerListView->Items->Clear();

   DownloadRdrPCVerLabel->Caption = "";
   DownloadRdrPCDateLabel->Caption = "";

   DownloadRdrPDVerLabel->Caption = "";
   DownloadRdrPDDateLabel->Caption = "";

   DownloadRdrPEVerLabel->Caption = "";
   DownloadRdrPEDateLabel->Caption = "";
}
//---------------------------------------------------------------------------
UINT ReadBytes()
{
   DWORD dwRead=0, index=0;
   UINT BytesToRead, PktLen=0;

   if (!ReadFile(comPortID, &recvBuf[index], 1, &dwRead, &overlapRead))
   {
      if (GetLastError() != ERROR_IO_PENDING)
      {
         return(0);
      }
      else
      {
         if (!GetOverlappedResult(comPortID, &overlapRead, &dwRead, TRUE))
            return(0);

         if (dwRead == 0)
            return (0);
      }
   }

   // $$$ Added on mar 19 - this section will look for start pkets byte to
   //     start reading pkt.
   if (recvBuf[0] != 0x7E)
      return (0);

   index++;
   PktLen++;

   //get Command + Length
   if (!ReadFile(comPortID, &recvBuf[index], 2, &dwRead, &overlapRead))
   {
       if (GetLastError() != ERROR_IO_PENDING)
       {
          return(0);
       }
       else
       {
          if (!GetOverlappedResult(comPortID, &overlapRead, &dwRead, TRUE))
             return(0);

          if (dwRead == 0)
             return (0);
       }
   }

   index += 2;
   PktLen += 2;
   BytesToRead = recvBuf[2]; //(data + src addr + dest addr + type) length

   for (UINT i=0; i<BytesToRead; i++, PktLen++)
   {
      if (!ReadFile(comPortID, &recvBuf[index++], 1, &dwRead, &overlapRead))
      {
          if (GetLastError() != ERROR_IO_PENDING)
          {
             return(0);
          }
          else
          {
             if (!GetOverlappedResult(comPortID, &overlapRead, &dwRead, TRUE))
                return(0);

             if (dwRead == 0)
                return (0);
           }
      }
   }

   Sleep(10);  //without this period, only one byte gets in?

   //Get CRC
   if (!ReadFile(comPortID, &recvBuf[index], 2, &dwRead, &overlapRead))
   {
      if (GetLastError() != ERROR_IO_PENDING)
      {
         return(0);
      }
      else
      {
         if (!GetOverlappedResult(comPortID, &overlapRead, &dwRead, TRUE))
            return(0);

         if (dwRead == 0)
            return (0);
      }
   }

   PktLen += dwRead;

   return(PktLen);
}
//------------------------------------------------------------------------------
/*UINT ReadBytes()
{
   DWORD bytesRead=0, dwRead=0, index=0;
   int MAX_COUNT = 12;

   //while (bytesRead < MAX_COUNT)
   //while (true)
   {
       //if (!ReadFile(comPortID, &recvBuf[index++], 1, &dwRead, &overlapRead))
       if (!ReadFile(comPortID, &recvBuf[0], MAX_COUNT, &dwRead, &overlapRead))
       {
           if (GetLastError() != ERROR_IO_PENDING)
           {
               dwRead = 0;
               //break;
           }
           else if (!GetOverlappedResult(comPortID, &overlapRead, &dwRead, TRUE))
           {
               //if (!GetOverlappedResult(comPortID, &overlapRead, &dwRead, TRUE))
               //{
                   dwRead = 0;
                   //break;
               //}
           }
           //else
           //{
              //bytesRead = bytesRead;
              //break;
           //}
       }
       //bytesRead += dwRead;
       bytesRead = dwRead;
    } //while

    ClearCommError(comPortID, NULL, NULL);
    PurgeComm (comPortID, PURGE_TXCLEAR | PURGE_RXCLEAR );

   return((UINT)bytesRead);
}*/
//--------------------------------------------------------------------------
DWORD FAR PASCAL WatchCommThread(LPSTR lpData)
{
    DWORD comEvent;

    do
    {
        gotResponse = FALSE; //needed for synchronizing transmit and receive communication

        WaitCommEvent(comPortID, &comEvent, NULL);
        //WaitCommEvent(comPortID, &comEvent, &overlapWaitObj);

        gotResponse = TRUE; //needed for synchronizing transmit and receive communication

        if (!ProgStationForm->modifyComm)
           ProgStationForm->OnCommNotify();

    }while(connected);

    return(0);
}
//----------------------------------------------------------------------------
bool __fastcall TProgStationForm::OpenSerial(UINT port, UINT baud)
{
   HCURSOR hOldCursor, hWaitCursor;
   COMMTIMEOUTS comTimeouts;
   DWORD   dwFlag;
   DWORD   dwThreadID ;

   frameError = 0;
   chksumError = 0;

   //hWaitCursor = LoadCursor(NULL, IDC_WAIT);
   //hOldCursor = SetCursor(hWaitCursor);
   Sleep (100);
   //char PortStr[1];
   //itoa( port, PortStr, 10);
   String ComPort = "COM";
   ComPort += port; // PortStr[0];


   if (( comPortID = CreateFile(ComPort.c_str(), GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_ALWAYS, FILE_FLAG_OVERLAPPED, 0)) == INVALID_HANDLE_VALUE) //NULL,
   {
      ComPort = "Error Opening Com port ";
      ComPort += port;
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )ComPort.c_str(),
           ( LPCSTR )"Programming Station Information Dialog",
           MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );

      //pInformWin->informWinStr = "Configurator initialization ERROR ...";
      ClearCommError(comPortID, &dwFlag, NULL);
      sysStr = "ERROR: Com  Port";
      MainStatusBar->Panels->Items[0]->Text =  "ERROR: Com  Port";
      MainStatusBar->Panels->Items[2]->Text = "";
      comPortOK = false;
      return (false);
   }

   overlapRead.hEvent = CreateEvent(NULL, false, false, NULL);
   if (overlapRead.hEvent == NULL)
   {
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"ERROR: Creating read overlapped event.",
                    ( LPCSTR )"Programming Station Information Dialog",
                    MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
      sysStr = "ERROR: Creating read overlapped event.";
      MainStatusBar->Panels->Items[0]->Text = "ERROR: Creating read overlapped event.";

      return (false);
   }

   overlapWrite.hEvent = CreateEvent(NULL, false, false, NULL);
   if (overlapWrite.hEvent == NULL)
   {
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"ERROR: Creating write overlapped event.",
                    ( LPCSTR )"Programming Station Information Dialog", MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
      sysStr = "ERROR: Creating write overlapped event.";
      MainStatusBar->Panels->Items[0]->Text = "ERROR: Creating write overlapped event.";
      //recLED->LEDStyleID = 0;
      //recLED->Value = 1;
      //recReadyToggle->Value = 0;
      return (false);
   }

   overlapWaitObj.hEvent = CreateEvent(NULL, false, false, NULL);
   if (overlapWaitObj.hEvent == NULL)
   {
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"ERROR: Creating overlapped event.",
                    ( LPCSTR )"Programming Station Information Dialog", MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
      sysStr = "ERROR: Creating overlapped event.";
      MainStatusBar->Panels->Items[0]->Text =  "ERROR:  Com  Port";
      //recLED->LEDStyleID = 0;
      //recLED->Value = 1;
      //recReadyToggle->Value = 0;
      return (false);
   }

   // Initialize the serial port
   if (!InitComPort( port, baud ))
   {
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"ERROR: Failed to initialized Serial Comm Port.",
                    ( LPCSTR )"Programming Station Information Dialog",
                    MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );

      //pInformWin->informWinStr = "Configurator initialization ERROR ...";
      ClearCommError(comPortID, &dwFlag, NULL);
      sysStr = "ERROR: Failed to initialized Serial Comm Port.";
      MainStatusBar->Panels->Items[0]->Text =  "ERROR:  Com  Port";

      return (false);
   }

   // purge TX and RX buffers
   ClearCommError(comPortID, &dwFlag, NULL);
   PurgeComm (comPortID, PURGE_TXCLEAR | PURGE_RXCLEAR );

   // setup device buffer size
   if (!SetupComm( comPortID, IN_QUE_SIZE, OUT_QUE_SIZE))
   {
      if (comPortID)
         CloseHandle(comPortID);
      if (connected)
      {
         TerminateThread(hCommWatchThread, 0);
         connected = FALSE;
      }

      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"ERROR: Setting up comm buffer size",
                    ( LPCSTR )"Programming Station Information Dialog",
                    MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );

      ClearCommError(comPortID, &dwFlag, NULL);
      sysStr = "ERROR: Setting up comm buffer size";
      MainStatusBar->Panels->Items[0]->Text =  "ERROR:  Com  Port";

      return (false);
   }

   // setting time-out parameters for all read and write operations
   GetCommTimeouts(comPortID, &oldTimeouts);

   //Init timeous to ensure our overlapped reads work
   //COMMTIMEOUTS timeouts = { 0x01, 0, 0, 0, 0 };
   //SetCommTimeouts( comPortID, &timeouts );

   comTimeouts.ReadIntervalTimeout = MAXWORD;  //0L;   03/31/03 for all timeout param
   comTimeouts.ReadTotalTimeoutMultiplier = 0L;
   comTimeouts.ReadTotalTimeoutConstant = 1000L;
   comTimeouts.WriteTotalTimeoutMultiplier = (20000 / comDCB.BaudRate) ? (20000 / comDCB.BaudRate) : 1; //0L;
   comTimeouts.WriteTotalTimeoutConstant = 1000L;
   SetCommTimeouts (comPortID, &comTimeouts);

   // purge TX and RX buffers
   ClearCommError(comPortID, &dwFlag, NULL);
   PurgeComm (comPortID, PURGE_TXCLEAR | PURGE_RXCLEAR );

   if (!SetCommMask(comPortID, EV_RXCHAR))
   {
      if (comPortID)
         CloseHandle(comPortID);
      if (connected)
      {
         TerminateThread(hCommWatchThread, 0);
         connected = FALSE;
      }

      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"ERROR: EV_RXCHAR mask not set.",
                    ( LPCSTR )"Programming Station Information Dialog",
                    MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );

      ClearCommError(comPortID, &dwFlag, NULL);
      sysStr = "ERROR: EV_RXCHAR mask not set.";
      MainStatusBar->Panels->Items[0]->Text =  "ERROR:  Com  Port";

      return (false);
   }

   txWriteThread = new WriteThread(true);   // create but don’t ru

   portClosed = FALSE;

   //set the timer
   /*if((statusTimerID = SetTimer(Application, 2, 250, NULL)) == 0)  //500
   {
       MessageBox( "ERROR: Timer Not Installed",
                   "ADS Information Dialog", MB_OK | MB_ICONEXCLAMATION );
       return;
   }*/


   //create a thread to watch com for incoming chars
   if (NULL == (hCommWatchThread = CreateThread( (LPSECURITY_ATTRIBUTES) NULL,
                0,
                (LPTHREAD_START_ROUTINE) WatchCommThread,
                (LPVOID) NULL,
                0, &dwThreadID )))
   {
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"ERROR: failed to create WatchAdsCommThread thread.",
                 ( LPCSTR )"Programming Station Information Dialog",
                 MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );

      //pInformWin->informWinStr = "Configurator initialization ERROR ...";
      connected = FALSE;
      sysStr = "ERROR: failed to create WatchAdsCommThread thread.";
      MainStatusBar->Panels->Items[0]->Text =  "ERROR:  Com  Port";

      return (false);
   }
   else
   {
      connected = TRUE;
      comPortOK = true;
   }

   if (!::SetThreadPriority(hCommWatchThread, THREAD_PRIORITY_TIME_CRITICAL))
   {
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"ERROR: Thread priority setting.",
                    ( LPCSTR )"Programming Station Information Dialog",
                    MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
   }

   chksumErrorFlag = FALSE;
   frameErrorFlag = FALSE;

   //if (networkOn)
      //CloseSocket(openSock);

   RS232On = true;
   Sleep(1000);

   return (true);
}
//-----------------------------------------------------------------------------
bool __fastcall TProgStationForm::InitComPort(int port, int baud)
{
   DWORD lpErrors;
   COMSTAT lpStat;

   int baudDisplay = baud;
   FillMemory(&oldDCBStruct, sizeof(oldDCBStruct), 0);
   if (!GetCommState(comPortID, &oldDCBStruct))
   {
      if (comPortID)
         CloseHandle(comPortID);
      if (connected)
      {
         TerminateThread(hCommWatchThread, 0);
         connected = FALSE;
      }

      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Failed to get current DCB setting",
      ( LPCSTR )"Comm Information Dialog",
      MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );

      ClearCommError(comPortID, &lpErrors, &lpStat);
      sysStr = "Error: Failed to get current DCB setting";
      MainStatusBar->Panels->Items[0]->Text =  "ERROR:  Com  Port";

      return (false);
   }

   FillMemory(&comDCB, sizeof(comDCB), 0);
   if (!GetCommState(comPortID, &comDCB))
   {
      if (comPortID)
         CloseHandle(comPortID);
      if (connected)
      {
         TerminateThread(hCommWatchThread, 0);
         connected = FALSE;
      }

      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Failed to get current DCB setting",
      ( LPCSTR )"Comm Information Dialog",
      MB_OK | MB_ICONEXCLAMATION | MB_TOPMOST  , LANG_ENGLISH );

      ClearCommError(comPortID, &lpErrors, &lpStat);
      sysStr = "Error: Failed to get current DCB setting";
      MainStatusBar->Panels->Items[0]->Text =  "ERROR: Com  Port";

      return (false);
   }

   // Build the DCB (control setting for a serial communications device)
   // structure for the COM port.

   switch( baud)
   {
        case 9600:
            baud = CBR_9600;
        break;

        case 19200:
            baud = CBR_19200;
        break;

        case 38400:
            baud = CBR_38400;
        break;

        case 56000:
            baud = CBR_56000;
        break;

        case 57600:
            baud = CBR_57600;
        break;

        case 115200:
            baud = CBR_115200;
        break;
    }

    //comDCB.DCBlength               // size in bytes of DCB struct
    //comDCB.fTXContinueOnxoff       // transmission control after input buf is full
    //comDCB.EofChar                 // parity error char replacement
    //comDCB.fNull                   // if null bytes are discardes
    //comDCB.fAbortOnError           // read & write termination if an error occurs
    //comDCB.XonLim                  // min # bytes in input buf before XON is sent
    //comDCB.XoffLim                 // max # bytes in input buf before XOFF is sent
    //comDCB.XonChar                 // value of XON for trans and recept
    //comDCB.XoffChar                // value of XOFF for trans and recept
    //comDCB.ErrorChar               // value of char used to replace parity error
    //comDCB.EofChar                 // value of char used to signal end of data
    //comDCB.EvtChar                 // value of char used to cause the EV_RXFLAG event
    //comDCB.fRtsControl             // RTS(ready to send) input flow control
	                                 // default: RTS_CONTROL_HADSHAKE

    comDCB.BaudRate = baud;          // baud rate

    comDCB.fBinary = true;           // binary Mode. it should always set to TRUE
    comDCB.fParity = false;          // parity checking enabled   //8_9_bit_code

    comDCB.fOutxCtsFlow = true;      // TC 0 - No CTS flow control  //traffic controler
    comDCB.fOutxDsrFlow = 0;         // No DSR flow control

    //comDCB.fDtrControl = DTR_CONTROL_DISABLE;  //DTR(data terminal ready) input flow control
    comDCB.fRtsControl = RTS_CONTROL_TOGGLE; // TC 0  - Traffic controller
    comDCB.fDtrControl = 0;

    //comDCB.fDsrSensitivity = FALSE;  // driver comm sensitivity to state of DSR signal
    comDCB.fOutX   = 0;          // No XON/XOFF flow control during transmission
    comDCB.fInX    = 0;          // No XON/XOFF flow control during reception

    comDCB.Parity = 0;        //8_9_bit_code
    //NOPARITY            0
    //MARKPARITY          3
    //SPACEPARITY         4
    comDCB.StopBits = 0;    //
    comDCB.ByteSize = 8;    // 8 data bits

    //comDCB.XonChar=0;
    //comDCB.XoffChar=0;
    //comDCB.XonLim=100;
    //comDCB.XoffLim=100;

    ClearCommError(comPortID, &lpErrors, &lpStat);
    PurgeComm (comPortID, PURGE_TXCLEAR | PURGE_RXCLEAR );
    if ( SetCommState(comPortID, &comDCB ) == 0 )
    {
       if (comPortID)
          CloseHandle(comPortID);
       if (connected)
       {
          TerminateThread(hCommWatchThread, 0);
          connected = FALSE;
       }

       ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error setting CommState",
       ( LPCSTR )"Comm Information Dialog", MB_OK | MB_ICONEXCLAMATION | MB_TOPMOST  , LANG_ENGLISH );

       ClearCommError(comPortID, &lpErrors, &lpStat);
       sysStr = "Error setting CommState";
       MainStatusBar->Panels->Items[0]->Text =  "ERROR: Com  port ";
       //recLED->LEDStyleID = 0;
       //recLED->Value = 1;
       //recReadyToggle->Value = 0;
       return (false);
    }

    comStatusStr = "COM";
    comStatusStr += comPort;
    comStatusStr += "  ";
    comStatusStr += baudDisplay;
    comStatusStr += "   ";
    comStatusStr += dataBits;
    comStatusStr += "-";
    //NOPARITY            0
    //MARKPARITY          3
    //SPACEPARITY         4
    if (parity == NOPARITY)
       comStatusStr += 'N';
    else if (parity == SPACEPARITY)
       comStatusStr += 'S';
    else if (parity == MARKPARITY)
       comStatusStr += 'M';
    else if (parity == ODDPARITY)
       comStatusStr += 'O';
    else if (parity == EVENPARITY)
       comStatusStr += 'E';
    else
       comStatusStr += ' ';
    comStatusStr += "-";
    if (stopBits == 0)
       comStatusStr += '1';
    else if (stopBits == 1)
       comStatusStr += "1.5";
    else
       comStatusStr += '2';

    MainStatusBar->Panels->Items[2]->Text =  comStatusStr.c_str();
    sysStr = " COM  PORT  OK ";
    MainStatusBar->Panels->Items[0]->Text = " COM  PORT  OK ";

    return (true);
}
//---------------------------------------------------------------------------
int __fastcall TProgStationForm::OnCommNotify()
{
   DWORD lpErrors;
   COMSTAT lpStat;
   //char recvBufCpy[64];
   int index;
   unsigned int id;
   bool eRdr;
   AnsiString str;

    memset(recvBuf, NULL, sizeof(recvBuf));

    bytesRead = 0;
    bytesRead = ReadBytes();
    if (bytesRead == 0)
    {
       PurgeComm (comPortID, PURGE_RXCLEAR);
       return (0);
    }

    pktLen = recvBuf[2] + 5; //3header + 2crc
    if ((pktLen == bytesRead) && (bytesRead > 0))
    {
       packetOK = true;
       frameErrorFlag = false;
    }
    else
    {
       packetOK = false;        //frame Error
       frameErrorFlag = true;
    }

    pktLen = bytesRead;

    /*recvBuf[0] = 0x7E;
    recvBuf[1] = 0x01;
    recvBuf[2] = 0x04;
    recvBuf[3] = 0x0A;
    recvBuf[4] = 0x01;
    recvBuf[5] = 0x02;
    recvBuf[6] = 0x01;
    recvBuf[7] = 0x6D;
    recvBuf[8] = 0x96;*/

    if (CheckCRC(bytesRead, recvBuf))    //Check CRC
    {
       packetOK = true;
       CRCErrorFlag = false;
    }
    else
    {
       packetOK = false;
       CRCErrorFlag = true;
    }

    lastLenBytesSent = 0;

    pollComm = TRUE;
    pktCounter++;
    if (pktCounter == 9999)
       pktCounter = 0;

    PurgeComm (comPortID, PURGE_RXCLEAR ); // 3/17/00  added to fix the problem for receiving

    //PktLength = bytesRead;
    if (Activated )
    {
       if ((fileHandle != NULL) && recording)
       {
          recDebugStr = BuildRecPktString(recvBuf, pktLen, frameErrorFlag, CRCErrorFlag);
          recDebugStr += "\n";
          fwrite(recDebugStr.c_str(), recDebugStr.Length(), 1, fileHandle);
          if ((txRxCounter % 16) == 0)
             fflush(fileHandle);
       }

       for (unsigned int i=0; i<pktLen; i++)
         recvBufCpy[i] = recvBuf[i];

       if (displayRx)
          DisplayRecPackets(recvBufCpy, pktLen, frameErrorFlag, CRCErrorFlag,  NULL);

       //if (displayTx && !readerFgenButtonActivated /*&& (recvBuf[1] == POWER_UP)*/ || /*(recvBuf[1] == TAG_DETECTED) ||*/ (recvBuf[1] == 0x11))
       //{
          //pktCounter++;
          //DisplayTransmitPackets(XBuf, lastLenBytesSent);
      // }

       if (!frameErrorFlag && !CRCErrorFlag)
          PacketParser(bytesRead, -1); // only data len  no command
    }

    return (false);
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::PacketParser(int len, const int sockIndex)
{

   if (IsReaderOffline() && networkOn) //((int)recvBuf[4] == callingReaderID))
   {
       int myIndex;
       if ((myIndex=IsReaderOffline((int)recvBuf[4])) >= 0)
       {
           noResponseReaderID[myIndex] = 0;
           if ((myIndex=GetNetworkInfoIndex((int)recvBuf[4])) >= 0)
           {
              strcpy(listViewInfo[myIndex].rdrStatus, "Online");
              comStatusStr = "Connected To Network";
              BootloadTimer->Enabled = false;
              readerOffLine = false;
              readerOnLine = true;
              networkOffline = false;
           }
       }
       else
          BootloadTimer->Enabled = false;
   }
  else
  {
     BootloadTimer->Enabled = false;
     readerOffLine = false;
     readerOnLine = true;
  }

  if (networkOn)
     networkOffline = false;

   if (!allHostID)
   {
      if (!CheckHostID())
        return;
   }

   AnsiString IDStr;
   AnsiString str;
   char TagID[5];
   int i, index, configIndex, index2 = 0;
   int nr;
   unsigned int n;
   unsigned int tagID;
   unsigned char pktID, ch;
   bool extended = false;
   unsigned int readerType;
   unsigned int readerConfig;
   unsigned int cmd;
   int fGenID = 0;
   int hID = 0;
   int rID = 0;
   int tTime;
   int wTime;
   int hTime = -1;
   int motionSens = -1;
   bool gID;
   bool* fGenFlag = new bool;
   bool* gIDFlag = new bool;
   unsigned short* dIndex = new unsigned short;
   unsigned short queIndex = 0;
   AnsiString idStr;
   bool a, b, c, d, e, s, l;
   int dataLen, ct;
   char type;
   char chr;
   unsigned short rssi = 0;
   AnsiString diffTimeStr = "";
   //unsigned int n1;
   //unsigned int n2;
   //unsigned int n3;
   //unsigned int n4;

   //int Command = recvBuf[1] & 0x7F;  //0x0111 1111
   unsigned char Command = (unsigned char)recvBuf[1];
   tgType = 6;

   Label24->Visible = true;
   Label24->Caption = "Tag Version:";
   RxTagVersionLabel->Visible = true;

   Label13->Caption = "Resend Time:";
   Label9->Caption = "TIF Time:";
   Label11->Caption = "Tag Type: ";
   RxTagTypeLabel->Left = 63;

   *fGenFlag = false;
   *gIDFlag = false;
   *dIndex = 0;


   switch (Command)
   {
       case (HST_CMD_DWNLD_RDR + 0) | CMD_ACK: // 7E EC 04 11 02 01 ?? CH-CL
       case (HST_CMD_DWNLD_RDR + 1) | CMD_ACK: // 7E ED 04 11 02 01 ?? CH-CL
       case (HST_CMD_DWNLD_RDR + 2) | CMD_ACK: // 7E EE 04 11 02 01 ?? CH-CL

          if (lastDownloadPkt)
          {
              if (bload_proc == 0)
              {
                 DownloadRdrProgressBarC->Position = numLines-1;
              }
              else if (bload_proc == 1)
              {
                DownloadRdrProgressBarD->Position = numLines-1;
             }
             else if (bload_proc == 2)
             {
                DownloadRdrProgressBarE->Position = numLines-1;
             }
          }
          else
          {
             if (bload_proc == 0)
             {
                DownloadRdrProgressBarC->StepIt();
             }
             else if (bload_proc == 1)
             {
                DownloadRdrProgressBarD->StepIt();
             }
             else if (bload_proc == 2)
             {
                DownloadRdrProgressBarE->StepIt();
             }
          }

          if (proc_addrs == 1160)
             fGenID = 0;

          if (now_bootloading )
          {
             //Sleep(50);
             send_a_bload_cmd();
          }

          if(bl_ending_state == 1)
          {
              now_bootloading = false;
              got_last_bload_ack = TRUE;
              //BootloadTimer->Enabled = true;    it is used for reader Offline
              if (wfPtr)
              {
                 fclose(wfPtr);
                 wfPtr = NULL;
              }
          }
          first_bload_cmd	= FALSE;
       break;

       //----------------------------------------------------------------------
          //Processor:        cccccccccccccc dddddddddddddd eeeeeeeeeeeeee
          //FL Cm Ln Pt RA HA CR CD-CM CH-CL DR DD-DM DH-DL ER ED-EM EH-EL Bs Pi -CRC-
          //7E EF 14 11 ?? 01 C? Dy-MY CCKSM D? Dy-MY DCKSM E? Dy-MY ECKSM F? ?? -CRC-
       //----------------------------------------------------------------------*/
       case HST_CMD_BOOT_QUERY | CMD_ACK:		// ACK of reader-boot-query
							// if response to an automatic boot-query after booting
           if( bl_ending_state == 7 )
              bl_ending_state = 8;

           i = itsan_ext_reader ? 7 : 6;
           procs[0].code_revsion = recvBuf[i++] & 0x0FF;
           procs[0].ucode_day    = recvBuf[i++] & 0x0FF;
           procs[0].ucode_mnyr   = recvBuf[i++] & 0x0FF;
           chr = recvBuf[i++] & 0x0FF;
           ecksm = ( chr << 8 ) + ( recvBuf[i++] & 0x0FF );
           procs[ 0 ].exec_checksum = ecksm;
           DisplayQueryBootData(0);

           procs[1].code_revsion = recvBuf[i++] & 0x0FF;
           procs[1].ucode_day    = recvBuf[i++] & 0x0FF;
           procs[1].ucode_mnyr   = recvBuf[i++] & 0x0FF;
           chr = recvBuf[i++] & 0x0FF;
           ecksm = ( chr << 8 ) + ( recvBuf[i++] & 0x0FF );
           procs[1].exec_checksum = ecksm;
           DisplayQueryBootData(1);

           procs[2].code_revsion = recvBuf[i++] & 0x0FF;
           procs[2].ucode_day    = recvBuf[i++] & 0x0FF;
           procs[2].ucode_mnyr   = recvBuf[i++] & 0x0FF;
           chr = recvBuf[i++] & 0x0FF;
           ecksm = ( chr << 8 ) + ( recvBuf[i++] & 0x0FF );
           procs[2].exec_checksum = ecksm;
           DisplayQueryBootData(2);

           procs[0].got_ex_cksm =
           procs[1].got_ex_cksm = procs[2].got_ex_cksm = TRUE;

           got_rdr_bquery = TRUE;	// boot-query ACK from non-TCop

           //verify the checksum
           if (bootloading)
           {
              UINT j;
              short int diff, x;
              bootloading = false;

              j = procs[ bload_proc ].max_cksm_loc;
              diff = 0;
              for( i = 0; (unsigned int)i < j; i++ )
                 diff += prog_image[ i ];
              procs[ bload_proc ].been_booted = TRUE;
              procs[ bload_proc ].bl_checksum = diff;

              x = procs[ bload_proc ].exec_checksum & 0xFFFF;
              if( diff == x )
              {
                  if (bload_proc == 0)
                  {
                    DownloadLabelC->Font->Color = clGreen;
                    DownloadLabelC->Caption = "Completed";
                    StaticText->Caption = "Downloading awi501c.hex completed successfully.";
                  }
                  else if (bload_proc == 1)
                  {
                    DownloadLabelD->Font->Color = clGreen;
                    DownloadLabelD->Caption = "Completed";
                    StaticText->Caption = "Downloading awi501d.hex completed successfully.";
                  }
                  else if (bload_proc == 2)
                  {
                    DownloadLabelE->Font->Color = clGreen;
                    DownloadLabelE->Caption = "Completed";
                    StaticText->Caption = "Downloading awi501e.hex completed successfully.";
                  }
               } // end if a match
               else
               {
                  if (bload_proc == 0)
                  {
                    DownloadLabelC->Font->Color = clRed;
                    DownloadLabelC->Caption = "Failed";
                    StaticText->Caption = "Downloading awi501c.hex failed.";
                  }
                  else if (bload_proc == 1)
                  {
                    DownloadLabelD->Font->Color = clRed;
                    DownloadLabelD->Caption = "Failed";
                    StaticText->Caption = "Downloading awi501d.hex failed.";
                  }
                  else if (bload_proc == 2)
                  {
                    DownloadLabelE->Font->Color = clRed;
                    DownloadLabelE->Caption = "Failed";
                    StaticText->Caption = "Downloading awi501e.hex failed.";
                  }
               }
           }
       break;

       case RESET_DEVICE_ACK:  //0x01  ACK
          PlaySound("Ding.wav", NULL, SND_ASYNC );
          global = false;
          receivedResponse = true;
          EnableReaderBitBtn->Enabled = true;
          DisableReaderBitBtn->Enabled = true;
          QueryReaderBitBtn->Enabled = true;
          ConfigTagBitBtn->Enabled = true;
          EnableTagBitBtn->Enabled = true;
          DisableTagBitBtn->Enabled = true;
          QueryTagBitBtn->Enabled = true;
          CallTagBitBtn->Enabled = true;
          RelayBitBtn->Enabled = true;
          AssignReaderBitBtn->Enabled = true;
          if (recvBuf[2] == 4) //len=4
          {
             n = (unsigned char)recvBuf[4];
             RxReaderIDLabel->Caption = n;  //reader ID

             RxCommandLabel->Caption = "Reset Reader ACK";
             StaticText->Caption = "Reader was Reset successfully.";
          }
          else if (((unsigned char)recvBuf[2]) == 5)  //len = 5 (extended or ack from smart Fgen)
          {
             if ((recvBuf[3] & 0x38) == 0x30)  //exteded reader
             {
                n = (unsigned int)((unsigned char)recvBuf[4])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[5]);
                RxReaderIDLabel->Caption = n;  //reader ID

                RxCommandLabel->Caption = "Reset Reader ACK";
                StaticText->Caption = "Reader was Reset successfully.";
             }
             else
             {
                n = (unsigned char)recvBuf[4];
                RxReaderIDLabel->Caption = n;    //reader ID
                nr = (unsigned char)recvBuf[5];  //field gen

                RxCommandLabel->Caption = "Reset Smart FGen ACK";
                str = "Smart FGen ";
                str += nr;
                str += " was Reset successfully.";
                StaticText->Caption = str;
             }
          }


       break;

       case INPUT_STATUS_ACK:  //0x91  ACK
       case 0x11:              //unsolicitated input status
           receivedResponse = true;
          //if (recvBuf[2] == 5) //reg reader
          if ((recvBuf[3] & 0x38) == 0x10)  //reg reader
          {
             rID = (unsigned char)recvBuf[4];
             hID = (unsigned char)recvBuf[5];
             RxReaderIDLabel->Caption = rID;  //reader ID
             ch = recvBuf[6];  //condition byte
          }
          else  // (extended)
          {
             rID = (unsigned int)((unsigned char)recvBuf[4])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[5]);
             hID = (unsigned char)recvBuf[6];
             RxReaderIDLabel->Caption = rID;  //reader ID
             ch = (unsigned char)recvBuf[7];  //condition byte
          }

          DisplayInputListView(rID, ch);

          RxCommandLabel->Caption = "Input Status ACK";
          str = "Received Status of Reader Inputs.";
          StaticText->Caption = str;
          PlaySound("Ding.wav", NULL, SND_ASYNC );
       break;

       case ENABLE_RELAY_ACK:  //0x02  ACK
           receivedResponse = true;
          //if (recvBuf[2] == 4) //len=4
          if ((recvBuf[3] & 0x38) == 0x10)  //reg reader
          {
             rID = (unsigned char)recvBuf[4];
             hID = (unsigned char)recvBuf[5];
             RxReaderIDLabel->Caption = rID;  //reader ID
             pktID = (unsigned char)recvBuf[6];
          }
          else  //len = 4 (extended)
          {
             rID = (unsigned int)((unsigned char)recvBuf[4])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[5]);
             hID = (unsigned char)recvBuf[6];
             RxReaderIDLabel->Caption = rID;  //reader ID
             pktID = (unsigned char)recvBuf[7];
          }

          //China Demo
          //-------------------------
          /*if (chinaDemoON)
          {
             if (pktID == 81)  //relay 1
                ChinaDemoForm->UpdateChinaMsg(1, 0);
             else  //relay 2
                ChinaDemoForm->UpdateChinaMsg(2, 0);
          } */
          //-------------------------

          if (pktID == 0x41)  //relay 1
             DisplayRelayListView(rID, 1, true);
          else  //relay 2
             DisplayRelayListView(rID, 2, true);


          RxCommandLabel->Caption = "Enable Relay ACK";
          str = "Relay Was Opened.";
          StaticText->Caption = str;
          PlaySound("Ding.wav", NULL, SND_ASYNC );
       break;

       case DISABLE_RELAY_ACK:  //0x03  ACK
          receivedResponse = true;
          //if (recvBuf[2] == 4) //len=4
          if ((recvBuf[3] & 0x38) == 0x10)  //reg reader
          {
             rID = (unsigned char)recvBuf[4];
             hID = (unsigned char)recvBuf[5];
             RxReaderIDLabel->Caption = rID;  //reader ID
             pktID = (unsigned char)recvBuf[6];
          }
          else  //len = 4 (extended)
          {
             rID = (unsigned int)((unsigned char)recvBuf[4])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[5]);
             hID = (unsigned char)recvBuf[6];
             RxReaderIDLabel->Caption = n;  //reader ID
             pktID = (unsigned char)recvBuf[7];
          }

          //China Demo
          //-------------------------
          /*if (chinaDemoON)
          {
             if (pktID == 91)  //relay 1
                ChinaDemoForm->UpdateChinaMsg(1, 1);
             else  //relay 2
                ChinaDemoForm->UpdateChinaMsg(2, 1);
          }*/
          //-------------------------

          if (pktID == 0x41)  //relay 1
             DisplayRelayListView(rID, 1, false);
          else  //relay 2
             DisplayRelayListView(rID, 2, false);

          RxCommandLabel->Caption = "Disable Relay ACK";
          str = "Relay Was Closed.";
          StaticText->Caption = str;
          PlaySound("Ding.wav", NULL, SND_ASYNC );
       break;

       case ENABLE_READER_ACK:  //0x04  ACK
          receivedResponse = true;
          //if (recvBuf[2] == 4) //len=4
          if ((recvBuf[3] & 0x38) == 0x10)  //reg reader
          {
             n = (unsigned char)recvBuf[4];
             RxReaderIDLabel->Caption = n;  //reader ID
          }
          else  //len = 4 (extended)
          {
             n = (unsigned int)((unsigned char)recvBuf[4])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[5]);
             RxReaderIDLabel->Caption = n;  //reader ID
          }

          idStr = n;
          //if (EnableReaderIDComboBox->Text.data() == NULL)
          if (!CheckDuplicatedReader(n))
               readerIDList[numReaderIDList++] = n;

          DisplayReadersInViewList("", idStr);

          RxCommandLabel->Caption = "Enable Reader ACK";
          str = "Reader ID ";
          str += n;
          str += "  Enabled.";
          StaticText->Caption = str;
          PlaySound("Ding.wav", NULL, SND_ASYNC );
       break;

       case DISABLE_READER_ACK:  //0x05  ACK
          receivedResponse = true;
          //if (recvBuf[2] == 4) //len=4
          if ((recvBuf[3] & 0x38) == 0x10)  //reg reader
          {
             n = (unsigned char)recvBuf[4];
             RxReaderIDLabel->Caption = n;  //reader ID
          }
          else  //len = 4 (extended)
          {
             n = (unsigned int)((unsigned char)recvBuf[4])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[5]);
             RxReaderIDLabel->Caption = n;  //reader ID
          }

          idStr = n;
          //if (ReaderIDComboBox->Text.data() == NULL)
          if (!CheckDuplicatedReader(n))
               readerIDList[numReaderIDList++] = n;
          DisplayReadersInViewList("", idStr);

          RxCommandLabel->Caption = "Disable Reader ACK";
          str = "Reader ID ";
          str += n;
          str += "  Disabled.";
          StaticText->Caption = str;
          PlaySound("Ding.wav", NULL, SND_ASYNC );
       break;

       case SET_READER_DPOT_ACK:  //0xA2  ACK
          receivedResponse = true;
          if ((recvBuf[3] & 0x38) == 0x10)  //reg reader
          {
             n = (unsigned char)recvBuf[4];
             RxReaderIDLabel->Caption = n;  //reader ID

             if (SmartFGenGroupBox->Visible)
             {
                SmartFGenDPotValueLabel->Caption = ((unsigned char)recvBuf[6] & 0x1F);
             }
             else if (SetFStrengthGroupBox->Visible)
             {
                ReaderFStrengthLabel->Caption = ((unsigned char)recvBuf[6] & 0x1F);
                if (recvBuf[6] & 0x20)  //long distance
                {
                    ReaderLongRangeRadioButton->Checked = true;
                    ReaderShortRangeRadioButton->Checked = false;
                }
                else
                {
                    ReaderLongRangeRadioButton->Checked = false;
                    ReaderShortRangeRadioButton->Checked = true;
                }
             }
          }
          else  //len = 4 (extended)
          {
             n = (unsigned int)((unsigned char)recvBuf[4])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[5]);
             RxReaderIDLabel->Caption = n;  //reader ID

             ReaderFStrengthLabel->Caption = ((unsigned char)recvBuf[7] & 0x1F);
             if (recvBuf[7] & 0x20)  //long distance
             {
                ReaderLongRangeRadioButton->Checked = true;
                ReaderShortRangeRadioButton->Checked = false;
             }
             else
             {
                ReaderLongRangeRadioButton->Checked = false;
                ReaderShortRangeRadioButton->Checked = true;
             }
          }

          RxCommandLabel->Caption = "Set Reader DPOT ACK";
          str = "DPOT for Reader ID ";
          str += n;
          str += "  was set successfully.";
          StaticText->Caption = str;
          PlaySound("Ding.wav", NULL, SND_ASYNC );
       break;

       case CONFIG_TAG_ACK:   //0x06  ACK

          EnableTagStaticCommands();
          receivedResponse = true;
          programming = false;
          PlaySound("Ding.wav", NULL, SND_ASYNC );
          //if (recvBuf[2] == 9) //len=9   //reg reader - no repeater
          if ((recvBuf[3] & 0x38) == 0x10)  //reg reader
          {
             nr = (unsigned char)recvBuf[4];
             RxReaderIDLabel->Caption = nr;  //reader ID

             //status Byte
             DisplayStatusByte(6, CONFIG_TAG);
             configIndex = 6;

             n = (unsigned int)((unsigned char)recvBuf[7])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[8])*pow(2, 16)+
                 (unsigned int)((unsigned char)recvBuf[9])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[10]);
             RxTagIDLabel->Caption = n;     //tag ID
             gID = ((unsigned char)recvBuf[6]) & 0x01;
             //n = (unsigned int)(unsigned char)recvBuf[7]*pow(2, 24)+(unsigned int)(unsigned char)recvBuf[8]*pow(2, 16)+
                 //(unsigned int)(unsigned char)recvBuf[9]*pow(2, 8)+(unsigned int)(unsigned char)recvBuf[10];
             RxTagIDLabel->Caption = n;     //tag ID
          }
          else  //len = 10 (extended)  no repeater
          {
             nr = (unsigned int)((unsigned char)recvBuf[4])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[5]);
             RxReaderIDLabel->Caption = nr;  //reader ID

             //status Byte
             DisplayStatusByte(7, CONFIG_TAG);
             configIndex = 7;

             n = (unsigned int)((unsigned char)recvBuf[7])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[8])*pow(2, 16)+
                 (unsigned int)((unsigned char)recvBuf[9])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[10]);
             RxTagIDLabel->Caption = n;     //tag ID
             gID = ((unsigned char)recvBuf[7]) & 0x01;

             //n = (unsigned int)(unsigned char)recvBuf[8]*pow(2, 24)+(unsigned int)(unsigned char)recvBuf[9]*pow(2, 16)+
                 //(unsigned int)(unsigned char)recvBuf[10]*pow(2, 8)+(unsigned int)(unsigned char)recvBuf[11];
             RxTagIDLabel->Caption = n;     //tag ID
          }

          if (!CheckSameTag(n, tgType, fGenID, gID, fGenFlag, gIDFlag, dIndex, nr, CONFIG_TAG_ACK, rssi) || multiDisplayTagDetect)
          {
                if (*gIDFlag || *fGenFlag)
                {
                   queIndex = *dIndex;
                   nDuplicates++;
                }
                else
                {
                   queIndex = tagDetectCount;
                   /*if (tgType == 0x01) //access
                      accTagCount += 1;
                   else if (tgType == 0x02) //inventory
                      invTagCount += 1;
                   else if (tgType == 0x03) //asset
                      assTagCount += 1;
                   else if (tgType == 0x04) //car
                      carTagCount += 1;

                   if (multiDisplayTagDetect)
                      nDuplicates++;*/
                }

                LoadStatusByteToQue(configIndex, TAG_DETECTED, queIndex);

                tagDetectedArray[queIndex].lastDetectTime = Now();

                tagDetectedArray[queIndex].tagID = n;
                tagDetectedArray[queIndex].readerID = nr;
                tagDetectedArray[queIndex].cmd = TAG_DETECTED;
                tagDetectedArray[queIndex].tagType = tgType;
                tagDetectedArray[queIndex].rssi = rssi;

                if (fGenID > 0)
                   tagDetectedArray[queIndex].fGenID = fGenID;
                else
                   tagDetectedArray[queIndex].fGenID = 0;
                tagDetectedArray[queIndex].gID = gID;

                DisplayTagInListView(queIndex, fGenID, gID, fGenFlag, gIDFlag, 0, "CFG"); //(DetectedTagListView->Items->Count);
                if (*gIDFlag == false)
                   tagDetectCount++;

                if (global)
                   PlaySound("Ding.wav", NULL, SND_ASYNC );
          }

          RxCommandLabel->Caption = "Configure Tag ACK";

          str = RxTagTypeLabel->Caption;
          str = " Tag ID ";
          str += n;
          str += "  Was programmed successfully.";
          StaticText->Caption = str;
       break;

       case ENABLE_TAG_ACK:  //0x07  ACK
          //StaticText->Caption = "";
          //DetectedMsg->Caption = "";
          //TamperSWMsg->Caption = "";

          EnableTagStaticCommands();
          EnableTagBitBtn->Enabled = true;
          CMDEnableTimer->Enabled = false;

          receivedResponse = true;
          programming = false;
          //PlaySound("Ding.wav", NULL, SND_ASYNC );
          //if (recvBuf[2] == 9) //len=9   //reg reader - no repeater
          if ((recvBuf[3] & 0x38) == 0x10)  //reg reader
          {
             n = (unsigned char)recvBuf[4];
             RxReaderIDLabel->Caption = n;  //reader ID

             //status Byte
             DisplayStatusByte(6, ENABLE_TAG);
             configIndex = 6;

             tgType = (unsigned char)recvBuf[6] & 0xE0;   //1110 0000
             tgType >>= 5;
             n = (unsigned int)((unsigned char)recvBuf[7])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[8])*pow(2, 16)+
                 (unsigned int)((unsigned char)recvBuf[9])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[10]);
             RxTagIDLabel->Caption = n;     //tag ID
             gID = ((unsigned char)recvBuf[6]) & 0x01;

          }
          else  //len = 10 (extended)  no repeater
          {
             n = (unsigned int)((unsigned char)recvBuf[4])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[5]);
             RxReaderIDLabel->Caption = n;  //reader ID

             //status Byte
             DisplayStatusByte(7, ENABLE_TAG);
             configIndex = 7;

             tgType = (unsigned char)recvBuf[7] & 0xE0;   //1110 0000
             tgType >>= 5;
             n = (unsigned int)((unsigned char)recvBuf[8])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[9])*pow(2, 16)+
                 (unsigned int)((unsigned char)recvBuf[10])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[11]);
             RxTagIDLabel->Caption = n;     //tag ID
             gID = ((unsigned char)recvBuf[7]) & 0x01;
          }

          if (!CheckDuplicatedEnabledTag(n, tgType))
          {
             StaticText->Caption = "";
             DisplayTagInListView(n, tgType);
             enabledTagArray[arrayIndexEnabled].tagID = n;
             enabledTagArray[arrayIndexEnabled].tagType = tgType;
             arrayIndexEnabled++;

             if (tgType == 1)
             {
                eTagType01Count++;
                eTagTotalCount++;
                EnableTagType01Label->Caption = eTagType01Count;
             }
             else if (tgType == 2)
             {
                eTagType02Count++;
                eTagTotalCount++;
                EnableTagType02Label->Caption = eTagType02Count;
             }
             else if (tgType == 3)
             {
                eTagType03Count++;
                eTagTotalCount++;
                EnableTagType03Label->Caption = eTagType03Count;
             }
             else if (tgType == 4)
             {
                eTagType04Count++;
                eTagTotalCount++;
                EnableTagType04Label->Caption = eTagType04Count;
             }
             else if (tgType == 5)
             {
                eTagType05Count++;
                eTagTotalCount++;
                EnableTagType05Label->Caption = eTagType05Count;
             }
             else if (tgType == 6)
             {
                eTagType06Count++;
                eTagTotalCount++;
                EnableTagType06Label->Caption = eTagType06Count;
             }
             else if (tgType == 7) //factory
             {
                eTagFactCount++;
                eTagTotalCount++;
                EnableTagFactoryLabel->Caption = eTagFactCount;
             }

             EnableTagTotalLabel->Caption = eTagTotalCount;

             str = "Tag ID ";
             str += n;
             str += " was Enabled successfully";
             StaticText->Caption = str;
             RxCommandLabel->Caption = "Enable Tag ACK";
          }

          RxCommandLabel->Caption = "Enable Tag ACK";
          PlaySound("Ding.wav", NULL, SND_ASYNC );

          /*if (!CheckSameTag(n, tgType, fGenID, gID, fGenFlag, gIDFlag, dIndex) || multiDisplayTagDetect)
          {
             if (*gIDFlag || *fGenFlag)
             {
                queIndex = *dIndex;
                nDuplicates++;
             }
             else
             {
                queIndex = tagDetectCount;
                //if (tgType == 0x01) //access
                   //accTagCount += 1;
                //else if (tgType == 0x02) //inventory
                   //invTagCount += 1;
                //else if (tgType == 0x03) //asset
                   //assTagCount += 1;
                //else if (tgType == 0x04) //car
                   //carTagCount += 1;

                //if (multiDisplayTagDetect)
                   //nDuplicates++;*
             }

             LoadStatusByteToQue(configIndex, TAG_DETECTED, queIndex);

             tagDetectedArray[queIndex].lastDetectTime = Now();

             tagDetectedArray[queIndex].tagID = n;
             tagDetectedArray[queIndex].readerID = nr;
             if (fGenID > 0)
                tagDetectedArray[queIndex].fGenID = fGenID;
             else
                tagDetectedArray[queIndex].fGenID = 0;
             tagDetectedArray[queIndex].gID = gID;

             DisplayTagInListView(queIndex, fGenID, gID, fGenFlag, gIDFlag); //(DetectedTagListView->Items->Count);
             if (*gIDFlag == false)
                tagDetectCount++;

             if (global)
                Beep();
          }
          else
          {
             if (configIndex > 0)
                UpdateTagDetectedArray(nr, fGenID, n, tgType, configIndex);
          } */

          /*RxCommandLabel->Caption = "Enable Tag ACK";

          str = RxTagTypeLabel->Caption;
          str = " Tag ID ";
          str += n;
          str += "  Was Enabled successfully.";
          StaticText->Caption = str;*/

          //str = RxTagTypeLabel->Caption;
          //str += " Tag ";
          //str += n;
          //str += " detected.";
          //if (RxTamperLabel->Caption == "Yes")
             //TamperSWMsg->Caption = "Tamper  Switch  Enabled !";
          //else
             //TamperSWMsg->Caption = "";
          //DetectedMsg->Caption = str;
       break;

       case DISABLE_TAG_ACK:  //0x08  ACK

          EnableTagStaticCommands();
          DisableTagBitBtn->Enabled = true;
          CMDEnableTimer->Enabled = false;

          receivedResponse = true;
          programming = false;
          //Beep();
          //if (recvBuf[2] == 9) //len=9   //reg reader - no repeater
          if ((recvBuf[3] & 0x38) == 0x10)  //reg reader
          {
             n = (unsigned char)recvBuf[4];
             RxReaderIDLabel->Caption = n;  //reader ID

             //status Byte
             DisplayStatusByte(6, DISABLE_TAG);
             configIndex = 6;

             tgType = (unsigned char)recvBuf[6] & 0xE0;   //1110 0000
             tgType >>= 5;
             n = (unsigned int)((unsigned char)recvBuf[7])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[8])*pow(2, 16)+
                 (unsigned int)((unsigned char)recvBuf[9])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[10]);

             //n1 = (unsigned int)((unsigned char)recvBuf[7]);
             //n2 = (unsigned int)((unsigned char)recvBuf[8]);
             //n3 = (unsigned int)((unsigned char)recvBuf[9]);
             //n4 = (unsigned int)((unsigned char)recvBuf[10]);

             RxTagIDLabel->Caption = n;     //tag ID
             gID = ((unsigned char)recvBuf[6]) & 0x01;

          }
          else  //len = 10 (extended)  no repeater
          {
             n = (unsigned int)((unsigned char)recvBuf[4])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[5]);
             RxReaderIDLabel->Caption = n;  //reader ID

             //status Byte
             DisplayStatusByte(7, DISABLE_TAG);
             configIndex = 7;

             tgType = (unsigned char)recvBuf[7] & 0xE0;   //1110 0000
             tgType >>= 5;
             n = (unsigned int)((unsigned char)recvBuf[8])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[9])*pow(2, 16)+
                 (unsigned int)((unsigned char)recvBuf[10])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[11]);

             //n1 = (unsigned int)((unsigned char)recvBuf[8]);
             // n2 = (unsigned int)((unsigned char)recvBuf[9]);
             //n3 = (unsigned int)((unsigned char)recvBuf[10]);
             //n4 = (unsigned int)((unsigned char)recvBuf[11]);

             RxTagIDLabel->Caption = n;     //tag ID
             gID = ((unsigned char)recvBuf[7]) & 0x01;
          }

          if (!CheckDuplicatedDisabledTag(n, tgType))
          {
             StaticText->Caption = "";
             //if (n > 2000)
               //int stop = 0;
             DisplayTagInListView(n, tgType);
             disabledTagArray[arrayIndexDisabled].tagID = n;
             disabledTagArray[arrayIndexDisabled].tagType = tgType;
             arrayIndexDisabled++;

             /*if (tgType == 1) //acc
             {
                dTagAccCount++;
                dTagTotalCount++;
                DisableTagAccLabel->Caption = dTagAccCount;
             }
             else if (tgType == 3) //ass
             {
                dTagAssCount++;
                dTagTotalCount++;
                DisableTagAssLabel->Caption = dTagAssCount;
             }
             else if (tgType == 2) //inv
             {
                dTagInvCount++;
                dTagTotalCount++;
                DisableTagInvLabel->Caption = dTagInvCount;
             }
             else if (tgType == 7) //factory
             {
                dTagFactCount++;
                dTagTotalCount++;
                DisableTagFactLabel->Caption = dTagFactCount;
             }*/
             if (tgType == 1)
             {
                dTagType01Count++;
                dTagTotalCount++;
                DisableTagType01Label->Caption = dTagType01Count;
             }
             else if (tgType == 2)
             {
                dTagType02Count++;
                dTagTotalCount++;
                DisableTagType02Label->Caption = dTagType02Count;
             }
             else if (tgType == 3)
             {
                dTagType03Count++;
                dTagTotalCount++;
                DisableTagType03Label->Caption = dTagType03Count;
             }
             else if (tgType == 4)
             {
                dTagType04Count++;
                dTagTotalCount++;
                DisableTagType04Label->Caption = dTagType04Count;
             }
             else if (tgType == 5)
             {
                dTagType05Count++;
                dTagTotalCount++;
                DisableTagType05Label->Caption = dTagType05Count;
             }
             else if (tgType == 6)
             {
                dTagType06Count++;
                dTagTotalCount++;
                DisableTagType06Label->Caption = dTagType06Count;
             }
             else if (tgType == 7) //factory
             {
                dTagFactCount++;
                dTagTotalCount++;
                DisableTagFactoryLabel->Caption = dTagFactCount;
             }

             DisableTagTotalLabel->Caption = dTagTotalCount;

             str = "Tag ID ";
             str += n;
             str += " was Disabled successfully";
             StaticText->Caption = str;
          }
          RxCommandLabel->Caption = "Disable Tag ACK";
          PlaySound("Ding.wav", NULL, SND_ASYNC );
       break;

       case QUERY_TAG_ACK:   //0x09  ACK

          EnableTagStaticCommands();
          QueryTagBitBtn->Enabled = true;
          CMDEnableTimer->Enabled = false;

          receivedResponse = true;
          programming = false;
          DetectedMsg->Caption = "";
          TamperSWMsg->Caption = "";

          PlaySound("Ding.wav", NULL, SND_ASYNC );
          //if (recvBuf[2] == 13) //len=13  reg Rdr no repeater
          if ((recvBuf[3] & 0x38) == 0x10)  //00 110 000 ext rdr
          {
             nr = (unsigned char)recvBuf[4];
             RxReaderIDLabel->Caption = nr;  //reader ID

             //status Byte
             DisplayStatusByte(10, QUERY_TAG);
             configIndex = 10;

             n = (unsigned int)((unsigned char)recvBuf[6])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[7])*pow(2, 16)+
                 (unsigned int)((unsigned char)recvBuf[8])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[9]);
             RxTagIDLabel->Caption = n;     //tag ID
             gID = ((unsigned char)recvBuf[10]) & 0x01;
          }
          //else if (recvBuf[2] == 14) //len=14  ext Rdr - no repeater
          else if ((recvBuf[3] & 0x38) == 0x30)  //reg reader
          {
             nr = (unsigned int)((unsigned char)recvBuf[4])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[5]);
             RxReaderIDLabel->Caption = nr;  //reader ID

             //status Byte
             DisplayStatusByte(11, QUERY_TAG);
             configIndex = 11;

             n = (unsigned int)((unsigned char)recvBuf[7])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[8])*pow(2, 16)+
                 (unsigned int)((unsigned char)recvBuf[9])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[10]);
             RxTagIDLabel->Caption = n;     //tag ID
             gID = ((unsigned char)recvBuf[11]) & 0x01;
          }
          else
             return;

          if (!CheckSameTag(n, tgType, fGenID, gID, fGenFlag, gIDFlag, dIndex, nr, QUERY_TAG, rssi) || multiDisplayTagDetect)
          {
             if (*gIDFlag || *fGenFlag)
             {
                queIndex = *dIndex;
                //nDuplicates++;
             }
             else
             {
                queIndex = tagDetectCount;
                /*if (tgType == 0x01) //access
                   accTagCount += 1;
                else if (tgType == 0x02) //inventory
                   invTagCount += 1;
                else if (tgType == 0x03) //asset
                   assTagCount += 1;
                else if (tgType == 0x04) //car
                   carTagCount += 1;

                if (multiDisplayTagDetect)
                   nDuplicates++;*/
             }

             LoadStatusByteToQue(configIndex, TAG_DETECTED, queIndex);

             tagDetectedArray[queIndex].lastDetectTime = Now();

             tagDetectedArray[queIndex].tagID = n;
             tagDetectedArray[queIndex].readerID = nr;
             tagDetectedArray[queIndex].cmd = QUERY_TAG;
             tagDetectedArray[queIndex].tagType = tgType;
             tagDetectedArray[queIndex].rssi = rssi;

             if (fGenID > 0)
                tagDetectedArray[queIndex].fGenID = fGenID;
             else
                tagDetectedArray[queIndex].fGenID = 0;
             tagDetectedArray[queIndex].gID = gID;

             DisplayTagInListView(queIndex, fGenID, gID, fGenFlag, gIDFlag, 0, "QRY"); //(DetectedTagListView->Items->Count);

             if (QueryTagKeepItemsCheckBox->Checked)
             {
                if (!IsItemInList(n))
                   DisplayTagInfo(n, configIndex);
             }
             else
                DisplayTagInfo(n, configIndex);


             if ((*gIDFlag == false) && (*fGenFlag == false))
                tagDetectCount++;

             if (global)
                PlaySound("Ding.wav", NULL, SND_ASYNC );
          }
          else
          {
             if (configIndex > 0)
                UpdateTagDetectedArray(nr, fGenID, n, tgType, configIndex);
          }

          RxCommandLabel->Caption = "Query Tag ACK";
          str = RxTagTypeLabel->Caption;
          str += " Tag ";
          str += n;
          //str += " detected.";
          if (RxTamperLabel->Caption == "Yes")
             TamperSWMsg->Caption = "Tamper  Switch  Enabled !";
          else
             TamperSWMsg->Caption = "";
          DetectedMsg->Caption = str;

       break;

       case CALL_TAG_ACK:   // 0x0A ACK

          EnableTagStaticCommands();
          CMDEnableTimer->Enabled = false;
          CallTagBitBtn->Enabled = true;

          receivedResponse = true;
          DetectedMsg->Caption = "";
          TamperSWMsg->Caption = "";
          //if (recvBuf[2] == 4) //len=4
          if ((recvBuf[3] & 0x38) == 0x10)  //reg reader
          {
             n = (unsigned char)recvBuf[4];
             RxReaderIDLabel->Caption = n;  //reader ID
          }
          else  //len = 4 (extended)
          {
             n = (unsigned int)((unsigned char)recvBuf[4])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[5]);
             RxReaderIDLabel->Caption = n;  //reader ID
          }

          RxCommandLabel->Caption = "Call Tag ACK";

          /*str = RxTagTypeLabel->Caption;
          str += " Tag ";
          str += n;
          //str += " detected.";
          DetectedMsg->Caption = str;
          if (RxTamperLabel->Caption == "Yes")
             TamperSWMsg->Caption = "Tamper  Switch  Enabled !";
          else
             TamperSWMsg->Caption = ""; */
          PlaySound("Ding.wav", NULL, SND_ASYNC );
       break;

       case READER_CODE_VER_ACK:  //0x8D ACK
          receivedResponse = true;
          //if (recvBuf[2] == 7) //len=7
          if ((recvBuf[3] & 0x38) == 0x10)  //reg reader
          {
             TListItem* ListItem;
             ListItem = RdrCodeVerListView->Items->Add();
             ListItem->ImageIndex = -1;

             n = (unsigned char)recvBuf[4];
             RxReaderIDLabel->Caption = n;  //reader ID
             ListItem->SubItems->Add(n);
             ListItem->SubItems->Add((unsigned char)recvBuf[6]);  //DataCodeVersion
             ListItem->SubItems->Add((unsigned char)recvBuf[7]);  //ProgCodeVersion
             ListItem->SubItems->Add((unsigned char)recvBuf[8]);  //HostCodeVersion

             //DataCodeVerLabel->Caption = (unsigned char)recvBuf[6];
             //ProgCodeVerLabel->Caption = (unsigned char)recvBuf[7];
             //HostCodeVerLabel->Caption = (unsigned char)recvBuf[8];
          }
          else  //len = 8 (extended)
          {
             n = (unsigned int)((unsigned char)recvBuf[4])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[5]);
             RxReaderIDLabel->Caption = n;  //reader ID

             TListItem* ListItem;
             ListItem = RdrCodeVerListView->Items->Add();
             ListItem->ImageIndex = -1;

             ListItem->SubItems->Add(n);
             ListItem->SubItems->Add((unsigned char)recvBuf[7]);  //DataCodeVersion
             ListItem->SubItems->Add((unsigned char)recvBuf[8]);  //ProgCodeVersion
             ListItem->SubItems->Add((unsigned char)recvBuf[9]);  //HostCodeVersion

             //DataCodeVerLabel->Caption = (unsigned char)recvBuf[7];
             //ProgCodeVerLabel->Caption = (unsigned char)recvBuf[8];
             //HostCodeVerLabel->Caption = (unsigned char)recvBuf[9];
          }

          RxCommandLabel->Caption = "Reader Code Version ACK";
          str = "Reader ID ";
          str += n;
          str += "  Code Version.";
          StaticText->Caption = str;
          PlaySound("Ding.wav", NULL, SND_ASYNC );

       break;

       case ASSIGN_READER_ACK:  //0x8E ACK
          receivedResponse = true;
          str = "Reader ID ";
          str += AssignReaderIDComboBox->Text; // AssignReaderIDComboBox->Text;
          str += "  was configured successfully.";
          StaticText->Caption = str;

          if ((recvBuf[3] & 0x38) == 0x10)  //reg reader
             n = (unsigned char)recvBuf[4];
          else  //len = 6 (extended)
             n = (unsigned int)((unsigned char)recvBuf[4])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[5]);

          if (networkOn)
          {
             int oldRdr = atoi(AssignReaderIDComboBox->Text.c_str());
             nr = GetSocketIndex(oldRdr);
             if (nr >= 0)
             {
                AWSockets[nr]->reader = n; //atoi(AssignReaderNewIDEdit->Text.c_str());
             }
             else
                StaticText->Caption = "No matching socket for the reader.";
          }

          idStr = AssignReaderNewIDEdit->Text;
          if (idStr.data() != NULL)
          {
             if (AssignReaderIDComboBox->Items->IndexOf(idStr) == -1 )
                AssignReaderIDComboBox->Items->Add(idStr);

             AssignReaderIDComboBox->Text = idStr;
             lastReaderID = atoi(idStr.c_str());

             if (!CheckDuplicatedReader(atoi(idStr.c_str())))
                  readerIDList[numReaderIDList++] = atoi(idStr.c_str());

             ResetReaderIDComboBox->Text = idStr;
             ResetBroadcastReaderCheckBox->Checked = false;

             //DisplayReadersInViewList("", idStr);
          }
          else
          {
             idStr = AssignReaderIDComboBox->Text;
             if (!CheckDuplicatedReader(atoi(idStr.c_str())))
                readerIDList[numReaderIDList++] = atoi(idStr.c_str());
             //DisplayReadersInViewList("", idStr);

          }

          if (allHostID)
          {
             idStr = AssignReaderNewHostIDEdit->Text;
             if (idStr.data() != NULL)
             {
                AssignReaderHostIDEdit->Text = idStr; //AssignReaderNewHostIDEdit->Text;
                lastHostID = atoi(AssignReaderHostIDEdit->Text.c_str());
             }
          }

          //str = "Host ID: ";
          //str += AssignReaderHostIDEdit->Text;
          //MainStatusBar->Panels->Items[5]->Text =  str;
          //lastHostID = atoi(AssignReaderHostIDEdit->Text.c_str());
          RxCommandLabel->Caption = "Assign Reader ACK";
          PlaySound("Ding.wav", NULL, SND_ASYNC );

          //reseting the reader
          //-----------------------------------------
          if(networkOn)
          {
             int index = GetSocketIndex(n);
             if (index >= 0)
                WriteAWSocket(RESET_DEVICE, 0, NULL, 0, 'S', NULL, 0, index);
             else
                StaticText->Caption = "No matching socket for the reader.";
          }
          else if (RS232On)
          {
             WriteRS232Comm(RESET_DEVICE, 0, NULL, 0);
          }

       break;

       case QUERY_READER_ACK:  //0x0F ACK
          receivedResponse = true;
          Sleep (200);
          //if (recvBuf[2] == 5) //len=5
          if ((recvBuf[3] & 0x38) == 0x10)  //reg reader
          {
             n = (unsigned char)recvBuf[4];
             RxReaderIDLabel->Caption = n;  //reader ID
             //readerType = (recvBuf[6] & 0x0F);
             readerType = (((unsigned char)recvBuf[6]) & 0x0F);
             readerConfig = ((recvBuf[6] & 0xF0) >> 4);
             lastReaderID = n;
             if (allHostID)
                lastHostID = (unsigned char)recvBuf[5];
          }
          else  //len = 6 (extended)
          {
             n = (unsigned int)((unsigned char)recvBuf[4])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[5]);
             RxReaderIDLabel->Caption = n;  //reader ID
             readerType = (((unsigned char)recvBuf[7]) & 0x0F);
             readerConfig = ((((unsigned char)recvBuf[7]) & 0xF0) >> 4);
             lastReaderID = n;
             if (allHostID)
                lastHostID = (unsigned char)recvBuf[6];
          }

          if (AssignReaderGroupBox->Visible)   //config reader screen  *********
          {
              if (readerType == 1)
              {
                 AssignReaderTypeComboBox->Text = "Programming Station";
              }
              else if (readerType == 2)
              {
                 AssignReaderTypeComboBox->Text = "Standard Reader";
                 ChangeConfigReaderSTDControls(false);
              }
              else if (readerType == 3)
              {
                 AssignReaderTypeComboBox->Text = "Access Control";
              }
              else if (readerType == 4)
              {
                 AssignReaderTypeComboBox->Text = "Small RF Reader";
              }
              else if (readerType == 5)
              {
                 AssignReaderTypeComboBox->Text = "PDA Reader";
              }
              else if (readerType == 6)
              {
                 AssignReaderTypeComboBox->Text = "FGen Reader";
                 ChangeConfigReaderSTDControls(true);
              }
              else if (readerType == 7)
              {
                 AssignReaderTypeComboBox->Text = "SaniFaucet Door Unit";
                 ChangeConfigReaderSTDControls(true);
              }
              else if (readerType == 8)
              {
                 AssignReaderTypeComboBox->Text = "SaniFaucet Faucet Unit";
                 ChangeConfigReaderSTDControls(false);
              }
              else if (readerType == 9)
              {
                 AssignReaderTypeComboBox->Text = "SaniFaucet Sanitization Unit";
                 ChangeConfigReaderSTDControls(true);
              }
              else if (readerType == 10)
              {
                 AssignReaderTypeComboBox->Text = "SaniFaucet Contamination Unit";
                 ChangeConfigReaderSTDControls(true);
              }
              else if (readerType == 11)
              {
                 AssignReaderTypeComboBox->Text = "SaniFaucet Bed Unit";
                 ChangeConfigReaderSTDControls(true);
              }
              else if (readerType == 12)
              {
                 AssignReaderTypeComboBox->Text = "Query FGen Reader";
                 ChangeConfigReaderSTDControls(true);
              }

              if ((readerConfig & 0x01) == 0x01)
                 AssignReaderBroadcastCheckBox->Checked = false;
              else
                 AssignReaderBroadcastCheckBox->Checked = true;

              if ((readerConfig & 0x02) == 0x02)
                 AssignReaderEnableCheckBox->Checked = false;
              else
                 AssignReaderEnableCheckBox->Checked = true;

              if ((readerConfig & 0x04) == 0x04)
                 AssignReaderRSSICheckBox->Checked = true;
              else
                 AssignReaderRSSICheckBox->Checked = false;

              if(networkOn)
              {
                  int rdr = atoi(AssignReaderIDComboBox->Text.c_str());
                  int index = GetSocketIndex(rdr);
                  if (index >= 0)
                  {
                     WriteAWSocket(GET_READER_CONFIG, 0, NULL, index, 'S', NULL, 0, index);
                  }
                  else
                     StaticText->Caption = "No matching socket for the reader.";
              }
              else if (RS232On)
              {
                  WriteRS232Comm(GET_READER_CONFIG, 0, NULL, 0);
              }
          }
          else   //query reader screen
          {
          Label24->Visible = false;
          RxTagVersionLabel->Visible = false;
          Label11->Caption = "Reader Type: ";
          RxTagTypeLabel->Left = 75;
          idStr = n;

          if (QueryReaderIDComboBox->Items->IndexOf(idStr) == -1 )
          {
             QueryReaderIDComboBox->Items->Add(idStr);
          }
          QueryReaderIDComboBox->Text = idStr;

          if (!CheckDuplicatedReader(n))
             readerIDList[numReaderIDList++] = n;

          if ((readerConfig & 0x01) == 0x01)
             a = false;
          else
             a = true;

          if ((readerConfig & 0x02) == 0x02)
             b = false;
          else
             b = true;

          if ((readerConfig & 0x04) == 0x04)
            c = true;
          else
            c = false;

          if (readerType == 1)
          {
             DisplayQueryReadersInViewList(n, "Programming Station", a, b, c);
             RxTagTypeLabel->Caption = "Programming Station";
             //DetectedMsg->Caption = "Programming Station Reader ID " + idStr;
          }
          else if (readerType == 2)
          {
             if (n <= 255)
                DisplayQueryReadersInViewList(n, "Standard Reader", a, b, c);
             else
                DisplayQueryReadersInViewList(n, "Ext. Standard Reader", a, b, c);
             RxTagTypeLabel->Caption = "Standard Reader";
             //DetectedMsg->Caption = "Standard Reader ID " + idStr;
          }
          else if (readerType == 3)
          {
             DisplayQueryReadersInViewList(n, "Access Control", a, b, c);
             RxTagTypeLabel->Caption = "Access Control";
             //DetectedMsg->Caption = "Access Control Reader ID " + idStr;
          }
          else if (readerType == 4)
          {
             DisplayQueryReadersInViewList(n, "Small RF", a, b, c);
             RxTagTypeLabel->Caption = "Small RF Reader";
             //DetectedMsg->Caption = "Small RF Reader ID " + idStr;
          }
          else if (readerType == 5)
          {
             DisplayQueryReadersInViewList(n, "PDA Reader", a, b, c);
             RxTagTypeLabel->Caption = "PDA Reader";
             //DetectedMsg->Caption = "PDA Reader ID " + idStr;
          }
          else if (readerType == 6)
          {
             DisplayQueryReadersInViewList(n, "FGen Reader", a, b, c);
             RxTagTypeLabel->Caption = "FGen Reader";
             //DetectedMsg->Caption = "FGen Reader ID " + idStr;
          }
          else if (readerType == 7)
          {
             DisplayQueryReadersInViewList(n, "SaniFaucet Door Unit", a, b, c);
             RxTagTypeLabel->Caption = "SaniFaucet Door Unit";
             //DetectedMsg->Caption = "SaniFaucet Door Unit ID " + idStr;
          }
          else if (readerType == 8)
          {
             DisplayQueryReadersInViewList(n, "SaniFaucet Faucet Unit", a, b, c);
             RxTagTypeLabel->Caption = "SaniFaucet Faucet Unit";
             //DetectedMsg->Caption = "SaniFaucet Faucet Unit ID " + idStr;
          }
          else if (readerType == 9)
          {
             DisplayQueryReadersInViewList(n, "SaniFaucet Sanitization Unit", a, b, c);
             RxTagTypeLabel->Caption = "SaniFaucet Sanitization Unit";
             //DetectedMsg->Caption = "SaniFaucet Sanitization Unit ID " + idStr;
          }
          else if (readerType == 10)
          {
             DisplayQueryReadersInViewList(n, "SaniFaucet Contamination Unit", a, b, c);
             RxTagTypeLabel->Caption = "SaniFaucet Contamination Unit";
             //DetectedMsg->Caption = "SaniFaucet Contamination Unit ID " + idStr;
          }
          else if (readerType == 11)
          {
             DisplayQueryReadersInViewList(n, "SaniFaucet Bed Unit", a, b, c);
             RxTagTypeLabel->Caption = "SaniFaucet Bed Unit";
             //DetectedMsg->Caption = "SaniFaucet Bed Unit ID " + idStr;
          }
          else if (readerType == 12)
          {
             DisplayQueryReadersInViewList(n, "Query FGen Reader", a, b, c);
             RxTagTypeLabel->Caption = "Query FGen Reader";
             //DetectedMsg->Caption = "Query FGen Reader ID " + idStr;
          }
          else
          {
             DisplayQueryReadersInViewList(n, " ", a, b, c);
             RxTagTypeLabel->Caption = "";
          }

          RxCommandLabel->Caption = "Query Reader ACK";
          StaticText->Caption = "";
          }  //if query reader screen

          PlaySound("Ding.wav", NULL, SND_ASYNC );
       break;

       //case 0x11:  //0x11
           //WriteComm(0x11, 0, &recvBuf[7]);
       //break;
       case CALL_TAG_SMART_FGEN_ACK:

           CMDEnableTimer->Enabled = false;
           EnableSmartFGenStaticCommands();
           SmartFGenBitBtn->Enabled = true;

           RxCommandLabel->Caption = "Call Smart FGen ACK";
           StaticText->Caption = "Call Tag to Smart FGen was executed successfully";
           PlaySound("Ding.wav", NULL, SND_ASYNC );
           //EnableAllStaticTextCommands();
       break; //CALL_TAG_SMART_FGEN_ACK

       case CONFIG_FIELD_GEN_ACK:  //CONFIG_TX_TIME_ACK  0xA0 -> ACK   0x02
          receivedResponse = true;

          readerOffLine = true;
          readerOnLine = false;
          fieldGenOffLine = false;
          fieldGenOnLine = true;
          EnableAllStaticTextCommands();

          if (AssignReaderGroupBox->Visible)
          {
             rdrConfigTxFlag = false;
             RxCommandLabel->Caption = "Config Reader TX Time ACK";
             str = "Reader Tx Time was configured successfully.";
             StaticText->Caption = str;
             PlaySound("Ding.wav", NULL, SND_ASYNC );

             ////////////////////////////////////////////////////////////////////

             if (rdrConfigFlag)
             {
                if(networkOn)
                {
                    int rdr = atoi(AssignReaderIDComboBox->Text.c_str());
                    int index = GetSocketIndex(rdr);
                    if (index >= 0)
                    {
                        WriteAWSocket(ASSIGN_READER, 0, NULL, index, 'S', NULL, 0, index);
                    }
                    else
                        StaticText->Caption = "No matching socket for the reader.";
                }
                else if (RS232On)
                {
                    WriteRS232Comm(ASSIGN_READER, 0, NULL, 0);
                }

                rdrConfigFlag = false;
             }
                 /*unsigned short newRdrID;
                 unsigned short hostID;
                 unsigned short rdrID;
                 unsigned short newHostID;

                 rdrConfigFlag = false;
                 rdrConfigTxFlag = false;

                 if (AssignReaderNewIDEdit->Text.data() == NULL)
                     newRdrID = rdrID;
                 else
                 {
                    newRdrID = atoi(AssignReaderNewIDEdit->Text.c_str());
                    if (newRdrID > 255)
                    {
                       Application->MessageBox("Error: Extended Reader Has Not Been Implememted Yet.",
                                               "Programming Station Information Dialog",
                                               MB_OK | MB_ICONSTOP | MB_TOPMOST);
                       AssignReaderBitBtn->Enabled = true;
                       StaticText->Caption = "";
                       return;
                    }
                 }

                 if (AssignReaderNewHostIDEdit->Text.data() == NULL)
                    newHostID = hostID;
                 else
                    newHostID = atoi(AssignReaderNewHostIDEdit->Text.c_str());

                 if (!newHostID)
                 {
                     Application->MessageBox("Error: New Host ID Can Not Be Zero",
                                             "Programming Station Information Dialog",
                                             MB_OK | MB_ICONSTOP | MB_TOPMOST);
                     AssignReaderBitBtn->Enabled = true;
                     return;
                 }

                 if (!newRdrID)
                 {
                    Application->MessageBox("Error: New Reader ID Can Not Be Zero",
                                            "Programming Station Information Dialog",
                                            MB_OK | MB_ICONSTOP | MB_TOPMOST);
                    AssignReaderBitBtn->Enabled = true;
                    return;
                 }

                 if (rdrID <= 255)  //standard reader
                 {
                    XBuf[3] = 0x0A;
                    XBuf[4] = hostID;
                    XBuf[5] = rdrID;
                    index = 6;
     //{
                    if (newRdrID <= 255)  //new standard reader address
                    {
                       XBuf[index++] = 0x0A;
                       XBuf[index++] = newHostID;
                       XBuf[index++] = newRdrID;
                    }
                    else
                    {
                       XBuf[index++] = 0x0E;
                       XBuf[index++] = newHostID;

                       str = IntToHex(newRdrID, 4);
                       XBuf[index++] = HexToInt(str.c_str(), 2);   //reader ID
                       str = str.SubString(3,2);
                       XBuf[index++] = HexToInt(str.c_str(), 2);   //reader ID
                    }
                 }
                else   //extended reader
                {
                   XBuf[3] = 0x0E;
                   XBuf[4] = hostID;

                   str = IntToHex(rdrID, 4);
                   XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
                   str = str.SubString(3,2);
                   XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
                   index = 7;
     //{
                   if (newRdrID <= 255)  //new standard reader address
                   {
                      XBuf[7] = 0x0A;
                      XBuf[8] = newHostID;
                      XBuf[9] = newRdrID;
                      index = 10;
                   }
                   else
                   {
                      XBuf[7] = 0x0E;
                      XBuf[8] = newHostID;

                      str = IntToHex(newRdrID, 4);
                      XBuf[9] = HexToInt(str.c_str(), 2);   //reader ID
                      str = str.SubString(3,2);
                      XBuf[10] = HexToInt(str.c_str(), 2);   //reader ID
                      index = 11;
                   }
                }

                XBuf[index] = 0x00;  //Config byte for reader - no change

                if (AssignReaderNoChangeCheckBox->Checked)  //modify button
                {
                    //XBuf[index] = 0x80;   //1 000 0000  wrong@@

                    //ReaderType
                   //if (AssignReaderTypeComboBox->ItemIndex >= 0)
                   //XBuf[index] |= AssignReaderTypeComboBox->ItemIndex; //ReaderTypeComboBox->ItemIndex;
                   //XBuf[index] = 0x02;   //Std reader

                   if (!AssignReaderBroadcastCheckBox->Checked)   //broadcast
                      XBuf[index] |= 0x10;   //0001 0000

                   if (!AssignReaderEnableCheckBox->Checked)   //enable pwrup
                      XBuf[index] |= 0x20;   //0010 0000

                   if (AssignReaderRSSICheckBox->Checked)
                      XBuf[index] |= 0x40;   //0100 0000   send RSSI

                   XBuf[index] |= 0x80;   //1000 0000   reader enable (not on screen)
                }
               else  //reader config needs to be sent allways - reader type bit 0 = no change
               {
                   if (!AssignReaderBroadcastCheckBox->Checked)   //broadcast
                      XBuf[index] |= 0x10;   //0001 0000

                   if (!AssignReaderEnableCheckBox->Checked)   //enable pwrup
                      XBuf[index] |= 0x20;   //0010 0000

                   if (AssignReaderRSSICheckBox->Checked)
                      XBuf[index] |= 0x40;   //0100 0000   send RSSI

                   XBuf[index] |= 0x80;   //1000 0000   reader enable (not on screen)

               }

               index += 1;

               XBuf[index] = 0x00;
               index += 1;
               XBuf[index] = 0x00;
               index += 1;
               XBuf[index] = 0xAF;  //pktID
               XBuf[2] = index - 2; //len
               index += 1;
               //Generating CRC
               crc = 0xFFFF;
               for (i=0; i<index; i++)    //index = len whole packet
                   Generate_CRC(XBuf[i]);

               XBuf[index++] = (char)(crc & 0x00FF) ^ 0xFF;       //LSB first
               XBuf[index] = (char)((crc >> 8) & 0x00FF) ^ 0xFF;  //MSB

            }//if rdrFlag TRUE */
             ////////////////////////////////////////////////////////////////////
          }
          else
          {
             n = (unsigned char)recvBuf[4]; //field gen ID

             if (FGenConfigFGenIDModifyCheckBox->Checked)
             {
                FGenConfigFieldGenIDEdit->Text = newFGID;

                if (SFGenConfigFGenIDEdit->Text.data() != NULL)
                   lastFieldGenID = atoi(newFGID.c_str());

                //lastFieldGenID = atoi(newFGID.c_str());
             }
             RxCommandLabel->Caption = "Config Field Gen ACK";
             str = "Field Gen ID ";
             str += n;
             str += "  was configured successfully.";
             StaticText->Caption = str;
             PlaySound("Ding.wav", NULL, SND_ASYNC );
          }
       break;

       case DEFINE_TAG_READER_ACK:  //0x90

          EnableTagStaticCommands();
          CMDEnableTimer->Enabled = false;
          AssignTagRdrBitBtn->Enabled = true;

          receivedResponse = true;
          if ((recvBuf[3] & 0x38) == 0x30)  //00 110 000 ext rdr
          {
                nr = (unsigned int)((unsigned char)recvBuf[4])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[5]);
                tgType = (unsigned char)recvBuf[6] & 0xE0;   //1110 0000
                tgType >>= 5;
                n = (unsigned int)((unsigned char)recvBuf[7])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[8])*pow(2, 16)+
                    (unsigned int)((unsigned char)recvBuf[9])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[10]);
          }
          //else   //reg rdr + field gen
          else if ((recvBuf[3] & 0x38) == 0x10)  //reg reader
          {
                nr = (unsigned char)recvBuf[4];
                tgType = (unsigned char)recvBuf[6] & 0xE0;   //1110 0000
                tgType >>= 5;
                n = (unsigned int)((unsigned char)recvBuf[7])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[8])*pow(2, 16)+
                    (unsigned int)((unsigned char)recvBuf[9])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[10]);
          }
          else
             return;

          if (!CheckDuplicatedTag(n, tgType))
          {
             DisplayTagInListView(n, tgType);
             tagArray[arrayIndex].tagID = n;
             tagArray[arrayIndex].tagType = tgType;
             arrayIndex++;
             str = "Reader ID ";
             str += assignedTagRdrID;
             str += " was assigned to Tag ID ";
             str += n;
             str += " successfully";
             StaticText->Caption = str;
             PlaySound("Ding.wav", NULL, SND_ASYNC );
          }

       break;

       case CONFIG_TAG_RND_ACK:  //0x92

          EnableTagStaticCommands();
          CMDEnableTimer->Enabled = false;
          ConfigTagRNDBitBtn->Enabled = true;

          receivedResponse = true;
          if ((recvBuf[3] & 0x38) == 0x30)  //00 110 000 ext rdr
          {
                nr = (unsigned int)((unsigned char)recvBuf[4])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[5]);
                tgType = (unsigned char)recvBuf[6] & 0xE0;   //1110 0000
                tgType >>= 5;
                n = (unsigned int)((unsigned char)recvBuf[7])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[8])*pow(2, 16)+
                    (unsigned int)((unsigned char)recvBuf[9])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[10]);
          }
          //else   //reg rdr + field gen
          else if ((recvBuf[3] & 0x38) == 0x10)  //reg reader
          {
                nr = (unsigned char)recvBuf[4];
                tgType = (unsigned char)recvBuf[6] & 0xE0;   //1110 0000
                tgType >>= 5;
                n = (unsigned int)((unsigned char)recvBuf[7])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[8])*pow(2, 16)+
                    (unsigned int)((unsigned char)recvBuf[9])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[10]);
          }
          else
            return;

          if (!CheckDuplicatedTag(n, tgType))
          {
             DisplayTagInListView(n, tgType);
             tagArray[arrayIndex].tagID = n;
             tagArray[arrayIndex].tagType = tgType;
             arrayIndex++;
             StaticText->Caption = "Tag Random Number was configured successfully";
             ConfigTagRNDBitBtn->Font->Color = clTeal;
             PlaySound("Ding.wav", NULL, SND_ASYNC );
          }

       break;

       case QUERY_FIELD_GEN_ACK: //0xA1   ACK
          receivedResponse = true;

          if ((recvBuf[3] & 0x38) == 0x00)  // Fgen
          {
             if ((unsigned char)recvBuf[2] == 0x06)
             {
                pktID = (unsigned char)recvBuf[8];
                a = true;  //older ver no FS
             }
             else
             {
                if ((unsigned char)recvBuf[2] == 0x0D)    //new ver with motion detector
                   pktID = (unsigned char)recvBuf[0x0F];
                else
                   pktID = (unsigned char)recvBuf[9];
                a = false; //new version with FS
             }
             rID = (unsigned char)recvBuf[4];
             hID = (unsigned char)recvBuf[5];
             index = 6;

             pktLen = (unsigned char)(recvBuf[2]);

             if (pktLen == 0x0D) //new version
             {
                 stdFGenType = 0x01;
             }
             else
             {
                stdFGenType = 0x00;
             }
          }
          else
          {
             /*if ((unsigned char)recvBuf[2] == 0x07)
             {
                pktID = (unsigned char)recvBuf[9];
                a = true;  //older ver no FS
             }
             else
             {
                pktID = (unsigned char)recvBuf[10];
                a = false; //new version with FS
             }*/

             pktID = (unsigned char)recvBuf[(unsigned char)recvBuf[2] + 2];
             if ((recvBuf[3] & 0x38) == 0x30)  //00 110 000 ext rdr
             {
                rID = (unsigned int)((unsigned char)recvBuf[4])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[5]);
                hID = (unsigned char)recvBuf[6];
                index = 7;
             }
             else if ((recvBuf[3] & 0x38) == 0x10)  //reg reader
             {
                rID = (unsigned char)recvBuf[4];
                hID = (unsigned char)recvBuf[5];
                index = 6;
             }
             else
               return;


             //rID = (unsigned int)((unsigned char)recvBuf[4])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[5]);
             //hID = (unsigned char)recvBuf[6];
             //index = 7;
          }
          /*pktLen = (unsigned char)(recvBuf[2]);
          if (pktLen == 0x0D) //new version
          {
              stdFGenType = 0x01;
          }
          else
          {
             stdFGenType = 0x00;
          }*/

          if (SetFStrengthGroupBox->Visible)   //Set Field Strength Screen
          {
              index += 2;
              ReaderModifyTXFComboBox->Text = (unsigned char)(recvBuf[index] & 0x1F);
              ReaderFStrengthLabel->Caption = (unsigned char)(recvBuf[index] & 0x1F);
              if (recvBuf[index] & 0x20)  // 00 1 0 0000  long distance
              {
                 ReaderLongRangeRadioButton->Checked = true;
                 ReaderShortRangeRadioButton->Checked = false;
              }
              else
              {
                 ReaderLongRangeRadioButton->Checked = false;
                 ReaderShortRangeRadioButton->Checked = true;
              }

              StaticText->Caption = "Received Field Strength data successfully.";
              PlaySound("Ding.wav", NULL, SND_ASYNC );

          }//SetFStrengthGroupBox
          else if (AssignReaderGroupBox->Visible && (pktID == 0xC0))  // ****** CONFIG READER SCREEN *********
          {

            tTime = (unsigned char)(recvBuf[index]);    //transmit time
            if ((tTime & 0x80) == 0x80)
            {
                b = true;  //MDActiveHi
                AssignReaderMDActiveHiRadioButton->Checked = true;
            }
            else
            {
                b = false;  //MDActiveLow
                AssignReaderMDActiveLoRadioButton->Checked = true;
            }

            if ((recvBuf[index] & 0x40) == 0x40)      //Motion detector
            {
               c = true;   //MDEnable
               AssignReaderEnableMDCheckBox->Checked = true;
            }
            else
            {
               c = false;  //MDdisable
               AssignReaderEnableMDCheckBox->Checked = false;
            }

            index += 1;
            wTime = (unsigned char)(recvBuf[index] & 0x3F);  //0011 1111   Wait Time
            AssignReaderWTComboBox->Text = wTime;
            if (((unsigned char)recvBuf[index] & 0xC0) == 0x00)  //00 00 0000
            {
               nr = 0;

               AssignReaderWTSecRadioButton->Checked = true;
            }
            else if (((unsigned char)recvBuf[index] & 0xC0) == 0x40)  //01 00 0000
            {
               nr = 1;
               AssignReaderWTMinRadioButton->Checked = true;
            }
            else if (((unsigned char)recvBuf[index] & 0xC0) == 0x80)  //10 00 0000
            {
               nr = 2;
               AssignReaderWTHourRadioButton->Checked = true;
            }
            else
               nr = 3;

            index += 1;

            int dpot;
            if (a) //old version
               dpot = -1;
            else
               dpot = (unsigned char)(recvBuf[index] & 0x1F);

            DisplayConfigRdrListView(rID, hID, tTime, nr, wTime, c, b, dpot);
            StaticText->Caption = "Received configuration data successfully.";
          }
          else    //STD Field Generator  *********************************
          {
              readerOffLine = true;
              readerOnLine = false;
              fieldGenOffLine = false;
              fieldGenOnLine = true;

              //to find out if new version of STD FGen
              int pktLen = (unsigned char)recvBuf[2];
              if (pktLen == 0x0D) //new version
              {
                  //stdFGenType = 0x01;
                  //FGenConfigHoldTimeCheckBox->Enabled = false;
                  FGenConfigHTimeLabel->Enabled = true;
                  //FGenConfigHoldTimeComboBox->Enabled = false;
                  FGenConfigHoldTimeLabel->Enabled = true;
                  //FGenConfigEnableISLabel->Enabled = true;
              }
              else  //old version   0x0C
              {
                  //stdFGenType = 0x00;
                  //FGenConfigHoldTimeCheckBox->Enabled = false;
                  FGenConfigHTimeLabel->Enabled = false;
                  FGenConfigHoldTimeComboBox->Enabled = false;
                  FGenConfigHoldTimeLabel->Enabled = false;
                  //FGenConfigEnableISLabel->Enabled = false;
              }

              fGenID = (unsigned char)recvBuf[4];
              lastFieldGenID = fGenID;

              if ( stdFGenType == 0x00)
              {
                 hID = (unsigned char)recvBuf[5];

                 if (recvBuf[2] == 0x0C)  //reg reader
                 {
                    rID = (unsigned char)recvBuf[6];
                    index = 7;
                 }
                 else if (recvBuf[2] == 0x0D)  //ext reader)
                 {
                     rID = (unsigned int)((unsigned char)recvBuf[6])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[7]);
                     index = 8;
                 }
                 else
                    return;
             }
             else
             {
                 hID = (unsigned char)recvBuf[5];

                 if (recvBuf[2] == 0x0D)  //reg reader
                 {
                    rID = (unsigned char)recvBuf[6];
                    index = 7;
                 }
                 else if (recvBuf[2] == 0x0E)  //ext reader)
                 {
                     rID = (unsigned int)((unsigned char)recvBuf[6])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[7]);
                     index = 8;
                 }
                 else
                    return;

             }

             tTime = (unsigned char)recvBuf[index]; // & 0x1F);

             index += 1;
             configIndex = index; //index to be used for PIR setting later in the code
             wTime = (unsigned char)(recvBuf[index] & 0x3F);   //0011 1111
             if (((unsigned char)recvBuf[index] & 0xC0) == 0x00)  //00 00 0000
                nr = 0;
             else if (((unsigned char)recvBuf[index] & 0xC0) == 0x40)  //01 00 0000
                nr = 1;
             else if (((unsigned char)recvBuf[index] & 0xC0) == 0x80)  //10 00 0000
                nr = 2;
             else
                nr = 3;

             index += 1;
             int p = 0;

             if (stdFGenType == 0x01)  //new std fgen
             {
                hTime = (unsigned char)(recvBuf[index] & 0x1F);  //0001 1111   Hold Time
                FGenConfigHoldTimeComboBox->Text = hTime;   //0011 1111;
                if (((unsigned char)recvBuf[index] & 0xC0) == 0x00)  //00 00 0000
                {
                    FGenConfigHoldTimeLabel->Caption = "sec";
                    //FGenConfigWaitTimeSecRadioButton->Checked = true;
                    //FGenConfigWaitTimeMinRadioButton->Checked = false;
                    //FGenConfigWaitTimeHourRadioButton->Checked = false;
                }
                else if (((unsigned char)recvBuf[index] & 0xC0) == 0x40)  //01 00 0000
                {
                    FGenConfigHoldTimeLabel->Caption = "min";
                    //FGenConfigWaitTimeSecRadioButton->Checked = false;
                    //FGenConfigWaitTimeMinRadioButton->Checked = true;
                    //FGenConfigWaitTimeHourRadioButton->Checked = false;
                }
                else if (((unsigned char)recvBuf[index] & 0xC0) == 0x80)  //10 00 0000
                {
                    FGenConfigHoldTimeLabel->Caption = "hour";
                    //FGenConfigWaitTimeSecRadioButton->Checked = false;
                    //FGenConfigWaitTimeMinRadioButton->Checked = false;
                    //FGenConfigWaitTimeHourRadioButton->Checked = true;
                }
                else
                    nr = 3;
                index += 1;
             }

             //Tag Type
             if (((unsigned char)recvBuf[index] & 0xE0) == 0x00)
             {
                 str = "All Types";
                 p = FGenConfigTagTypeComboBox->Items->Count - 1;
             }
             else if ((p=GetTagTypesIndex((unsigned char)recvBuf[index])) < 0)
                 str = " ";
             else
             {
                  if (tagTypesAbr[p].data() == NULL)
                  {
                     if (p == 0x00)
                         str = "T00";
                     else
                     {
                       str = "T0";
                       str += p;
                     }
                  }
                  else
                     str = tagTypesAbr[p];
              }

              //Spk and LED
              if (((unsigned char)recvBuf[index] & 0xE0) == 0x00)

              /*if (((unsigned char)recvBuf[index] & 0xE0) == 0x20)  //001 0 0000
              str = "ACC";   //acc
              else if (((unsigned char)recvBuf[index] & 0xE0) == 0x40)  //010 0 0000
              str = "INV";   //inv
              else if (((unsigned char)recvBuf[index] & 0xE0) == 0x60)  //100 0 0000
              str = "AST";   //ast
              else
              str = " ";*/

              a = ((unsigned char)recvBuf[index] & 0x01);  //0000 0001  RN
              d = ((unsigned char)recvBuf[index] & 0x02);  //0000 0010  RA

              s =  ((unsigned char)recvBuf[index] & 0x04);  //0000 0100 LED
              l =  ((unsigned char)recvBuf[index] & 0x80);  //0000 1000 SPK

              index += 1;
              tagID = (unsigned int)((unsigned char)recvBuf[index])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[index+1])*pow(2, 16)+
                      (unsigned int)((unsigned char)recvBuf[index+2])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[index+3]);

              if ((tTime & 0x80) == 0x80)
              {
                  //AssignReaderMDActiveHiRadioButton->Checked = true;
                  b = true;
              }
              else
              {
                  //AssignReaderMDActiveLoRadioButton->Checked = true;
                  b = false;
              }

              //if ((recvBuf[configIndex] & 0x40) == 0x40)
              if ((tTime & 0x40) == 0x40)
              {
                 //AssignReaderEnableMDCheckBox->Checked = true;
                 c = true;
              }
              else
              {
                //AssignReaderEnableMDCheckBox->Checked = false;
                c = false;
              }

              //if ((recvBuf[index] & 0x20) == 0x20)      //Motion sensor
              if ((tTime & 0x20) == 0x20)
              {
                  //FGenConfigEnableISCheckBox->Checked = true;   //enable
                  e = true;
              }
              else
              {
                  //FGenConfigEnableISCheckBox->Checked = false;   //disable
                  e = false;
              }

              if (ConfigFGenGroupBox->Visible)   //CONFIG FGEN SCREEN **************
              {
                  //Reader
                  if (rID <= 0)
                     FGenConfigAssignedReaderIDEdit->Text = "";
                  else
                     FGenConfigAssignedReaderIDEdit->Text = rID;

                  //Transmit Time ---
                  FGenConfigTxTimeComboBox->Text = (tTime & 0x1F);

                 //Wait Time ---
                 FGenConfigWaitTimeComboBox->Text = (wTime & 0x3F);   //0011 1111;
                 if (nr == 0) //sec
                 {
                    FGenConfigWaitTimeSecRadioButton->Checked = true;
                    FGenConfigWaitTimeMinRadioButton->Checked = false;
                    FGenConfigWaitTimeHourRadioButton->Checked = false;
                    FGenConfigWaitTimeLabel->Caption = "sec";
                 }
                 else if (nr == 1)  //min
                 {
                    FGenConfigWaitTimeSecRadioButton->Checked = false;
                    FGenConfigWaitTimeMinRadioButton->Checked = true;
                    FGenConfigWaitTimeHourRadioButton->Checked = false;
                    FGenConfigWaitTimeLabel->Caption = "min";
                 }
                 else if (nr == 2) //hour
                 {
                    FGenConfigWaitTimeSecRadioButton->Checked = false;
                    FGenConfigWaitTimeMinRadioButton->Checked = false;
                    FGenConfigWaitTimeHourRadioButton->Checked = true;
                   FGenConfigWaitTimeLabel->Caption = "hour";
                 }

                 /*if (stdFGenType == 0x01)  //new std fgen
                 {
                     if (nr == 0) //sec
                     {
                         FGenConfigHoldTimeLabel->Caption = "sec";
                     }
                     else if (nr == 1)  //min
                     {
                         FGenConfigHoldTimeLabel->Caption = "min";
                     }
                     else if (nr == 2) //hour
                     {
                         FGenConfigHoldTimeLabel->Caption = "hour";
                     }
                 }

                 if (nr == 0) //sec
                 {
                    FGenConfigWaitTimeLabel->Caption = "sec";
                 }
                 else if (nr == 1)  //min
                 {
                     FGenConfigWaitTimeLabel->Caption = "min";
                 }
                 else if (nr == 2) //hour
                 {
                     FGenConfigWaitTimeLabel->Caption = "hour";
                 } */


                 //FGenConfigWaitTimeSecRadioButton->Checked = false;
                 //FGenConfigWaitTimeMinRadioButton->Checked = false;
                 //FGenConfigWaitTimeHourRadioButton->Checked = false;

             //tag ID -----
             if (tagID <= 0)
             {
                FGenConfigTagIDEdit->Text = "";
                FGenConfigAnyTagIDRadioButton->Checked = true;
             }
             else
             {
                FGenConfigTagIDEdit->Text = tagID;
                FGenConfigTagIDRadioButton->Checked = true;
             }

             if (p >= 0)
                 FGenConfigTagTypeComboBox->ItemIndex = p;


             //Tag Type -----
             /*if (str == "ACC")
                FGenConfigAccessRadioButton->Checked = true;
             else if (str == "INV")
                FGenConfigInventoryRadioButton->Checked = true;
             else if (str == "AST")
                FGenConfigAssetRadioButton->Checked = true;
             else
                FGenConfigAnyTypeRadioButton->Checked = true; */

             //RN -----
             if (a)
                FGenConfigRALongRadioButton->Checked =true;   //long
             else
                FGenConfigRNShortRadioButton->Checked = true;  //short

             if (d)
                FGenConfigTagRdrIDCheckBox->Checked =true;   //Assigned tag reader
             else
                FGenConfigTagRdrIDCheckBox->Checked = false;

             //LED
             if (l)
               FGenConfigLEDCheckBox->Checked = true;
             else
               FGenConfigLEDCheckBox->Checked = false;

             //SPK
             if (s)
               FGenConfigSPKCheckBox->Checked = true;
             else
               FGenConfigSPKCheckBox->Checked = false;

             //Motion Detector Enable ------
             //if ((recvBuf[configIndex] & 0x3F) == 0x00)
             if (c)
             {
                FGenConfigMDEnableCheckBox->Checked = true;
                //a = true;
             }
             else
             {
                FGenConfigMDEnableCheckBox->Checked = false;
                //a = false;
             }
             /*if ((tTime & 0x40) == 0x40)
                FGenConfigMDEnableCheckBox->Checked = true;
             else
                FGenConfigMDEnableCheckBox->Checked = false;*/

             //Motion Detector Plus Active -----
             //if ((tTime & 0x80) == 0x80)
             if (b)
             {
                FGenConfigMDActiveHiRadioButton->Checked = true;
                //b = true;
             }
             else
             {
                FGenConfigMDActiveLoRadioButton->Checked = true;
                //b = false;
             }

             if (e)   //motion sensor
             {
                 FGenConfigEnableISCheckBox->Checked = true;   //enable
             }
             else
             {
                 FGenConfigEnableISCheckBox->Checked = false;   //enable
             }

             //
          }
          else if (QueryFGenGroupBox->Visible)
          {
             if (e)   //motion sensor
             {
                 FGenConfigEnableISCheckBox->Checked = true;   //enable
                 motionSens = 1;
             }
             else
             {
                 FGenConfigEnableISCheckBox->Checked = false;   //enable
                 motionSens = 0;
             }

             if (stdFGenType == 0)
             {
                 motionSens = -1;
                 FGenConfigHoldTimeComboBox->Text = "";
             }


             if (powerupQueryFGen)
                QueryFGenListView->Items->Clear();

             DisplayQueryFGenListView(fGenID, n, (tTime & 0x1F), nr, wTime, rID, str, tagID, c, b, hTime, motionSens);
          }

          if (!powerupQueryFGen)
             StaticText->Caption = "Query Standard Field Generator was successful.";
          else
             powerupQueryFGen = false;

          PlaySound("Ding.wav", NULL, SND_ASYNC );
          }//smart FGen GroupBox
       break;

       case POWER_UP:   //0x30  ACK

          waitingForRespone = false;
          waitResetRdrACK = false;
          receivedResponse = true;
          TxClearTagCtrls();
          RxClearTagCtrls();
          ProgammingMode = true;
          StaticText->Caption = "";
          resetPowerup = false;

          CMDEnableTimer->Enabled = false;
          EnableSmartFGenStaticCommands();
          FGenResetBitBtn->Enabled = true;

          if (recvBuf[3] == 0x01)   //Std field gen power up
          {
             str = "Field Generator ID:";
             str += (unsigned int)(unsigned char)recvBuf[4];
             str += "  Rev:";
             str += (unsigned int)(unsigned char)recvBuf[6];
             str += "  Date:";
             str += GetDate(recvBuf[7], recvBuf[8]);
             str += "  Powered Up Successfully";
             //StaticText->Caption = "Field Generator Powered Up Successfully";
             StaticText->Caption = str;

             PlaySound("Ding.wav", NULL, SND_ASYNC );
             PlaySound("Ding.wav", NULL, SND_ASYNC );

             readerFgenButtonActivated = true;
             //if (!ConfigFGenGroupBox->Visible)
                //GotoConfigFGenPage();
             lastFieldGenID = (unsigned int)((unsigned char)recvBuf[3]);

             fieldGenOffLine = false;
             fieldGenOnLine = true;
             readerOffLine = true;
             readerOnLine = false;

             WriteRS232Comm(POWER_UP, 0, "F", 0);  //field generator powerup ACK
             //GotoConfigFGenPage();
             Sleep(250);
             if (QueryFGenGroupBox->Visible)    //Query STD FGEN
             {
                powerupQueryFGen = true;
                QueryFGenIDEdit->Text = lastFieldGenID;
                WriteRS232Comm(QUERY_FIELD_GEN, 0, NULL, 0);
             }
             else if (ConfigFGenGroupBox->Visible)
             {
                powerupQueryFGen = true;
                FGenConfigFieldGenIDEdit->Text = lastFieldGenID;
                QueryFGenIDEdit->Text = lastFieldGenID;
                QueryFGenHostIDEdit->Text =  (unsigned int)(unsigned char)recvBuf[5];
                WriteRS232Comm(QUERY_FIELD_GEN, 0, NULL, 0);
             }
          }
          else if ((recvBuf[2] == 0x05) && (recvBuf[3] == 0x11)) //smart FGen
          {
             pwUplastSFGenAddr = (int)recvBuf[6];  //smart fgen id
             lastSmartFieldGenID = pwUplastSFGenAddr;  //smart fgen id

             str = "Smart FGen ID ";
             str += pwUplastSFGenAddr;
             str += " was Powered up successfully.";
             StaticText->Caption = str;

             PlaySound("Ding.wav", NULL, SND_ASYNC );
             PlaySound("Ding.wav", NULL, SND_ASYNC );

             if (FGenResetGroupBox->Visible)
             {
                CMDEnableTimer->Enabled = false;
                EnableAllCommands(true);
                str = PwUpHostAddr;
                idStr = pwUpReaderAddr;
                lastReaderID = pwUpReaderAddr;
                FGenResetReaderIDComboBox->Text = idStr;
                if (FGenResetReaderIDComboBox->Items->IndexOf(FGenResetReaderIDComboBox->Text) == -1 )
                   FGenResetReaderIDComboBox->Items->Add(idStr);
                FGenResetHostIDEdit->Text = str;

                FGenResetIDComboBox->Text = pwUplastSFGenAddr;

                if (FGenResetIDComboBox->Items->IndexOf(FGenResetIDComboBox->Text) == -1 )
                {
                   FGenResetIDComboBox->Items->Add(pwUplastSFGenAddr);

                }
                   TListItem* ListItem;
                   ListItem = FGenResetListView->Items->Add();
                   ListItem->ImageIndex = -1;
                   ListItem->SubItems->Add(pwUplastSFGenAddr);
                   ListItem->SubItems->Add(pwUpReaderAddr);

                   fgenIDList[numSFgenIDList] = pwUplastSFGenAddr;
                   numSFgenIDList += 1;
                   lastSmartFieldGenID = pwUplastSFGenAddr;

                   ResetReaderStaticText->Enabled = true;
                   EnableReaderStaticText->Enabled = true;
                   DisableReaderStaticText->Enabled = true;
                   QueryReaderStaticText->Enabled = true;
                   AssignReaderStaticText->Enabled = true;
                   ReaderVersionStaticText->Enabled = true;
                   ConfigFGenStaticText->Enabled = true;
                   QueryFGenStaticText->Enabled = true;
                   FGenResetStaticText->Enabled = true;
                   SmartFGenStaticText->Enabled = true;
                   ConfigTagStaticText->Enabled = true;
                   EnableTagStaticText->Enabled = true;
                   DisableTagStaticText->Enabled = true;
                   QueryTagStaticText->Enabled = true;
                   CallTagStaticText->Enabled = true;
                   AssignTagRdrStaticText->Enabled = true;
                   ConfigTagRNDStaticText->Enabled = true;
                   WriteMemoryStaticText->Enabled = true;
                   ReadMemoryStaticText->Enabled = true;
                   //EnableRdrFGenStaticText->Enabled = true;
                   RelayStaticText->Enabled = true;
                   InputsStaticText->Enabled = true;
                   TagTempStaticText->Enabled = true;
                //}

                //ListItem->SubItems->Add(tagDetectedArray[index].fGenID);

                //ListItem->SubItems->Add(tagDetectedArray[index].readerID);

                   ////////////////////////////////////////////

                //str = "Smart FGen ID ";
                //str += pwUplastSFGenAddr;
                //str += " was Powered up successfully.";
                //StaticText->Caption = str;
             }
             else if (ConfigSFGenGroupBox->Visible)
             {
                FGenConfigSmartFieldGenIDComboBox->Text = pwUplastSFGenAddr;
                if (FGenConfigSmartFieldGenIDComboBox->Items->IndexOf(FGenConfigSmartFieldGenIDComboBox->Text) == -1 )
                   FGenConfigSmartFieldGenIDComboBox->Items->Add(pwUplastSFGenAddr);
                SFGenConfigHostIDEdit->Text = PwUpHostAddr;  //str;
             }
             else if (ConfigSFGenGroupBox->Visible)
             {
                FGenConfigSmartFieldGenIDComboBox->Text = pwUplastSFGenAddr;
                if (FGenConfigSmartFieldGenIDComboBox->Items->IndexOf(FGenConfigSmartFieldGenIDComboBox->Text) == -1 )
                   FGenConfigSmartFieldGenIDComboBox->Items->Add(pwUplastSFGenAddr);
                SFGenConfigHostIDEdit->Text = PwUpHostAddr;  //str;
             }
             else if (QuerySFGenGroupBox->Visible)
             {
                QueryFGenSmartFGenIDComboBox->Text = pwUplastSFGenAddr;
                if (QueryFGenSmartFGenIDComboBox->Items->IndexOf(QueryFGenSmartFGenIDComboBox->Text) == -1 )
                   QueryFGenSmartFGenIDComboBox->Items->Add(pwUplastSFGenAddr);
                QuerySFGenHostIDEdit->Text = PwUpHostAddr; //str;
             }
             else if (SmartFGenGroupBox->Visible)
             {
                SmartFGenIDComboBox->Text = pwUplastSFGenAddr;
                if (SmartFGenIDComboBox->Items->IndexOf(SmartFGenIDComboBox->Text) == -1 )
                   SmartFGenIDComboBox->Items->Add(pwUplastSFGenAddr);
                SmartFGenHostIDEdit->Text = PwUpHostAddr; //str;
             }

          }
          else  //reader power up
          {
           readerOffLine = false;
           readerOnLine = true;
           fieldGenOffLine = true;
           fieldGenOnLine = false;
          //waitingForRespone = false;
          //waitResetRdrACK = false;
          //receivedResponse = true;
          //TxClearTagCtrls();
          //RxClearTagCtrls();
          //ProgammingMode = true;
          //StaticText->Caption = "";
          //resetPowerup = false;

          if ((recvBuf[3] & 0x38) == 0x30)  //exteded reader
          {
            readerOffLine = false;
            readerOnLine = true;
            fieldGenOffLine = true;
            fieldGenOnLine = false;

            if (ResetReaderGroupBox->Visible && ResetModifyReaderCheckBox->Checked)
            {
                pwUpReaderAddr = newRID;
                PwUpHostAddr = newHID;
            }
            else
            {
               PwUpHostAddr = (unsigned char)recvBuf[6];
               pwUpReaderAddr = (unsigned int)((unsigned char)recvBuf[4])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[5]);  //reader ID
            }
            str = PwUpHostAddr;
            idStr = pwUpReaderAddr;
            lastReaderID = pwUpReaderAddr;
            if (allHostID)
               lastHostID = PwUpHostAddr;
          }
          else  //reg rdr
          {
             if (recvBuf[2] == 4) //len=4   reg reader
             {
                if (ResetReaderGroupBox->Visible && ResetModifyReaderCheckBox->Checked)
                {
                   pwUpReaderAddr = newRID;
                   PwUpHostAddr = newHID;
                }
                else
                {
                   PwUpHostAddr = (unsigned char)recvBuf[5];
                   pwUpReaderAddr = (unsigned char)recvBuf[4];
                }
                idStr = pwUpReaderAddr;
                str = PwUpHostAddr;
                lastReaderID = pwUpReaderAddr;
                if (allHostID)
                   lastHostID = PwUpHostAddr;
             }
             //else if (recvBuf[2] == 5) //len=5 smart field generator
             //{
                //pwUplastSFGenAddr = (int)recvBuf[6];  //fgen id

             //}

          }  //reg rdr

          fieldGenOffLine = true;
          fieldGenOnLine = false;
          readerOffLine = false;
          fieldGenOnLine = true;

          if (RS232On)
          {
             WriteRS232Comm(POWER_UP, 0, NULL, 0);
          }
          else if (networkOn)
          {
             if (sockIndex < 0)
                return;

             //WriteTCPIPComm(POWER_UP, 0, NULL, 0, networkInfo[sockIndex].activeSock, networkInfo[sockIndex].peerSock, sockIndex);
             //BuildTxSockets(POWER_UP, 0, NULL, 0, "");
             WriteAWSocket(POWER_UP, 0, NULL, 0, 'S', NULL, 0, sockIndex);

             if (AWSockets[sockIndex]->AWClientSocket->Address.data() != NULL)
             {
                 AWSockets[sockIndex]->reader = pwUpReaderAddr;
                 AWSockets[sockIndex]->host = PwUpHostAddr;
                 AWSockets[sockIndex]->rdrStatus = "Online";
                 index = GetIpAddressIndex(AWSockets[sockIndex]->AWClientSocket->Address);
                 if (index >= 0)
                 {
                    strcpy(listViewInfo[index].rdrStatus, "Online");
                    strcpy(listViewInfo[index].netStatus, "Active");
                    listViewInfo[index].reader = pwUpReaderAddr;
                    listViewInfo[index].host = PwUpHostAddr;
                    //listViewInfo[index].selected = false;
                    if (comConfigDialog)
                       comConfigDialog->UpdateIPListView();
                 }
             }
          }

          if (bootloading)
          {
             sendBootQuery = true;
             //BootloadTimer->Enabled = true;
          }
          else
             sendBootQuery = false;

          if (NewReaderIDCheckBox->Checked && (NewReaderIDEdit->Text.data() != NULL))
             ReaderIDComboBox->Text = NewReaderIDEdit->Text;
          else
             ReaderIDComboBox->Text = idStr;

          if (ReaderIDComboBox->Items->IndexOf(ReaderIDComboBox->Text) == -1 )
          {
             ReaderIDComboBox->Items->Add(ReaderIDComboBox->Text);
             //if (!CheckDuplicatedReader(atoi(ReaderIDComboBox->Text.c_str())))
               //readerIDList[numReaderIDList++] = atoi(ReaderIDComboBox->Text.c_str());
             //readerIDList[numReaderIDList++] = atoi(ReaderIDComboBox->Text.c_str());
          }

          if (!CheckDuplicatedReader(atoi(ReaderIDComboBox->Text.c_str())))
               readerIDList[numReaderIDList++] = atoi(ReaderIDComboBox->Text.c_str());

          if (allHostID)
          {
             if (NewHostIDCheckBox->Checked && (NewHostIDEdit->Text.data() != NULL))
                HostIDEdit->Text = NewHostIDEdit->Text;
             else
                HostIDEdit->Text = str;
          }

          if (ResetReaderGroupBox->Visible)
          {
             ResetReaderIDComboBox->Text = idStr;
             if (ResetReaderIDComboBox->Items->IndexOf(ResetReaderIDComboBox->Text) == -1 )
                ResetReaderIDComboBox->Items->Add(idStr);
             ResetHostIDEdit->Text = str;
             n = (unsigned int)atoi(idStr.c_str());
             if (!CheckDuplicatedReader(n))
                readerIDList[numReaderIDList++] = n;
             //DisplayReadersInViewList("", idStr);
          }
          else if (EnableReaderGroupBox->Visible)
          {
             EnableReaderIDComboBox->Text = idStr;
             if (EnableReaderIDComboBox->Items->IndexOf(EnableReaderIDComboBox->Text) == -1 )
                EnableReaderIDComboBox->Items->Add(idStr);
             EnableReaderHostIDEdit->Text = str;
             //DisplayReadersInViewList("", idStr);
          }
          else if (DisableReaderGroupBox->Visible)
          {
             DisableReaderIDComboBox->Text = idStr;
             if (DisableReaderIDComboBox->Items->IndexOf(DisableReaderIDComboBox->Text) == -1 )
                DisableReaderIDComboBox->Items->Add(idStr);
             DisableReaderHostIDEdit->Text = str;
             //DisplayReadersInViewList("", idStr);
          }
          else if (QueryReaderGroupBox->Visible)
          {
             QueryReaderIDComboBox->Text = idStr;
             if (QueryReaderIDComboBox->Items->IndexOf(QueryReaderIDComboBox->Text) == -1 )
                QueryReaderIDComboBox->Items->Add(idStr);
             QueryReaderHostIDEdit->Text = str;
             //DisplayReadersInViewList("", idStr);
          }
          else if (AssignReaderGroupBox->Visible)
          {
             AssignReaderIDComboBox->Text = idStr;
             if (AssignReaderIDComboBox->Items->IndexOf(AssignReaderIDComboBox->Text) == -1 )
                AssignReaderIDComboBox->Items->Add(idStr);
             AssignReaderHostIDEdit->Text = str;
             //DisplayReadersInViewList("", idStr);
          }
          else if (ReaderCodeVerGroupBox->Visible)
          {
             RdrCodeVerReaderComboBox->Text = idStr;
             if (RdrCodeVerReaderComboBox->Items->IndexOf(RdrCodeVerReaderComboBox->Text) == -1 )
                RdrCodeVerReaderComboBox->Items->Add(idStr);
             RdrCodeVerHostEdit->Text = str;
          }
          else if (DownloadRdrGroupBox->Visible)
          {
             DownloadRdrReaderComboBox->Text = idStr;
             if (DownloadRdrReaderComboBox->Items->IndexOf(DownloadRdrReaderComboBox->Text) == -1 )
                DownloadRdrReaderComboBox->Items->Add(idStr);
             DownloadRdrHostEdit->Text = str;
          }
          else if (ConfigReaderTxTimeGroupBox->Visible)
          {
             ConfigTxTimeReaderIDComboBox->Text = idStr;
             if (ConfigTxTimeReaderIDComboBox->Items->IndexOf(ConfigTxTimeReaderIDComboBox->Text) == -1 )
                ConfigTxTimeReaderIDComboBox->Items->Add(idStr);
             ConfigTxTimeHostIDEdit->Text = str;
          }
          else if (SetFStrengthGroupBox->Visible)
          {
             ReaderFStrengthReaderComboBox->Text = idStr;
             if (ReaderFStrengthReaderComboBox->Items->IndexOf(ReaderFStrengthReaderComboBox->Text) == -1 )
                ReaderFStrengthReaderComboBox->Items->Add(idStr);
             ReaderFStrengthHostEdit->Text = str;
          }
          else if (ConfigFGenGroupBox->Visible)
          {
             FGenConfigReaderIDEdit->Text = idStr;
             FGenConfigHostIDEdit->Text = str;

             FGenConfigSmartFieldGenIDComboBox->Text = pwUplastSFGenAddr;
             if (FGenConfigSmartFieldGenIDComboBox->Items->IndexOf(FGenConfigSmartFieldGenIDComboBox->Text) == -1 )
                FGenConfigSmartFieldGenIDComboBox->Items->Add(pwUplastSFGenAddr);
          }
          else if (QuerySFGenGroupBox->Visible)
          {
             QueryFGenSmartFGenRdrIDComboBox->Text = idStr;
             if (QueryFGenSmartFGenRdrIDComboBox->Items->IndexOf(QueryFGenSmartFGenRdrIDComboBox->Text) == -1 )
                QueryFGenSmartFGenRdrIDComboBox->Items->Add(idStr);
             QuerySFGenHostIDEdit->Text = str;
          }
          else if (ConfigSFGenGroupBox->Visible)
          {
             FGenConfigSmartFGenReaderIDComboBox->Text = idStr;
             if (FGenConfigSmartFGenReaderIDComboBox->Items->IndexOf(FGenConfigSmartFGenReaderIDComboBox->Text) == -1 )
                FGenConfigSmartFGenReaderIDComboBox->Items->Add(idStr);
             SFGenConfigHostIDEdit->Text = str;
          }
          else if (FGenResetGroupBox->Visible)
          {
             FGenResetReaderIDComboBox->Text = idStr;
             if (FGenResetReaderIDComboBox->Items->IndexOf(FGenResetReaderIDComboBox->Text) == -1 )
                FGenResetReaderIDComboBox->Items->Add(idStr);
             FGenResetHostIDEdit->Text = str;

             FGenResetIDComboBox->Text = pwUplastSFGenAddr;
             if (FGenResetIDComboBox->Items->IndexOf(FGenResetIDComboBox->Text) == -1 )
                FGenResetIDComboBox->Items->Add(pwUplastSFGenAddr);
          }
          else if (SmartFGenGroupBox->Visible)
          {
             SmartFGenReaderIDComboBox->Text = idStr;
             if (SmartFGenReaderIDComboBox->Items->IndexOf(SmartFGenReaderIDComboBox->Text) == -1 )
                SmartFGenReaderIDComboBox->Items->Add(idStr);
             SmartFGenHostIDEdit->Text = str;

             SmartFGenIDComboBox->Text = pwUplastSFGenAddr;
             if (SmartFGenIDComboBox->Items->IndexOf(SmartFGenIDComboBox->Text) == -1 )
                SmartFGenIDComboBox->Items->Add(pwUplastSFGenAddr);
          }
          else if (AssignTagReaderGroupBox->Visible)
          {
             AssignTagRdrRdrIDComboBox->Text = idStr;
             if (AssignTagRdrRdrIDComboBox->Items->IndexOf(AssignTagRdrRdrIDComboBox->Text) == -1 )
                AssignTagRdrRdrIDComboBox->Items->Add(idStr);
             AssignTagRdrHostIDEdit->Text = str;

             if (AssignTagRdrTagRdrIDComboBox->Items->IndexOf(idStr) == -1 )
                AssignTagRdrTagRdrIDComboBox->Items->Add(idStr);
          }
          else if (ConfigTagRandGroupBox->Visible)
          {
             ConfigTagRNDRdrIDComboBox->Text = idStr;
             if (ConfigTagRNDRdrIDComboBox->Items->IndexOf(ConfigTagRNDRdrIDComboBox->Text) == -1 )
                ConfigTagRNDRdrIDComboBox->Items->Add(idStr);
             ConfigTagRNDHostIDEdit->Text = str;
          }
          else if (ConfigTagGroupBox->Visible)
          {
             ConfigTagReaderIDComboBox->Text = idStr;
             if (ConfigTagReaderIDComboBox->Items->IndexOf(ConfigTagReaderIDComboBox->Text) == -1 )
                ConfigTagReaderIDComboBox->Items->Add(idStr);
             ConfigTagHostIDEdit->Text = str;
          }
          else if (EnableTagGroupBox->Visible)
          {
             EnableTagIDComboBox->Text = idStr;
             if (EnableTagIDComboBox->Items->IndexOf(EnableTagIDComboBox->Text) == -1 )
                EnableTagIDComboBox->Items->Add(idStr);
             EnableTagHostIDEdit->Text = str;
          }
          else if (DisableTagGroupBox->Visible)
          {
             DisableTagIDComboBox->Text = idStr;
             if (DisableTagIDComboBox->Items->IndexOf(DisableTagIDComboBox->Text) == -1 )
                DisableTagIDComboBox->Items->Add(idStr);
             DisableTagHostIDEdit->Text = str;
          }
          else if (QueryTagGroupBox->Visible)
          {
             QueryTagReaderIDComboBox->Text = idStr;
             if (QueryTagReaderIDComboBox->Items->IndexOf(QueryTagReaderIDComboBox->Text) == -1 )
                QueryTagReaderIDComboBox->Items->Add(idStr);
             QueryTagHostIDEdit->Text = str;
          }
          else if (WriteMemoryGroupBox->Visible)
          {
             WriteMemoryReaderIDComboBox->Text = idStr;
             if (WriteMemoryReaderIDComboBox->Items->IndexOf(WriteMemoryReaderIDComboBox->Text) == -1 )
                WriteMemoryReaderIDComboBox->Items->Add(idStr);
             WriteMemoryHostIDEdit->Text = str;
          }
          else if (ReadMemoryGroupBox->Visible)
          {
             ReadMemoryReaderIDComboBox->Text = idStr;
             if (ReadMemoryReaderIDComboBox->Items->IndexOf(ReadMemoryReaderIDComboBox->Text) == -1 )
                ReadMemoryReaderIDComboBox->Items->Add(idStr);
             ReadMemoryHostIDEdit->Text = str;
          }
          else if (TagTempGroupBox->Visible)
          {
             TagTempReaderIDComboBox->Text = idStr;
             if (TagTempReaderIDComboBox->Items->IndexOf(TagTempReaderIDComboBox->Text) == -1 )
                TagTempReaderIDComboBox->Items->Add(idStr);
             TagTempHostIDEdit->Text = str;
          }

          if (idStr != "0")
             StaticText->Caption = "Reader ID " + idStr + " was Powered up successfully.";
          //else
             //StaticText->Caption = "Reader was Powered up successfully.";
          } //reader power up
       break;

       case INVALID_RESPONSE:  //0xFF
          global = false;
          EnableReaderStaticText->Enabled = true;
          DisableReaderStaticText->Enabled = true;
          QueryReaderStaticText->Enabled = true;
          AssignReaderStaticText->Enabled = true;
          ReaderVersionStaticText->Enabled = true;
          ConfigTxTimeStaticText->Enabled = true;
          //EnableRdrFGenStaticText->Enabled = true;
          RelayStaticText->Enabled = true;
          InputsStaticText->Enabled = true;
          //EnableFGenStaticText->Enabled = true;
          ConfigFGenStaticText->Enabled = true;
          QueryFGenStaticText->Enabled = true;
          FGenResetStaticText->Enabled = true;
          SmartFGenStaticText->Enabled = true;
          ConfigTagStaticText->Enabled = true;
          EnableTagStaticText->Enabled = true;
          DisableTagStaticText->Enabled = true;
          QueryTagStaticText->Enabled = true;
          CallTagStaticText->Enabled = true;
          AssignTagRdrStaticText->Enabled = true;
          ConfigTagRNDStaticText->Enabled = true;
          WriteMemoryStaticText->Enabled = true;
          ReadMemoryStaticText->Enabled = true;
          TagTempStaticText->Enabled = true;
          QuerySFGenStaticText->Enabled = true;
          ConfigSFGenStaticText->Enabled = true;
          ConfigTagLEDStaticText->Enabled = true;

          CMDEnableTimer->Enabled = false;

          if ((recvBuf[3] & 0x38) == 0x30)  //exteded reader
          {
             cmd = (unsigned int)recvBuf[7];
             index = 7;
          }
          else
          {
             cmd = (unsigned int)recvBuf[6];
             index = 6;
          }

         /* if (WriteMemoryGroupBox->Visible && LargeDataCheckBox->Checked && writeTagData)
          {
              if ((recvBuf[2] + 1) == writePktID)
              {
                  cmd = WRITE_TAG_MEMORY;
                  pktID = recvBuf[recvBuf[2] + 1];
              }

              retry = 0;

          }*/

          //if 0xFF and LargData and writing in progress
         /*if (WriteMemoryGroupBox->Visible && LargeDataCheckBox->Checked && writeTagData)
          {
              // if 0xFF and same write packet ID
              if ((recvBuf[recvBuf[2] + 1]) == writePktID)
              {
                  //if len for 0xFF does not match then this is ack to write cmd
                  if (recvBuf[2] > 0x07)
                  {
                     cmd = WRITE_TAG_MEMORY;
                     pktID = recvBuf[recvBuf[2] + 1];
                     GeneralTimer->Enabled = false;
                     largDataWriteAck = true;
                     retry = 0;
                  }
                  else if (recvBuf[index + 1] != 0xBE)  //this 0xFF with Error code for write command
                  {
                     //let timer service it - do retry
                     return;
                  }
                  else if (!largDataWriteAck)//this is 0xBE for the write command but no write Ack
                  {
                     //let timer service it - do retry
                     return;
                  }
              }

          }*/

          switch (cmd)
          {
             case QUERY_FIELD_GEN:
                QueryFGenBitBtn->Enabled = true;
                StaticText->Caption = "Search Completed.";
             break;

             case CONFIG_TAG:
                ConfigTagBitBtn->Enabled = true;
                StaticText->Caption = "Configuration Completed.";
             break;

             case ENABLE_TAG:
                EnableTagBitBtn->Enabled = true;
                StaticText->Caption = "Enabling Tags Completed.";
             break;

             case DISABLE_TAG:
                DisableTagBitBtn->Enabled = true;
                StaticText->Caption = "Disabling Tags Completed.";
             break;

             case QUERY_TAG:
                QueryTagBitBtn->Enabled = true;
                StaticText->Caption = "Search Completed.";
             break;

             case CALL_TAG:
                CallTagBitBtn->Enabled = true;
                StaticText->Caption = "Calling Tags Completed.";
             break;

             case DEFINE_TAG_READER:
                AssignTagRdrBitBtn->Enabled = true;
                if (StaticText->Caption.IsEmpty())
                   StaticText->Caption = "Task Completed.";
             break;

             case CONFIG_TAG_RND:
                ConfigTagRNDBitBtn->Enabled = true;
                StaticText->Caption = "Task Completed.";
             break;

             case READ_TAG_MEMORY:
                 if (TagTempGroupBox->Visible)
                 {
                    TagTempReadTempValueBitBtn->Enabled = true;
                    TagTempRefreshBitBtn->Enabled = true;
                    TagTempBitBtn->Enabled = true;
                    StaticText->Caption = "Reading Tag Temperature Parameter Completed.";
                 }
                 else
                   ReadMemoryBitBtn->Enabled = true;

                  if (ReadTagLargeDataCheckBox->Checked)
                  {
                     gotFF = true;
                     //AnsiString s = atoi(ReadMemoryStartAddrEdit->Text.c_str()) + 16;
                     //ReadMemoryStartAddrEdit->Text = IntToHex(atoi(s.c_str()), s.Length());
                  }

                 /*if (WriteMemoryGroupBox->Visible && LargeDataCheckBox->Checked && writeTagData)
                 {
                    if (!largDataReadAck)
                    {
                        largeDataReadRetry = true;
                        largeDataReadRetryCt = 0;
                        RetryTimer->Enabled = true;
                    }
                    else if (!WriteTimer->Enabled)
                    {
                        largeDataReadRetryCt = 0;
                        WriteTimer->Enabled = true;
                    }

                 }*/

             break;

             case WRITE_TAG_MEMORY:

                 /*if (WriteMemoryGroupBox->Visible && LargeDataCheckBox->Checked && writeTagData)
                 {
                    if (!largDataWriteAck)
                    {
                        largeDataWriteRetry = true;
                        largeDataWriteRetryCt = 0;
                        RetryTimer->Enabled = true;
                    }
                    else if (!ReadTimer->Enabled)
                    {
                        largeDataWriteRetryCt = 0;
                        ReadTimer->Enabled = true;
                    }
                 }*/

                 if (TagTempGroupBox->Visible)
                 {
                   TagTempReadTempValueBitBtn->Enabled = true;
                   TagTempRefreshBitBtn->Enabled = true;
                   TagTempBitBtn->Enabled = true;
                   StaticText->Caption = "Configuring Tag Temperature Completed.";
                 }
                 else
                 {
                   WriteMemoryBitBtn->Enabled = true;

                   //GeneralTimer->Enabled = false;
                   //writeTagData = false;
                   //PlaySound("Ding.wav", NULL, SND_ASYNC );
                   //StaticText->Caption = "Writing large data to the tag completed.";
                   //displayElapsedTime = false;

                   //////////  Large Data tag mem write  OLD CODE  //////////////////////
                   //-------------------------------------------------------------------
                   /*if ((LargeDataCheckBox->Checked) &&
                       (pktID != lastWritePktID) &&
                       writeTagData)
                   {
                       totByteWritten += 12;
                       AnsiString str = "Bytes Written: ";
                       str += totByteWritten;
                       BytesWrittenLabel->Caption = str;
                       BytesWrittenLabel->Invalidate();

                       if (totByteWritten < atoi(WriteMemoryNumByteEdit->Text.c_str()))
                       {
                          lastWritePktID = pktID;
                          AnsiString addrStr = WriteMemoryStartAddrEdit->Text;
                          int addr = HexToInt(addrStr.c_str(), addrStr.Length());
                          //int addr = 224;
                          addr += 16;
                          WriteMemoryStartAddrEdit->Text = IntToHex(addr, 4);

                          //totByteWritten += 8;
                          //AnsiString str = "Bytes Written: ";
                          //str += totByteWritten;
                          //BytesWrittenLabel->Caption = str;

                          //GeneralTimer->Enabled = true;


                          if(networkOn)
                          {
                             int rdr = atoi(WriteMemoryReaderIDComboBox->Text.c_str());
                             int index = GetSocketIndex(rdr);
                             if (index >= 0)
                             {
                                WriteAWSocket(WRITE_TAG_MEMORY, 0, NULL, index, 'S', NULL, 0, index);
                             }
                             else
                                StaticText->Caption = "No matching socket for the reader.";
                          }
                          else if (RS232On)
                          {
                              //WriteRS232Comm(WRITE_TAG_MEMORY, 0, NULL, 0);
                              nextPkt = true;
                              retry = 0;
                              GeneralTimer->Enabled = true;
                              numWritePkts += 1;
                              AnsiString s = "#Pkts: ";
                              s += numWritePkts;
                              WriteNumPKtLabel->Caption = s;
                              WriteNumPKtLabel->Invalidate();
                          }
                       }
                       else
                       {
                          GeneralTimer->Enabled = false;
                          writeTagData = false;
                          PlaySound("Ding.wav", NULL, SND_ASYNC );
                          StaticText->Caption = "Writing large data to the tag completed.";
                          displayElapsedTime = false;
                       }*/
                  // } */
                   ///////////////////////////////////////////////////////////
                 }
             break;

             case SET_READER_DPOT:
                 if (SetFStrengthGroupBox->Visible)
                 {
                   if ((unsigned char)recvBuf[index+2] == 0x85)  //pktID increment
                   {
                      StaticText->Caption = "Reader DPOT reached MAX Limit (20).";
                      //ReaderFStrengthUpDown->Position = 20;
                   }
                   else if ((unsigned char)recvBuf[index+2] == 0x84)  //pktID decrement
                   {
                      StaticText->Caption = "Reader DPOT reached MIN Limit (0).";
                      //ReaderFStrengthUpDown->Position = 20;
                   }
                 }
             break;

          }

          if (!receivedResponse)
             StaticText->Caption = "";
          PlaySound("Ding.wav", NULL, SND_ASYNC );
       break;

       case TAG_DETECTED:   //0x31  ACK
         receivedResponse = true;
         if (!global)
           PlaySound("Ding.wav", NULL, SND_ASYNC );

          TxClearTagCtrls();
          RxClearTagCtrls();
          ProgammingMode = true;
          DetectedMsg->Caption = "";
          TamperSWMsg->Caption = "";

          if (recvBuf[2] == 9) //len=9  reg Rdr
          {
             nr = (unsigned char)recvBuf[4];
             RxReaderIDLabel->Caption = nr;  //reader ID

             //status Byte
             DisplayStatusByte(10, TAG_DETECTED);
             configIndex = 10;

             //n = (unsigned int)(unsigned char)recvBufCpy[6]*pow(2, 24)+(unsigned int)(unsigned char)recvBufCpy[7]*pow(2, 16)+
                 //(unsigned int)(unsigned char)recvBufCpy[8]*pow(2, 8)+(unsigned int)(unsigned char)recvBufCpy[9];

             n = (unsigned int)((unsigned char)recvBuf[6])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[7])*pow(2, 16)+
                 (unsigned int)((unsigned char)recvBuf[8])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[9]);

             RxTagIDLabel->Caption = n;     //tag ID
             pktID = recvBufCpy[11];
             gID = ((unsigned char)recvBuf[10]) & 0x01;
             FGenIDLabel->Caption = "0";  //reader field gen

          }
          else if (recvBuf[2] == 10) //len=10  ext Rdr no repeater / reg rdr + fgen
          {
             if ((recvBuf[3] & 0x38) == 0x30)  //00 110 000 ext rdr
             {
                nr = (unsigned int)((unsigned char)recvBuf[4])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[5]);
                RxReaderIDLabel->Caption = nr;  //reader ID
                DisplayStatusByte(11, TAG_DETECTED);
                configIndex = 11;
                n = (unsigned int)((unsigned char)recvBuf[7])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[8])*pow(2, 16)+
                    (unsigned int)((unsigned char)recvBuf[9])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[10]);
                gID = ((unsigned char)recvBuf[11]) & 0x01;
             }
             //else   //reg rdr + field gen
             else if ((recvBuf[3] & 0x38) == 0x10)  //reg reader
             {
                nr = (unsigned char)recvBuf[4];
                RxReaderIDLabel->Caption = nr;  //reader ID
                DisplayStatusByte(10, TAG_DETECTED);
                configIndex = 10;
                n = (unsigned int)((unsigned char)recvBuf[6])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[7])*pow(2, 16)+
                    (unsigned int)((unsigned char)recvBuf[8])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[9]);
                FGenIDLabel->Caption = (unsigned char)recvBuf[11];
                fGenID = (unsigned char)recvBuf[11];
                FGenIDLabel->Caption = fGenID;
                gID = ((unsigned char)recvBuf[10]) & 0x01;

             }
             else
                return;

             RxTagIDLabel->Caption = n;     //tag ID
             pktID = recvBufCpy[12];
          }
          else
          {
             configIndex = 0;
          }

          RxCommandLabel->Caption = "Tag Detected";
          str = RxTagTypeLabel->Caption;
          str += " Tag ";
          str += n;
          //str += " detected.";

          if (RxTamperLabel->Caption == "Yes")
             TamperSWMsg->Caption = "Tamper  Switch  Enabled !";
          else
             TamperSWMsg->Caption = "";
          DetectedMsg->Caption = str;

          if (!CheckSameTag(n, tgType, fGenID, gID, fGenFlag, gIDFlag, dIndex, nr, TAG_DETECTED, rssi) || multiDisplayTagDetect)
          {
             //******China Demo******
            /* if (chinaDemoON)
                ChinaDemoForm->UpdateChinaDemoScreen(n); */

             if (*gIDFlag || *fGenFlag)
             {
                queIndex = *dIndex;
             }
             else
             {
                queIndex = tagDetectCount;
             }

             LoadStatusByteToQue(configIndex, TAG_DETECTED, queIndex);

             tagDetectedArray[queIndex].lastDetectTime = Now();

             tagDetectedArray[queIndex].tagID = n;
             tagDetectedArray[queIndex].readerID = nr;
             tagDetectedArray[queIndex].cmd = TAG_DETECTED;
             tagDetectedArray[queIndex].tagType = tgType;
             tagDetectedArray[queIndex].rssi = rssi;

             if (fGenID > 0)
                tagDetectedArray[queIndex].fGenID = fGenID;
             else
                tagDetectedArray[queIndex].fGenID = 0;
             tagDetectedArray[queIndex].gID = gID;

             DisplayTagInListView(queIndex, fGenID, gID, fGenFlag, gIDFlag, 0, "DET"); //(DetectedTagListView->Items->Count);
             if ((*gIDFlag == false) && (*fGenFlag == false))
                tagDetectCount++;

             if (global)
                PlaySound("Ding.wav", NULL, SND_ASYNC );
          }
          else
          {
             if (configIndex > 0)
                UpdateTagDetectedArray(nr, fGenID, n, tgType, configIndex);
          }

       break;

       case TAG_DETECTED_RSSI:  //0x32  ACK
         receivedResponse = true;
         if (!global)
           PlaySound("Ding.wav", NULL, SND_ASYNC );

          TxClearTagCtrls();
          RxClearTagCtrls();
          ProgammingMode = true;
          DetectedMsg->Caption = "";
          TamperSWMsg->Caption = "";

          if (recvBuf[2] == 10) //len=9  reg Rdr
          {
             nr = (unsigned char)recvBuf[4];
             RxReaderIDLabel->Caption = nr;  //reader ID

             //status Byte
             DisplayStatusByte(10, TAG_DETECTED_RSSI);
             configIndex = 10;

             //n = (unsigned int)(unsigned char)recvBufCpy[6]*pow(2, 24)+(unsigned int)(unsigned char)recvBufCpy[7]*pow(2, 16)+
                 //(unsigned int)(unsigned char)recvBufCpy[8]*pow(2, 8)+(unsigned int)(unsigned char)recvBufCpy[9];

             n = (unsigned int)((unsigned char)recvBuf[6])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[7])*pow(2, 16)+
                 (unsigned int)((unsigned char)recvBuf[8])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[9]);

             RxTagIDLabel->Caption = n;     //tag ID
             pktID = recvBufCpy[11];
             gID = ((unsigned char)recvBuf[10]) & 0x01;
             rssi = (unsigned char)recvBuf[11];
             FGenIDLabel->Caption = "0";  //reader field gen

          }
          else if (recvBuf[2] == 11) //len=10  ext Rdr no repeater / reg rdr + fgen
          {
             if ((recvBuf[3] & 0x38) == 0x30)  //00 110 000 ext rdr
             {
                nr = (unsigned int)((unsigned char)recvBuf[4])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[5]);
                RxReaderIDLabel->Caption = nr;  //reader ID
                DisplayStatusByte(11, TAG_DETECTED);
                configIndex = 11;
                n = (unsigned int)((unsigned char)recvBuf[7])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[8])*pow(2, 16)+
                    (unsigned int)((unsigned char)recvBuf[9])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[10]);
                gID = ((unsigned char)recvBuf[11]) & 0x01;
             }
             //else   //reg rdr + field gen
             else if ((recvBuf[3] & 0x38) == 0x10)  //reg reader
             {
                nr = (unsigned char)recvBuf[4];
                RxReaderIDLabel->Caption = nr;  //reader ID
                DisplayStatusByte(10, TAG_DETECTED_RSSI);
                configIndex = 10;
                n = (unsigned int)((unsigned char)recvBuf[6])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[7])*pow(2, 16)+
                    (unsigned int)((unsigned char)recvBuf[8])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[9]);
                FGenIDLabel->Caption = (unsigned char)recvBuf[11];
                fGenID = (unsigned char)recvBuf[11];
                FGenIDLabel->Caption = fGenID;
                gID = ((unsigned char)recvBuf[10]) & 0x01;
                rssi = (unsigned char)recvBuf[12];
             }
             else
                return;

             RxTagIDLabel->Caption = n;     //tag ID
             pktID = recvBufCpy[13];
          }
          else
          {
             configIndex = 0;
          }

          RxCommandLabel->Caption = "Tag Det. RSSI";
          str = RxTagTypeLabel->Caption;
          str += " Tag ";
          str += n;
          //str += " detected.";

          if (RxTamperLabel->Caption == "Yes")
             TamperSWMsg->Caption = "Tamper  Switch  Enabled !";
          else
             TamperSWMsg->Caption = "";
          DetectedMsg->Caption = str;

          if (!CheckSameTag(n, tgType, fGenID, gID, fGenFlag, gIDFlag, dIndex, nr, TAG_DETECTED, rssi) || multiDisplayTagDetect)
          {
             //******China Demo******
            /* if (chinaDemoON)
                ChinaDemoForm->UpdateChinaDemoScreen(n); */

             if (*gIDFlag || *fGenFlag)
             {
                queIndex = *dIndex;
             }
             else
             {
                queIndex = tagDetectCount;
             }

             LoadStatusByteToQue(configIndex, TAG_DETECTED, queIndex);

             tagDetectedArray[queIndex].lastDetectTime = Now();

             tagDetectedArray[queIndex].tagID = n;
             tagDetectedArray[queIndex].readerID = nr;
             tagDetectedArray[queIndex].cmd = TAG_DETECTED;
             tagDetectedArray[queIndex].tagType = tgType;
             tagDetectedArray[queIndex].rssi = rssi;

             if (fGenID > 0)
                tagDetectedArray[queIndex].fGenID = fGenID;
             else
                tagDetectedArray[queIndex].fGenID = 0;
             tagDetectedArray[queIndex].gID = gID;

             DisplayTagInListView(queIndex, fGenID, gID, fGenFlag, gIDFlag, rssi, "DET_RSSI"); //(DetectedTagListView->Items->Count);
             if ((*gIDFlag == false) && (*fGenFlag == false))
                tagDetectCount++;

             if (global)
                PlaySound("Ding.wav", NULL, SND_ASYNC );
          }
          else
          {
             if (configIndex > 0)
                UpdateTagDetectedArray(nr, fGenID, n, tgType, configIndex);
          }
       break;

       case ENABLE_FIELD_GEN_ACK:
          receivedResponse = true;
          if (recvBuf[2] == 4) //len=4
          {
             n = (unsigned char)recvBuf[4];
             RxReaderIDLabel->Caption = n;  //reader ID
          }
          else  //len = 4 (extended)
          {
             n = (unsigned int)((unsigned char)recvBuf[4])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[5]);
             RxReaderIDLabel->Caption = n;  //reader ID
          }

          RxCommandLabel->Caption = "Field Gen ACK";
          str = "Field Gen Enabled";
          StaticText->Caption = str; //field gen enabled
          PlaySound("Ding.wav", NULL, SND_ASYNC );
       break;

       case TAG_DETECTED_UNSOLICITED: //0x75
          if ((recvBuf[3] & 0x38) == 0x30)  //exteded reader
          {
              if (((int)recvBuf[7] == 0x01) && !displayLowBattery)
                  return;
          }
          else if ((recvBuf[3] & 0x38) == 0x10)  //reg reader
          {
              if (((int)recvBuf[6] == 0x01) && !displayLowBattery)
                  return;
          }

          receivedResponse = true;
          programming = false;

          PlaySound("Ding.wav", NULL, SND_ASYNC );
          if ((recvBuf[3] & 0x38) == 0x30)  //exteded reader
          {
             nr = (unsigned int)((unsigned char)recvBuf[4])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[5]);
             RxReaderIDLabel->Caption = nr;  //reader ID

             n = (unsigned int)((unsigned char)recvBuf[8])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[9])*pow(2, 16)+
                 (unsigned int)((unsigned char)recvBuf[10])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[11]);
             RxTagIDLabel->Caption = n;     //tag ID

             gID = ((unsigned char)recvBuf[12]) & 0x01;
             configIndex = 12;
             type = (unsigned char)recvBuf[12];  //tag type
             if ((type & 0xE0) == 0x20)    //0010 0000   //acc
             {
                RxTagTypeLabel->Caption = "Access";
                type = 0x01;
             }
             else if ((type & 0xE0) == 0x40)    //0100 0000  //inv
             {
                RxTagTypeLabel->Caption = "Inventory";
                type = 0x02;
             }
             else if ((type & 0xE0) == 0x60)    //0110 0000  //ass
             {
                RxTagTypeLabel->Caption = "Asset";
                type = 0x03;
             }
             else if ((type & 0xE0) == 0x70)    //1110 0000  //factory
             {
                RxTagTypeLabel->Caption = "Factory";
                type = 0x07;
             }

             index = 13;
             index2 = 7;
          }
          //else
          else if ((recvBuf[3] & 0x38) == 0x10)  //reg reader
          {
             nr = (unsigned char)recvBuf[4];
             RxReaderIDLabel->Caption = nr;  //reader ID

             n = (unsigned int)((unsigned char)recvBuf[7])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[8])*pow(2, 16)+
                 (unsigned int)((unsigned char)recvBuf[9])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[10]);
             RxTagIDLabel->Caption = n;     //tag ID

             gID = ((unsigned char)recvBuf[11]) & 0x01;
             configIndex = 11;
             type = (unsigned char)recvBuf[11];  //tag type
             if ((type & 0xE0) == 0x20)    //0010 0000   //acc
             {
                RxTagTypeLabel->Caption = "Access";
                type = 0x01;
             }
             else if ((type & 0xE0) == 0x40)    //0100 0000  //inv
             {
                RxTagTypeLabel->Caption = "Inventory";
                type = 0x02;
             }
             else if ((type & 0xE0) == 0x60)    //0110 0000  //ass
             {
                RxTagTypeLabel->Caption = "Asset";
                type = 0x03;
             }
             else if ((type & 0xE0) == 0x70)    //1110 0000  /factory
             {
                RxTagTypeLabel->Caption = "Factory";
                type = 0x07;
             }
             index = 12;
             index2 = 6;
          }
          else
             return;

          //index += 1;  //to bypass tag status

          i = recvBuf[2];
          i += 2;
          pktID = (int)recvBuf[i];

          str = "Tag ID ";
          str += n;

          if ((int)recvBuf[index2] == 0x01)
          {
             if (QueryTagGroupBox->Visible)  //display low battery in list view if query page is active
             {
                 TListItem* ListItem;
                 //unsigned int n;

                 ListItem = QueryTagListView->Items->Add();
                 ListItem->ImageIndex = -1;
                 ListItem->SubItems->Add(n);   //tag id
                 ListItem->SubItems->Add(RxTagTypeLabel->Caption);  //tag type
                 ListItem->SubItems->Add("-");  //enabled/disabled
                 ListItem->SubItems->Add("Low");  //low battery
                 ListItem->SubItems->Add("-");     //resend time
                 ListItem->SubItems->Add("-");     //TIF
                 ListItem->SubItems->Add("-");     //GC
                 ListItem->SubItems->Add("-");     //Tamper switch
                 ListItem->SubItems->Add("-");     //tag version

             }

             str += " ";
             str += RxTagTypeLabel->Caption;
             str += "  Low Battery.";
             RxCommandLabel->Caption = "Low Battery";
             StaticText->Caption = str;
             break;
          }
          else
          {
             str += " detected with Temperature information.";
             RxCommandLabel->Caption = "Tag detected";
          }

          StaticText->Caption = str;

          //RxCommandLabel->Caption = "Tag detected";

          int temp;
          temp = ((unsigned char)recvBuf[index] << 8) + (unsigned char)recvBuf[index+1];
          //int nbits = 12;
          if ( recvBuf[index] & 0x80 )   //negative num
          {
             temp = nBitTwosComplement(temp, (int)12);
          }

          tagTemperature =  temp * 0.0625;

          //tagTemperature = ((float)temp) / 16.0;
          //tagTemperature -= tagTempCalibC;

          index += 2;  //tag temp status
          ch = (unsigned char)recvBuf[index];

          if (!CheckSameTagTemp(n, type, gID, gIDFlag, dIndex, nr) || multiDisplayTagDetect || readTemp)
          {
             readTemp = false;

             if (*gIDFlag)
             {
                queIndex = *dIndex;
             }
             else
             {
                queIndex = tagTempCount;
             }

             tagTempArray[queIndex].lastDetectTime = Now();
             tagTempArray[queIndex].timeValue = GetNowTimeValue();

             tagTempArray[queIndex].tagID = n;
             tagTempArray[queIndex].readerID = nr;

             tagTempArray[queIndex].gID = gID;

             tagTempArray[queIndex].tagType = type;

             //short int temp = ((unsigned char)recvBuf[index] << 8) + (unsigned char)recvBuf[index+1];
             //tagTemperature = ((float)temp) / 16.0;

             //index += 2;  //tag temp status
             //ch = (unsigned char)recvBuf[index];

             if (TagTempDisplayListCheckBox->Checked && TagTempListGroupBox->Visible)
                DisplayTagTempInListView(n, tagTemperature, ch, type, nr);

             if ((*gIDFlag == false) && (*fGenFlag == false))
                tagTempCount++;

             if (global)
                PlaySound("Ding.wav", NULL, SND_ASYNC );
          }

          if (TagTempListGroupBox->Visible)
             DisplayTagTemperature(ch);

       break;

       case WRITE_TAG_MEMORY_ACK:  //0x8B

          EnableTagStaticCommands();
          CMDEnableTimer->Enabled = false;
          EnableAllBitbtnCommands();

          receivedResponse = true;
          programming = false;

          PlaySound("Ding.wav", NULL, SND_ASYNC );
          if ((recvBuf[3] & 0x38) == 0x30)  //exteded reader
          {
             nr = (unsigned int)((unsigned char)recvBuf[4])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[5]);
             RxReaderIDLabel->Caption = nr;  //reader ID
             extended = true;
             index = 7;

             /*type = (unsigned char)recvBuf[7];  //tag type
             gID = ((unsigned char)recvBuf[7]) & 0x01;

             if ((type & 0xE0) == 0x20)    //0010 0000   //acc
                RxTagTypeLabel->Caption = "Access";
             else if ((type & 0xE0) == 0x40)    //0100 0000  //inv
                RxTagTypeLabel->Caption = "Inventory";
             else if ((type & 0xE0) == 0x60)    //0110 0000  //ass
                RxTagTypeLabel->Caption = "Asset";

             n = (unsigned int)((unsigned char)recvBuf[8])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[9])*pow(2, 16)+
                 (unsigned int)((unsigned char)recvBuf[10])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[11]);
             RxTagIDLabel->Caption = n;     //tag ID
             index = 12;*/
          }
          //else
          else if ((recvBuf[3] & 0x38) == 0x10)  //reg reader
          {
             nr = (unsigned char)recvBuf[4];
             RxReaderIDLabel->Caption = nr;  //reader ID
             extended = false;
             index = 6;

             /*type = (unsigned char)recvBuf[6];  //tag type
             gID = ((unsigned char)recvBuf[6]) & 0x01;

             if ((type & 0xE0) == 0x20)    //0010 0000   //acc
                RxTagTypeLabel->Caption = "Access";
             else if ((type & 0xE0) == 0x40)    //0100 0000  //inv
                RxTagTypeLabel->Caption = "Inventory";
             else if ((type & 0xE0) == 0x60)    //0110 0000  //ass
                RxTagTypeLabel->Caption = "Asset";

             n = (unsigned int)((unsigned char)recvBuf[7])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[8])*pow(2, 16)+
                 (unsigned int)((unsigned char)recvBuf[9])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[10]);
             RxTagIDLabel->Caption = n;     //tag ID
             index = 11; */
          }
          else
             return;

          i = (unsigned char)recvBuf[2];
          i += 2;
          pktID = (int)recvBuf[i];

          if (pktID == READ_TAG_TEMPERATURE)
             StaticText->Caption = "Request for Tag Temperature was received successfully.";
          else if (pktID == WRITE_CONFIG_TAG_MEMORY)
          {
             //type = (unsigned char)recvBuf[index];  //tag type
             type = (unsigned char)recvBuf[index] & 0xE0;   //1110 0000
             type >>= 5;
             gID = ((unsigned char)recvBuf[index]) & 0x01;

             if ((type > 0) && (type <= 7))
             {
                if (type == 7)
                    RxTagTypeLabel->Caption = "Factory";
                else
                    RxTagTypeLabel->Caption = tagTypes[type - 1];
             }

             /*if ((type & 0xE0) == 0x20)    //0010 0000   //acc
                RxTagTypeLabel->Caption = "Access";
             else if ((type & 0xE0) == 0x40)    //0100 0000  //inv
                RxTagTypeLabel->Caption = "Inventory";
             else if ((type & 0xE0) == 0x60)    //0110 0000  //ass
                RxTagTypeLabel->Caption = "Asset"; */

             index += 1;
             n = (unsigned int)((unsigned char)recvBuf[index])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[index+1])*pow(2, 16)+
                 (unsigned int)((unsigned char)recvBuf[index+2])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[index+3]);
             RxTagIDLabel->Caption = n;     //tag ID
             index += 5;

             str = "Tag ID ";
             str += n;
             str += " Type ";
             str += RxTagTypeLabel->Caption;
             str += " was configured successfully.";
             StaticText->Caption = str;

             DisplayStatusByte(6, CONFIG_TAG);

             if (!CheckSameTag(n, type, fGenID, gID, fGenFlag, gIDFlag, dIndex, nr, CONFIG_TAG, rssi) || multiDisplayTagDetect)
             {
                if (*gIDFlag || *fGenFlag)
                {
                   queIndex = *dIndex;
                   nDuplicates++;
                }
                else
                {
                   queIndex = tagDetectCount;
                }

                LoadStatusByteToQue(configIndex, TAG_DETECTED, queIndex);

                tagDetectedArray[queIndex].lastDetectTime = Now();

                tagDetectedArray[queIndex].tagID = n;
                tagDetectedArray[queIndex].readerID = nr;
                tagDetectedArray[queIndex].cmd = CONFIG_TAG;
                tagDetectedArray[queIndex].tagType = type;
                tagDetectedArray[queIndex].rssi = rssi;

                if (fGenID > 0)
                   tagDetectedArray[queIndex].fGenID = fGenID;
                else
                   tagDetectedArray[queIndex].fGenID = 0;
                tagDetectedArray[queIndex].gID = gID;

                DisplayTagInListView(queIndex, fGenID, gID, fGenFlag, gIDFlag, 0, "CFG"); //(DetectedTagListView->Items->Count);
                if (*gIDFlag == false)
                   tagDetectCount++;
             }
             StaticText->Caption = "Config Tag command was executed successfully.";
          }
          else if (pktID == WRITE_TAG_TEMP_CONFIG)
          {
                StaticText->Caption = "Config Tag Temperature was successful.";
                EnableAllStaticTextCommands();
                RxCommandLabel->Caption = "Config Tag Temp ACK";

                if (first)
                {
                   first = false;
                   if(networkOn)
                   {
                      /*int rdr = atoi(TagTempReaderIDComboBox->Text.c_str());
                      int index = GetIpAddressIndex(rdr);
                      if (index >= 0)
                      {
                         WriteTCPIPComm(RESTART_TAG_TEMP_PERIODIC, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
                      }
                      else
                      {
                         Application->MessageBox("Did not find IP address.",
                                                 "Programming Station Information Dialog",
                                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
                         return;
                      }*/

                      int rdr = atoi(TagTempReaderIDComboBox->Text.c_str());
                      int index = GetSocketIndex(rdr);
                      if (index >= 0)
                      {
                         WriteAWSocket(RESTART_TAG_TEMP_PERIODIC, 0, NULL, index, 'S', NULL, 0, index);
                      }
                      else
                      {
                         StaticText->Caption = "No matching socket for the reader.";
                         return;
                      }
                   }
                   else if (RS232On)
                   {
                      WriteRS232Comm(RESTART_TAG_TEMP_PERIODIC, 0, NULL, 0);
                   }
                }//first
          }
          else if (pktID == RESTART_TAG_TEMP_PERIODIC)
          {
                StaticText->Caption = "Restarting Tag Temp Periodic Timer was successful.";
                EnableAllStaticTextCommands();
                RxCommandLabel->Caption = "Restart Tag Temp Periodic ACK";
          }
          else if (pktID == ABS_DPOT_SMART_FGEN)
          {
                StaticText->Caption = "Config Smart Field Gen Field Strength was successful.";
                EnableAllStaticTextCommands();
                RxCommandLabel->Caption = "Config Smart FGen ACK";
          }
          else if (pktID == WRITE_TAG_LOG_TIME)
          {
                StaticText->Caption = "Tag Temperature Logging Timestamp was recorded successfuly";
                EnableAllStaticTextCommands();
                RxCommandLabel->Caption = "Tag Log Timestamp ACK";
          }
          else if (pktID == CONFIG_SMART_FIELD_GEN)
          {
                //CMDEnableTimer->Enabled = false;
                //EnableAllCommands(true);
                StaticText->Caption = "Smart Field Gen was Configured successfully.";
                //EnableAllStaticTextCommands();
                lastSmartFieldGenID = (unsigned char)recvBuf[index];
                RxCommandLabel->Caption = "Config Smart FGen ACK";
          }
          else if (pktID == INC_DPOT_SMART_FGEN)  //0x11
          {
              unsigned short val;
              val = ((unsigned char)recvBuf[index+1]& 0x1F);

              SmartFGenDPotValueLabel->Caption = val;
              SmartFGenNewDPotEdit->Text = val;

              StaticText->Caption = "Smart Field Gen Field Strength was Incremented successfully.";
              RxCommandLabel->Caption = "Inc. Smart FGen DPot ACK";
          }
          else if (pktID == DEC_DPOT_SMART_FGEN)  //0x12
          {
              unsigned short val;
              val = ((unsigned char)recvBuf[index+1] & 0x1F);

              SmartFGenDPotValueLabel->Caption = val;
              SmartFGenNewDPotEdit->Text = val;

              StaticText->Caption = "Smart Field Gen Field Strength was Decremented successfully.";
              RxCommandLabel->Caption = "Dec. Smart FGen DPot ACK";
          }
          else if (pktID == SET_CONFIG_TAG_LED)
          {
                //CMDEnableTimer->Enabled = false;
                //EnableAllCommands(true);
                StaticText->Caption = "Tag LED Configured successfully.";
                //EnableAllStaticTextCommands();
                RxCommandLabel->Caption = "Config Tag LED ACK";
          }
          else
          {
             StaticText->Caption = "Write Tag Memory command was executed successfully.";
             RxCommandLabel->Caption = "Write Tag Mem ACK";

             //if ((LargeDataCheckBox->Checked) && (pktID != lastWritePktID))
             //{
                //GeneralTimer->Enabled = false;
             //}

             //////////  Large Data tag mem write  NEW CODE  //////////////////////
             //-------------------------------------------------------------------

             largDataWriteAck = true;
             largeDataWriteAckCounter = 0;
             largeDataReadAckCounter = 0;
             largeDataWriteRetryCt = 0;
             largeDataReadRetryCt = 0;

             if ((LargeDataCheckBox->Checked) &&
                 (pktID != lastWritePktID) &&
                  writeTagData && WriteMemoryGroupBox->Visible)
             {
                 if (totByteWritten <= atoi(WriteMemoryNumByteEdit->Text.c_str()))
                 {
                    //largDataWriteAck = true;
                    largeDataWriteRetry = false;
                    //////////RetryTimer->Enabled = false;
                    WriteTimer->Enabled = false;
                    ReadTimer->Enabled = true;
                 }
                 /*else
                 {
                    writeTagData = false;
                    largDataWriteAck = true;
                    largeDataWriteRetry = false;
                    RetryTimer->Enabled = false;
                    WriteTimer->Enabled = false;
                    ReadTimer->Enabled = false;
                    StaticText->Caption = "Writing large data to the tag successfully completed.";
                 }*/
             }


                    /////////////////////////////////////////////////////////////////////

             //////////  Large Data tag mem write  OLD OLD CODE  //////////////////////
             //-------------------------------------------------------------------

             /*if ((LargeDataCheckBox->Checked) && (pktID != lastWritePktID) && (totByteWritten < atoi(WriteMemoryNumByteEdit->Text.c_str())))
             {
                //GeneralTimer->Enabled = false;
                //nextPkt = true;
                //retry = 0;

                if ((LargeDataCheckBox->Checked) &&
                       (pktID != lastWritePktID) &&
                       writeTagData)
                   {
                       totByteWritten += 12;
                       AnsiString str = "Bytes Written: ";
                       str += totByteWritten;
                       BytesWrittenLabel->Caption = str;
                       BytesWrittenLabel->Invalidate();

                       if (totByteWritten < atoi(WriteMemoryNumByteEdit->Text.c_str()))
                       {
                          lastWritePktID = pktID;
                          AnsiString addrS = WriteMemoryStartAddrEdit->Text;
                          int addr = HexToInt(addrS.c_str(), addrS.Length());
                          //int addr = 224;
                          addr += 16;
                          WriteMemoryStartAddrEdit->Text = IntToHex(addr, 4);

                          //totByteWritten += 8;
                          //AnsiString str = "Bytes Written: ";
                          //str += totByteWritten;
                          //BytesWrittenLabel->Caption = str;

                          //GeneralTimer->Enabled = true;


                          if(networkOn)
                          {
                             int rdr = atoi(WriteMemoryReaderIDComboBox->Text.c_str());
                             int index = GetSocketIndex(rdr);
                             if (index >= 0)
                             {
                                WriteAWSocket(WRITE_TAG_MEMORY, 0, NULL, index, 'S', NULL, 0, index);
                             }
                             else
                                StaticText->Caption = "No matching socket for the reader.";
                          }
                          else if (RS232On)
                          {
                              //WriteRS232Comm(WRITE_TAG_MEMORY, 0, NULL, 0);
                              nextPkt = true;
                              retry = 0;
                              GeneralTimer->Enabled = true;
                              numWritePkts += 1;
                              AnsiString s = "#Pkts: ";
                              s += numWritePkts;
                              WriteNumPKtLabel->Caption = s;
                              WriteNumPKtLabel->Invalidate();
                          }
                       }
                       else
                       {
                          GeneralTimer->Enabled = false;
                          writeTagData = false;
                          PlaySound("Ding.wav", NULL, SND_ASYNC );
                          StaticText->Caption = "Writing large data to the tag completed.";
                          displayElapsedTime = false;
                       }
                   }

                /*lastWritePktID = pktID;
                largDataWriteAck = true;
                retry = 0;
                AnsiString addrStr = WriteMemoryStartAddrEdit->Text;
                int addr = HexToInt(addrStr.c_str(), 4);
                addr += 16;
                WriteMemoryStartAddrEdit->Text = IntToHex(((int)addr), 4);
                totByteWritten += 12;
                AnsiString str = "Bytes Written: ";
                str += totByteWritten;
                BytesWrittenLabel->Caption = str;

                if(networkOn)
                {
                    int rdr = atoi(WriteMemoryReaderIDComboBox->Text.c_str());
                    int index = GetSocketIndex(rdr);
                    if (index >= 0)
                    {
                       WriteAWSocket(WRITE_TAG_MEMORY, 0, NULL, index, 'S', NULL, 0, index);
                    }
                    else
                        StaticText->Caption = "No matching socket for the reader.";
                }
                else if (RS232On)
                {
                    WriteRS232Comm(WRITE_TAG_MEMORY, 0, NULL, 0);
                    //GeneralTimer->Enabled = true;
                   // numWritePkts += 1;
                   // AnsiString s = "#Pkts: ";
                   // s += numWritePkts;
                   // WriteNumPKtLabel->Caption = s;
                   // WriteNumPKtLabel->Invalidate();
                } */

             //}//if largedata section
             //*/
             /////OLD OLD /////////////////////////////////////////////////////////////////////////

          }
       break;

       case READ_TAG_MEMORY_ACK:  //0x8C

          EnableTagStaticCommands();
          CMDEnableTimer->Enabled = false;
          EnableAllBitbtnCommands();

          receivedResponse = true;
          programming = false;

          if ((recvBuf[3] & 0x38) == 0x30)  //exteded reader
          {
             extended = true;
             nr = (unsigned int)((unsigned char)recvBuf[4])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[5]);
             RxReaderIDLabel->Caption = nr;  //reader ID
             index = 6;

             /*type = recvBuf[7];  //tag type
             if ((type & 0xE0) == 0x20)    //0010 0000   //acc
                RxTagTypeLabel->Caption = "Access";
             else if ((type & 0xE0) == 0x40)    //0100 0000  //inv
                RxTagTypeLabel->Caption = "Inventory";
             else if ((type & 0xE0) == 0x60)    //0110 0000  //ass
                RxTagTypeLabel->Caption = "Asset";

             n = (unsigned int)(unsigned char)recvBuf[8]*pow(2, 24)+(unsigned int)(unsigned char)recvBuf[9]*pow(2, 16)+
                 (unsigned int)(unsigned char)recvBuf[10]*pow(2, 8)+(unsigned int)(unsigned char)recvBuf[11];
             RxTagIDLabel->Caption = n;     //tag ID
             index = 12;*/
          }
          //else
          else if ((recvBuf[3] & 0x38) == 0x10)  //reg reader
          {
             extended = false;
             nr = (unsigned char)recvBuf[4];
             RxReaderIDLabel->Caption = nr;  //reader ID
             index = 5;

             /*type = recvBuf[6];  //tag type
             if ((type & 0xE0) == 0x20)    //0010 0000   //acc
                RxTagTypeLabel->Caption = "Access";
             else if ((type & 0xE0) == 0x40)    //0100 0000  //inv
                RxTagTypeLabel->Caption = "Inventory";
             else if ((type & 0xE0) == 0x60)    //0110 0000  //ass
                RxTagTypeLabel->Caption = "Asset";

             n = (unsigned int)(unsigned char)recvBuf[7]*pow(2, 24)+(unsigned int)(unsigned char)recvBuf[8]*pow(2, 16)+
                 (unsigned int)(unsigned char)recvBuf[9]*pow(2, 8)+(unsigned int)(unsigned char)recvBuf[10];
             RxTagIDLabel->Caption = n;     //tag ID
             index = 11; */
          }
          else
             return;

          PlaySound("Ding.wav", NULL, SND_ASYNC );

          //get data here ---------------
          i = (unsigned char)recvBuf[2];
          i += 2;
          pktID = (int)recvBuf[i];

          if (pktID == READ_CONFIG_TAG_MEMORY) //0x50
          {
             if (extended)
                index = 7+5;
             else
                index = 6+5;

             /*int n = GetTagTypeComboBoxIndex(recvBuf[index]);
             if (n <= 0)
                ConfigTagTypeComboBox->Text = "";
             else
                ConfigTagTypeComboBox->ItemIndex = n;*/


             //Tag Type
             /*if ((recvBuf[index] & 0xE0) == 0x20)  //access
                ConfigTagAccessCtrlRadioButton->Checked = true;
             else if ((recvBuf[index] & 0xE0) == 0x40)  //inventory
                ConfigTagInvetRadioButton->Checked = true;
             else if ((recvBuf[index] & 0xE0) == 0x60)  //asset
                ConfigTagAssetCtrlRadioButton->Checked = true;
             else if ((recvBuf[index] & 0xE0) == 0xE0)  //factory
                ConfigTagFactoryRadioButton->Checked = true;*/

             //Tag Tamper
             if (((recvBuf[index] & 0x18) == 0x08) || //Disable   000 01 000
                 ((recvBuf[index] & 0x18) == 0x00))
                ConfigTagNoReportRadioButton->Checked = true;
             else if ((recvBuf[index] & 0x18) == 0x18)  //Report Real Time  000 11 000
                ConfigTagReportStatusRadioButton->Checked = true;
             else if ((recvBuf[index] & 0x18) == 0x10)  //Report history   000 10 000
                ConfigTagReportHistoryRadioButton->Checked = true;
             index += 1;

             //tag ID
             n = (unsigned int)((unsigned char)recvBuf[index])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[index+1])*pow(2, 16)+
                 (unsigned int)((unsigned char)recvBuf[index+2])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[index+3]);
             ConfigTagTagIDRadioButton->Checked = true;
             ConfigTagTagIDEdit->Text = n;
             index += 4;

             ConfigTagTIFComboBox->Text =  2*(unsigned int)((recvBuf[index] & 0xF0) >> 4);
             if ((unsigned int)(recvBuf[index] & 0x0F) == 0x00)
                ConfigTagGCComboBox->Text = "1";
             else
                ConfigTagGCComboBox->Text = 2*(unsigned int)(recvBuf[index] & 0x0F);
             index += 1;

             n = (unsigned int)((unsigned char)recvBuf[index])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[index+1]);
             double n1 = ceil(n/3.00);
             if (n1 == 0)
                ConfigTagDurationComboBox->Text = "Stop";
             else
                {
                    int unit = GetTimePeriodUnit();
                    if (unit==1)
                    {
                        ConfigTagDurationComboBox->Text = n1;
                    }
                    else if (unit==2)
                    {
                        ConfigTagDurationComboBox->Text = n1/(60);
                    }
                    else if(unit ==3)
                    {
                        ConfigTagDurationComboBox->Text = n1/(3600);
                    }
                }

             StaticText->Caption = "Tag configuration received successfully.";
          }
          else if (pktID == QUERY_SMART_FIELD_GEN)  //0x97
          {
             //CMDEnableTimer->Enabled = false;
             //EnableAllCommands(true);
             if (extended)
             {
                fGenID = (unsigned char)recvBuf[7];
                index = 8;
             }
             else
             {
                fGenID = (unsigned char)recvBuf[6];
                index = 7;
             }

             lastSmartFieldGenID = fGenID;

             if (QuerySFGenGroupBox->Visible)    //Query FGen
             {
                QueryFGenSmartFGenIDComboBox->Text = fGenID;  //field gen
                QueryFGenSmartFGenRdrIDComboBox->Text = nr; //reader

                TListItem* ListItem;

                ListItem = QuerySFGenListView->Items->Add();
                ListItem->ImageIndex = -1;
                ListItem->SubItems->Add((unsigned char)recvBuf[index]);  //fgen id
                index += 1;

                nr = (unsigned int)((unsigned char)recvBuf[index])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[index+1]);
                ListItem->SubItems->Add(nr);  //rdr id
                index += 2;

                str = (unsigned char)(recvBuf[index]&0x3F);  //xtime
                str += "  sec";
                ListItem->SubItems->Add(str);
                int indx = index;
                index += 1;

                int d = (unsigned char)(recvBuf[index]&0x3F); //wait time
                if (d == 0x00)
                   str = "Disable";
                else if (d == 0xFF)
                   str = "All Time";
                else
                {
                   str = d;
                   if (((unsigned char)recvBuf[index] & 0xC0) == 0x00)  //1100 0000 sec
                     str += " S";
                   else if (((unsigned char)recvBuf[index] & 0xC0) == 0x01)  //1100 0000 min
                     str += " M";
                   else if (((unsigned char)recvBuf[index] & 0xC0) == 0x10)  //1100 0000 hour
                     str += " H";
                }
                ListItem->SubItems->Add(str);  //wtime
                index += 1;

                //Motion Detector Enable/Disable
                if ((unsigned char)(recvBuf[indx]& 0x40) == 0x00)  //0x00 0000   //PIR enable/disable
                   ListItem->SubItems->Add("Enable");
                else
                   ListItem->SubItems->Add("Disable");

                //Motion Detector Status
                if ((unsigned char)(recvBuf[indx]& 0x80) == 0x00)  //x000 0000   //PIR enable/disable
                   ListItem->SubItems->Add("Active Low");
                else
                   ListItem->SubItems->Add("Active High");

                AnsiString sType;
                int p = 0;

               if (((unsigned char)recvBuf[index] & 0xE0) == 0x00)
               {
                  str = "All Types";
                  p = SFGenConfigTagTypeComboBox->Items->Count - 1;
               }
               else if ((p=GetTagTypesIndex((unsigned char)recvBuf[index])) < 0)
                   str = " ";
               else
               {
                    if (tagTypesAbr[p].data() == NULL)
                    {
                        if (p == 0x00)
                             str = "T00";
                        else
                        {
                             str = "T0";
                             str += p;
                        }
                    }
                    else
                        str = tagTypesAbr[p];
               }

               if (p >= 0)
               {
                   SFGenConfigTagTypeComboBox->ItemIndex = p;
                   sType = str;
               }

                /*if (((unsigned char)recvBuf[index] & 0xE0) == 0x20)    //0010 0000   //acc
                   sType = "ACC";
                else if (((unsigned char)recvBuf[index] & 0xE0) == 0x40)    //0100 0000  //inv
                   sType = "INV";
                else if (((unsigned char)recvBuf[index] & 0xE0) == 0x60)    //0110 0000  //ass
                   sType = "AST";
                else
                   sType = "NA"; */

                index += 1;

                n = (unsigned int)((unsigned char)recvBuf[index])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[index+1])*pow(2, 16)+
                    (unsigned int)((unsigned char)recvBuf[index+2])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[index+3]);
                index += 4;

                ListItem->SubItems->Add(((unsigned char)recvBuf[index]&0x1F));  //dpot

                //need to insert code here for FS Range short / Large
                if ((recvBuf[index]&0x40) == 0x40)
                   ListItem->SubItems->Add("Long");
                else
                   ListItem->SubItems->Add("Short");

                ListItem->SubItems->Add(sType);  //tag type
                if (n == 0)
                   ListItem->SubItems->Add("Any ID");      //tag id
                else
                   ListItem->SubItems->Add(n);      //tag id

                   //EnableAllStaticTextCommands();
                StaticText->Caption = "Query Smart FGen was successful.";
             }
             else if (ConfigSFGenGroupBox->Visible)   //Config FGen ---------
             {
                FGenConfigSmartFieldGenIDComboBox->Text = fGenID;  //field gen
                FGenConfigSmartFGenReaderIDComboBox->Text = nr; //reader

                index += 1;
                nr = (unsigned int)((unsigned char)recvBuf[index])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[index+1]);
                SFGenConfigAssignedReaderIDEdit->Text = nr;  //assigned rdr id
                index += 2;

                str = (unsigned char)(recvBuf[index]&0x3F);  //xtime
                SFGenConfigTxTimeComboBox->Text = str;
                int indx = index;
                index += 1;

                int d = (unsigned char)(recvBuf[index]&0x3F); //wait time
                if (d == 0x00)
                {
                   str = "Disable";
                   SFGenConfigWaitTimeComboBox->Text = str;
                   SFGenConfigWaitTimeSecRadioButton->Checked = true;
                }
                else if (d == 0xFF)
                {
                   str = "All Time";
                   SFGenConfigWaitTimeComboBox->Text = str;
                   SFGenConfigWaitTimeSecRadioButton->Checked = true;
                }
                else
                {
                   str = d;
                   SFGenConfigWaitTimeComboBox->Text = str;

                   if (((unsigned char)recvBuf[index] & 0xC0) == 0x00)  //1100 0000 sec  00
                   {
                     str += " S";
                     SFGenConfigWaitTimeSecRadioButton->Checked = true;
                   }
                   else if (((unsigned char)recvBuf[index] & 0xC0) == 0x40)  //1100 0000 min  01
                   {
                     str += " M";
                     SFGenConfigWaitTimeMinRadioButton->Checked = true;
                   }
                   else if (((unsigned char)recvBuf[index] & 0xC0) == 0x80)  //1100 0000 hour  10
                   {
                     str += " H";
                     SFGenConfigWaitTimeHourRadioButton->Checked = true;
                   }
                }
                index += 1;

                //Motion Detector Enable/Disable
                if ((unsigned char)(recvBuf[indx]& 0x40) == 0x00)  //0x00 0000   //PIR enable/disable
                {
                   SFGenConfigMDEnableCheckBox->Checked = false;
                }
                else
                {
                   SFGenConfigMDEnableCheckBox->Checked = true;
                }

                //Motion Detector Status
                if ((unsigned char)(recvBuf[indx]& 0x80) == 0x00)  //x000 0000   //PIR enable/disable
                {
                   SFGenConfigMDActiveLoRadioButton->Checked = true;
                }
                else
                {
                   SFGenConfigMDActiveHiRadioButton->Checked = true;
                }

                AnsiString sType;
                int p = 0;

               if (((unsigned char)recvBuf[index] & 0xE0) == 0x00)
               {
                  str = "All Types";
                  p = SFGenConfigTagTypeComboBox->Items->Count - 1;
               }
               else if ((p=GetTagTypesIndex((unsigned char)recvBuf[index])) < 0)
                  str = " ";
               else
               {
                  if (tagTypesAbr[p].data() == NULL)
                  {
                      if (p == 0x00)
                         str = "T00";
                      else
                      {
                          str = "T0";
                          str += p;
                      }
                  }
                  else
                      str = tagTypesAbr[p];
               }

               if (p >= 0)
                 SFGenConfigTagTypeComboBox->ItemIndex = p;

                /*if (((unsigned char)recvBuf[index] & 0x01) == 0x01)     //RA/RN
                   SFGenConfigRALongRadioButton->Checked = true;
                else
                   SFGenConfigRNShortRadioButton->Checked = true;

                if (((unsigned char)recvBuf[index] & 0xE0) == 0x20)    //0010 0000   //acc
                {
                   sType = "ACC";
                   SFGenConfigAccessRadioButton->Checked = true;
                }
                else if (((unsigned char)recvBuf[index] & 0xE0) == 0x40)    //0100 0000  //inv
                {
                   sType = "INV";
                   SFGenConfigInventoryRadioButton->Checked = true;
                }
                else if (((unsigned char)recvBuf[index] & 0xE0) == 0x60)    //0110 0000  //ass
                {
                   sType = "AST";
                   SFGenConfigAssetRadioButton->Checked = true;
                }
                else
                {
                   sType = "NA";
                   SFGenConfigAnyTypeRadioButton->Checked = true;
                }*/
                index += 1;

                n = (unsigned int)((unsigned char)recvBuf[index])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[index+1])*pow(2, 16)+
                    (unsigned int)((unsigned char)recvBuf[index+2])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[index+3]);
                if (n > 0)
                {
                   SFGenConfigTagIDEdit->Text = n;
                   SFGenConfigTagIDRadioButton->Checked = true;
                }
                else
                {
                   SFGenConfigTagIDEdit->Text = "";
                   SFGenConfigAnyTagIDRadioButton->Checked = true;
                }
                index += 4;

                FGenConfigPotentiComboBox->Text = (unsigned char)(recvBuf[index] & 0x1F);  //dpot
                if ((recvBuf[index] & 0x40) == 0x40)
                   SFGenConfigLongRangeRadioButton->Checked = true;
                else
                   SFGenConfigShortRangeRadioButton->Checked = true;
             }
          }
          else if (pktID == GET_DPOT_SMART_FGEN)  //0x99
          {
             unsigned short val;
             if (extended)
                val = ((unsigned char)recvBuf[8]&0x1F); //(unsigned char)recvBuf[8];
             else
                val = ((unsigned char)recvBuf[7]&0x1F); //(unsigned char)recvBuf[7];

             SmartFGenDPotValueLabel->Caption = val;
             SmartFGenNewDPotEdit->Text = val;

             StaticText->Caption = "Get Smart Field Gen Field Strength was successful.";
             RxCommandLabel->Caption = "Get Smart FGen DPot ACK";
          }
          else if (pktID == QUERY_PROC_SMART_FIELD_GEN)   //0x98
          {
             if (extended)
             {
                fGenID = (unsigned char)recvBuf[7];
                nr =  (unsigned int)((unsigned char)recvBuf[4])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[5]);   //rdrID
                index = 8;
             }
             else
             {
                fGenID = (unsigned char)recvBuf[6];
                nr =  (unsigned char)recvBuf[4];  //rdrID
                index = 7;
             }

             if (QuerySFGenGroupBox->Visible)
             {
                TListItem* ListItem;

                ListItem = QuerySFGenProcListView->Items->Add();
                ListItem->ImageIndex = -1;

                ListItem->SubItems->Add(fGenID);  //fgen id
                ListItem->SubItems->Add(nr);   //reader ID

                str = (unsigned char)recvBuf[index];  //j code version
                ListItem->SubItems->Add(str);  //j code version
                index += 1;

                unsigned short day;
                day = (unsigned char)recvBuf[index];  //day
                if (day < 10)
                {
                   str = "0";
                   str += day;
                }
                else
                   str = day;
                index += 1;
                str += " ";
                str += GetMonth((unsigned char)((recvBuf[index]&0xF0) >> 4));
                str += " 0";
                str += (unsigned char)(recvBuf[index]&0x0F);
                index += 3;
                ListItem->SubItems->Add(str); //j Date

                str = (unsigned char)recvBuf[index];  //k code version
                ListItem->SubItems->Add(str);  //k code version
                index += 1;

                day = (unsigned char)recvBuf[index];  //day
                if (day < 10)
                {
                   str = "0";
                   str += day;
                }
                else
                   str = day;
                index += 1;
                str += " ";
                str += GetMonth((unsigned char)((recvBuf[index]&0xF0) >> 4));
                str += " 0";
                str += (unsigned char)(recvBuf[index]&0x0F);
                index += 1;
                ListItem->SubItems->Add(str); //j Date

                GetProcRevDateBitBtn->Enabled = true;
                //QuerySFGenBitBtn->Enabled = true;
                //EnableAllStaticTextCommands();

                StaticText->Caption = "Query Smart Field Gen was successful.";
             }
          } //QUERY_PROC_SMART_FIELD_GEN
          else if (pktID == GET_DPOT_SMART_FGEN)   //0x99
          {
             if (extended)
             {
                fGenID = (unsigned char)recvBuf[7];
                index = 8;
             }
             else
             {
                fGenID = (unsigned char)recvBuf[6];
                index = 7;
             }

             if (SmartFGenGroupBox->Visible)
             {
                //put here dpot value here
                //when it is read from the packet
                SmartFGenDPotValueLabel->Caption = "";  //dpot value
                SmartFGenPotentioUpDown->Position = 0;
                SmartFGenDPotValueLabel->Caption = "";   //dpot value
             }
          } //GET_DPOT_SMART_FGEN
          else if (pktID == QUERY_SMART_FIELD_GEN)
          {
              //CMDEnableTimer->Enabled = false;
              //EnableAllCommands(true);
              StaticText->Caption = "Query Smart Field Gen was successful.";
              //EnableAllStaticTextCommands();
              RxCommandLabel->Caption = "Query Smart FGen ACK";
          }
          else if (pktID == GET_CONFIG_TAG_SPEAKER)
          {
             index += 1;
             int tType = GetTagTypesIndex(recvBuf[index]);
             /*type = recvBuf[index];  //tag type
             if ((type & 0xE0) == 0x20)    //0010 0000   //acc
                str = "ACC";
             else if ((type & 0xE0) == 0x40)    //0100 0000  //inv
                str = "INV";
             else if ((type & 0xE0) == 0x60)    //0110 0000  //ass
                str = "AST";
             else if ((type & 0xE0) == 0xE0)    //1110 0000  //Fact
                str = "FACT"; */

             if ((tType >= 0x00) && (tType <= 0x06))
             {
                if (tagTypesAbr[tType].data() == NULL)
                {
                    if (tType == 0x00)
                       str = "T00";
                    else
                    {
                       str = "T0";
                       str += tType;
                    }
                }
                else
                   str = tagTypesAbr[tType];
             }
             else
                 str = "";

             n = (unsigned int)(unsigned char)recvBuf[index+1]*pow(2, 24)+(unsigned int)(unsigned char)recvBuf[index+2]*pow(2, 16)+
                 (unsigned int)(unsigned char)recvBuf[index+3]*pow(2, 8)+(unsigned int)(unsigned char)recvBuf[index+4];

             if (!IsInSpkList(n, str))
             {
                TListItem* item;
                item = ConfigTagSpeakerListView->Items->Add();
                item->ImageIndex = -1;

                item->SubItems->Add(nr);     //reader
                item->SubItems->Add(n);      //tag
                item->SubItems->Add(str);    //type
                index += 5; //to get to data
                item->SubItems->Add((UINT)(recvBuf[index]));
                item->MakeVisible(false);
             }
          }
          else if (pktID == GET_CONFIG_TAG_LED)
          {
             index += 1;

             /*type = recvBuf[index];  //tag type
             if ((type & 0xE0) == 0x20)    //0010 0000   //acc
                str = "ACC";
             else if ((type & 0xE0) == 0x40)    //0100 0000  //inv
                str = "INV";
             else if ((type & 0xE0) == 0x60)    //0110 0000  //ass
                str = "AST";
             else if ((type & 0xE0) == 0xE0)    //1110 0000  //Fact
                str = "FACT"; */

             int tType = GetTagTypesIndex(recvBuf[index]);

             if ((tType >= 0x00) && (tType <= 0x06))
             {
                if (tagTypesAbr[tType].data() == NULL)
                {
                    if (tType == 0)
                       str = "T00";
                    else
                    {
                       str = "T0";
                       str += tType;
                    }
                }
                else
                   str = tagTypesAbr[tType];
             }
             else
                 str = "";

             n = (unsigned int)(unsigned char)recvBuf[index+1]*pow(2, 24)+(unsigned int)(unsigned char)recvBuf[index+2]*pow(2, 16)+
                 (unsigned int)(unsigned char)recvBuf[index+3]*pow(2, 8)+(unsigned int)(unsigned char)recvBuf[index+4];

             if (!IsInLEDList(n, str))
             {
                TListItem* item;
                item = ConfigTagLEDListView->Items->Add();
                item->ImageIndex = -1;

                item->SubItems->Add(nr);     //reader
                item->SubItems->Add(n);      //tag
                item->SubItems->Add(str);    //type
                index += 5; //to get to data
                item->SubItems->Add((UINT)(recvBuf[index]));
                item->MakeVisible(false);
             }


             /*if (((unsigned char)recvBuf[index] & 0x80) == 0x80)  //led enable  1000 0000
                ConfigTagLEDEnableCheckBox->Checked = true;
             else
                ConfigTagLEDEnableCheckBox->Checked = false;

             if (((unsigned char)recvBuf[index] & 0x40) == 0x40)  //use 20 msec 0100 0000
             {
                ConfigTagLED20msecDelayRadioButton->Checked = true;
                ConfigTagLED1msecDelayRadioButton->Checked = false;
             }
             else
             {
                ConfigTagLED20msecDelayRadioButton->Checked = false;
                ConfigTagLED1msecDelayRadioButton->Checked = true;
             }*/

             //ConfigTagLEDNumCyclesEdit->Text = (UINT)(recvBuf[index]);  // & 0x3F);  //0011 1111
             //index += 1;

             //ConfigTagLEDCountOnEdit->Text = (unsigned char)recvBuf[index];
             //index += 1;

             //ConfigTagLEDCountOffEdit->Text = (unsigned char)recvBuf[index];

             //CMDEnableTimer->Enabled = false;
             //EnableAllCommands(true);

             StaticText->Caption = "Get config LED tag setting was successful.";
             //EnableAllStaticTextCommands();
             RxCommandLabel->Caption = "Get LED Tag Config ACK";
          }
          else if (pktID == READ_TAG_TEMP_CONFIG)
          {
             if (extended)
             {
                type = (unsigned char)recvBuf[7];  //tag type
                if ((type & 0xE0) == 0x20)    //0010 0000   //acc
                   RxTagTypeLabel->Caption = "Access";
                else if ((type & 0xE0) == 0x40)    //0100 0000  //inv
                   RxTagTypeLabel->Caption = "Inventory";
                else if ((type & 0xE0) == 0x60)    //0110 0000  //ass
                   RxTagTypeLabel->Caption = "Asset";

                n = (unsigned int)((unsigned char)recvBuf[8])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[9])*pow(2, 16)+
                    (unsigned int)((unsigned char)recvBuf[10])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[11]);
                RxTagIDLabel->Caption = n;     //tag ID
                index = 12;
             }
             else
             {
                type = (unsigned char)recvBuf[6];  //tag type
                if ((type & 0xE0) == 0x20)    //0010 0000   //acc
                   RxTagTypeLabel->Caption = "Access";
                else if ((type & 0xE0) == 0x40)    //0100 0000  //inv
                   RxTagTypeLabel->Caption = "Inventory";
                else if ((type & 0xE0) == 0x60)    //0110 0000  //ass
                   RxTagTypeLabel->Caption = "Asset";

                n = (unsigned int)((unsigned char)recvBuf[7])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[8])*pow(2, 16)+
                    (unsigned int)((unsigned char)recvBuf[9])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[10]);
                RxTagIDLabel->Caption = n;     //tag ID
                index = 11;
             }

             if (TagTempChangeReportCheckBox->Checked)
             {
                if (TagTempLoggingCheckBox->Checked)
                {
                    TagTempTimeStampBitBtn->Enabled = true;
                    TagTempWarpAroundCheckBox->Enabled = true;
                }
                else
                {
                    TagTempTimeStampBitBtn->Enabled = false;
                    TagTempWarpAroundCheckBox->Enabled = false;
                }
             }
             //if (!tempDisplayed)
             {
               tagTempCtrlByte = (unsigned char)recvBuf[index];
               tagTempPeriodByte = (unsigned char)recvBuf[index+1];

               //Tag Temp Hi Limit
               int temp = ((unsigned char)recvBuf[index+2] << 8) + (unsigned char)recvBuf[index+3];
               if ( recvBuf[index+2] & 0x80 )   //negative num
               {
                  temp = nBitTwosComplement(temp, (int)12);
               }
               tagTempHiLimit =  temp * 0.0625;

               //tagTempHiLimit = ((float)temp) / 16.0;
               //tagTempHiLimit -= tagTempCalib;

               //Tag Temp Low Limit
               temp = ((unsigned char)recvBuf[index+4] << 8) + (unsigned char)recvBuf[index+5];
               if ( recvBuf[index+4] & 0x80 )   //negative num
               {
                  temp = nBitTwosComplement(temp, (int)12);
               }
                tagTempLoLimit =  temp * 0.0625;

               //temp = ((unsigned char)recvBuf[index+4] << 8) + (unsigned char)recvBuf[index+5];
               //tagTempLoLimit = ((float)temp) / 16.0;

               //tagTempLoLimit -= tagTempCalib;
               UpdateTemperatureScreen();
               StaticText->Caption = "Temperature status command was executed successfully.";
              }
               /*tempDisplayed = false;
               if(networkOn)
               {
                  int rdr = atoi(ReadMemoryReaderIDComboBox->Text.c_str());
                  int index = GetIpAddressIndex(rdr);
                  if (index >= 0)
                  {
                      WriteTCPIPComm(READ_TAG_TEMPERATURE, 0, NULL, 0, activeSock[index][0], peerSock[index]);
                  }
               }
               else if (RS232On)
               {
                  WriteRS232Comm(READ_TAG_TEMPERATURE, 0, NULL, 0);
               }*/
          }
          /*else if (pktID == READ_TAG_TEMPERATURE)
          {
             if (!tempDisplayed)
             {
                short int temp = (recvBuf[index] << 8) + recvBuf[index+1];
                tagTemperature = ((float)temp) / 16.0;
                DisplayTagTemperature();
                //"Temperature value was read successfully.";
            }
          }*/
          else  //Read Memory screen  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
          {
             if (extended)
             {
                type = (unsigned char)recvBuf[7];  //tag type
                if ((type & 0xE0) == 0x20)    //0010 0000   //acc
                   RxTagTypeLabel->Caption = "Access";
                else if ((type & 0xE0) == 0x40)    //0100 0000  //inv
                   RxTagTypeLabel->Caption = "Inventory";
                else if ((type & 0xE0) == 0x60)    //0110 0000  //ass
                   RxTagTypeLabel->Caption = "Asset";

                n = (unsigned int)((unsigned char)recvBuf[8])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[9])*pow(2, 16)+
                    (unsigned int)((unsigned char)recvBuf[10])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[11]);
                RxTagIDLabel->Caption = n;     //tag ID
                index = 12;
             }
             else
             {
                type = (unsigned char)recvBuf[6];  //tag type
                if ((type & 0xE0) == 0x20)    //0010 0000   //acc
                   RxTagTypeLabel->Caption = "Access";
                else if ((type & 0xE0) == 0x40)    //0100 0000  //inv
                   RxTagTypeLabel->Caption = "Inventory";
                else if ((type & 0xE0) == 0x60)    //0110 0000  //ass
                   RxTagTypeLabel->Caption = "Asset";

                n = (unsigned int)((unsigned char)recvBuf[7])*pow(2, 24)+(unsigned int)((unsigned char)recvBuf[8])*pow(2, 16)+
                    (unsigned int)((unsigned char)recvBuf[9])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[10]);
                RxTagIDLabel->Caption = n;     //tag ID
                index = 11;
             }

             AnsiString ss = "pktID: ";
             ss += pktID;
             WriteNumRetryLabel->Caption = ss;

             ss = "olDPkt: ";
             ss += lastReadPktID;
             ReadNumRetryLabel->Caption = ss;

             //WriteNumRetryLabel->Caption = "#W: 00";
             //ReadNumRetryLabel->Caption = "#R: 00";

             largeDataReadAck = true;
             largeDataReadAckCounter = 0;
             largeDataWriteAckCounter = 0;
             largeDataWriteRetryCt = 0;
             largeDataReadRetryCt = 0;

             bool goRead = false;
             if ((LargeDataCheckBox->Checked) &&
                 (pktID != lastReadPktID) &&
                  writeTagData && WriteMemoryGroupBox->Visible)
             {
                 ReadTimer->Enabled = false;
                 lastReadPktID = pktID;
                 for (int d=0; d<50; d++)
                    largeDataLastReadBuf[d] = '\0';

                 goRead = true;
             }
             else
               int momo = 0;

             dataLen = index;
             dataLen -= 3;  //header - zero index
             dataLen += 1; //pktid
             dataLen = (int)recvBuf[2] - dataLen;  //data len

             //------ Reading large data ---------------------------
             if (ReadTagLargeDataCheckBox->Checked)
             {
                 if (lastRPktID == pktID)
                    return;
                 else
                 {
                    lastRPktID = pktID;
                 }
                   //ReadMemoryStartAddrEdit->Text = IntToHex(startAddress + 12, 4);
                   numReadLargeData += dataLen;
                   AnsiString strg = "Bytes Read : ";
                   strg += numReadLargeData;
                   ReadTagReadLabel->Caption = strg;
                   if (numReadLargeData < MaxReadLargeData)
                   {
                        int addr = HexToInt(ReadMemoryStartAddrEdit->Text.c_str(), ReadMemoryStartAddrEdit->Text.Length());
                        addr += 16;
                        ReadMemoryStartAddrEdit->Text = IntToHex(addr, 4);
                   }
                   else
                   {
                       ReadLargDataTimer->Enabled = false;
                       displayElapsedTime = false;
                       StaticText->Caption = "Reading large data completed successfuly";
                   }
             }
             //-----------------------------------------------------


             AnsiString largeDataStr;
             for (int p=1, ct=0, i=1; ct<dataLen; p++, ct++)
             {
             //if (p%11 == 0)
             //{
               //i += 1;
               //p=1;
             //}

                //------ Writing large data ---------------------------
                if (goRead)
                {
                   largeDataLastReadBuf[p-1] = (unsigned char)recvBuf[index];
                }
                //-----------------------------------------------------

                //------ Reading large data ---------------------------
                if (ReadTagLargeDataCheckBox->Checked)
                {
                    largeDataReadBuf[p-1][readBufIndex] = (unsigned char)recvBuf[index];
                }

                if (ReadMemoryHexRadioButton->Checked)
                {
                   n = (unsigned char)recvBuf[index];
                   largeDataLastRead[ct] = n;
                   str = str.IntToHex(n, 2);
                   ReadMemoryStringGrid->Cells[p][i] = str;
                   if (DisplayDataCheckBox->Checked)
                   {
                      largeDataStr += str;
                      largeDataStr += "  ";
                   }
                }
                else if (ReadMemDecRadioButton->Checked)
                {
                   ReadMemoryStringGrid->Cells[p][i] = (unsigned int)((unsigned char)recvBuf[index]);
                   if (DisplayDataCheckBox->Checked)
                   {
                      largeDataStr += (unsigned int)((unsigned char)recvBuf[index]);
                      largeDataStr += "  ";
                   }
                }
                else
                {
                   ReadMemoryStringGrid->Cells[p][i] = (char)recvBuf[index];
                   if (DisplayDataCheckBox->Checked)
                   {
                      largeDataStr += (char)recvBuf[index];
                      largeDataStr += "  ";
                   }
                }

                index += 1;
             }//for loop

             if (ReadTagLargeDataCheckBox->Checked)
             {
                 readBufIndex += 1;
                 if ((largeDataDlg != NULL) && DisplayDataCheckBox->Checked)
                    largeDataDlg->DisplayReadBytes(largeDataStr, numReadLargeData, readBufIndex);
             }

             largeDataLastRead[12] = '\0';
             //large data
             if (goRead)
             {
             if (CheckValidWrite(12))
             {
                 //largDataWriteAck = true;
                 AnsiString str = "Bytes Written: ";

                 if (totByteWritten >= atoi(WriteMemoryNumByteEdit->Text.c_str()))
                 {
                     writeTagData = false;
                     //largDataWriteAck = true;
                     largeDataWriteRetry = false;
                     largeDataReadRetry = false;
                     RetryTimer->Enabled = false;
                     WriteTimer->Enabled = false;
                     ReadTimer->Enabled = false;
                     displayElapsedTime = false;

                     //totByteWritten += 12;
                     str += totByteWritten;
                     BytesWrittenLabel->Caption = str;
                     BytesWrittenLabel->Invalidate();
                     GeneralTimer->Enabled = false;
                     str = "Writing ";
                     str += WriteMemoryNumByteEdit->Text;
                     str += " bytes to the tag was successfully completed.";
                     StaticText->Caption = str;
                     return;
                 }

                 AnsiString addrStr = WriteMemoryStartAddrEdit->Text;
                 int addr = HexToInt(addrStr.c_str(), addrStr.Length());
                 addr += 16;
                 WriteMemoryStartAddrEdit->Text = IntToHex(addr, 4);
                 WriteMemoryStartAddrEdit->Invalidate();
                 largeDataWriteRetry = false;
                 largeDataReadRetry = false;
                 largeDataWriteRetryCt = 0;
                 largeDataReadRetryCt = 0;
                 WriteTimer->Enabled = true;
                 ////////////////RetryTimer->Enabled = false;
                 largeDataReadAck = true;
                 //WriteNumRetryLabel->Caption = "#W: 00";
                 //ReadNumRetryLabel->Caption = "#R: 00";
                 totByteWritten += 12;

                 str += totByteWritten;
                 BytesWrittenLabel->Caption = str;
                 BytesWrittenLabel->Invalidate();

                 StaticText->Caption = "Verified last write data OK. ";
                 WriteRS232Comm(RESET_DEVICE, 0, NULL, 0);

             }
             else   //not valid
             {
                 //largeDataReadAck = true;
                 if (largeDataWriteRetry <= 5)
                 {
                    largeDataWriteRetry = true;
                    ////////////RetryTimer->Enabled = true;
                    largeDataReadRetry = false;
                 }
                 else
                 {
                     writeTagData = false;
                     RetryTimer->Enabled = false;
                     ReadTimer->Enabled = false;
                     WriteTimer->Enabled = false;
                     GeneralTimer->Enabled = false;

                     Application->MessageBox("Write Large Data Failed",
                                             "Programming Station Information Dialog",
                                             MB_OK | MB_ICONSTOP | MB_TOPMOST );

                     StaticText->Caption = "Write Large Data to tag Failed";
                     return;
                 }
             }//else valid

             }//goRead

             //StaticText->Caption = "Read Memory Tag command was executed successfully.";

             //This is for large data
             //------------------------------------------------------------------------


             //------------------------------------------------------------------------

          } //memory read general

      /*unsigned char buf[4] = {'\0', '\0', '\0'};
      int j, count;
      int nBytes = atoi(WriteMemoryNumByteEdit->Text.c_str());
      for (i=1, j=1, count=0; count<nBytes; i++)    //01/13/04
      {
         if (j%12 == 0)
            j += 1;
         if (writeFormat == "CHAR")
         {
            strcpy(buf, WriteMemoryStringGrid->Cells[i][j].c_str());
            XBuf[index++] = buf[0];
         }
         else
            XBuf[index++] = atoi(WriteMemoryStringGrid->Cells[i][j].c_str());
         count += 1;
      }
       */
          /////////////////

          RxCommandLabel->Caption = "Read Tag Mem ACK";
          //str = RxTagTypeLabel->Caption;
          //str += " Tag ";
          //str += n;
          //str += " detected.";
          //if (RxTamperLabel->Caption == "Yes")
             //TamperSWMsg->Caption = "Tamper  Switch  Enabled !";
          //else
             //TamperSWMsg->Caption = "";
          //DetectedMsg->Caption = str;
       break;


   }//switch command

   delete fGenFlag;
   delete gIDFlag;
   delete dIndex;


   /*if (chinaDemoON)
   {
   EnableReaderBitBtn->Enabled = false;
   DisableReaderBitBtn->Enabled = false;
   QueryReaderBitBtn->Enabled = false;
   AssignReaderBitBtn->Enabled = false;
   EnableFGenBitBtn->Enabled = false;
   ConfigTagBitBtn->Enabled = false;
   EnableTagBitBtn->Enabled = false;
   DisableTagBitBtn->Enabled = false;
   QueryTagBitBtn->Enabled = false;
   CallTagBitBtn->Enabled = false;
   } */
}
//---------------------------------------------------------------------------

/*void __fastcall TProgStationForm::Timer1Timer(TObject *Sender)
{
   /*TDateTime DateTime = Time();  // store the current date and time
   timeStr = TimeToStr(DateTime); // convert the time to a string
   MainStatusBar->Panels->Items[2]->Text = comStatusStr.c_str();
   MainStatusBar->Panels->Items[3]->Text = timeStr.c_str();

   /*if (lastDownloadPkt)
   {
      lastDownloadPkt = false;

      if (bload_proc == 0)
          DownloadRdrProgressBarC->Position = numLines-1;
      else if (bload_proc == 1)
          DownloadRdrProgressBarD->Position = numLines-1;
      else if (bload_proc == 2)
          DownloadRdrProgressBarE->Position = numLines-1;

      if(networkOn)
      {
         int rdr = atoi(DownloadRdrReaderComboBox->Text.c_str());
         int index = GetSocketIndex(rdr);
         if (index >= 0)
         {
            WriteAWSocket(RESET_DEVICE, 0, NULL, 0, 'S', NULL, 0, index);
         }
         else
            StaticText->Caption = "No matching socket for the reader.";
      }
      else if (RS232On)
      {
         WriteRS232Comm(RESET_DEVICE, 0, NULL, 0);
      }
   }

   if (sendBootQuery && bootloading)
   {
      sendBootQuery = false;
      if(networkOn)
      {
         int rdr = atoi(DownloadRdrReaderComboBox->Text.c_str());
         int index = GetSocketIndex(rdr);
         if (index >= 0)
         {
            WriteAWSocket(BOOT_QUERY, 0, NULL, 0, 'S', NULL, 0, index);
         }
         else
            StaticText->Caption = "No matching socket for the reader.";
      }
      else if (RS232On)
      {
         WriteRS232Comm(BOOT_QUERY, 0, NULL, 0);
      }
   }
} */
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::Timer2Timer(TObject *Sender)
{
   //******* TEMP CHINA DEMO Renmove later
   /*if (closeChinaDemo)
   {
      closeChinaDemo = false;
      delete chinaDemoDlg;
   }*/

   TCanvas& c = *MainStatusBar->Canvas;
   Graphics::TBitmap *Bitmap = new Graphics::TBitmap();

   if (readerFgenButtonActivated)
   {
      if (fGenRedDisplay)
      {
         ReaderFgenToolButton->ImageIndex = 12;
         //FieldGenONWarningLabel->Visible = false;
         fGenRedDisplay = false;
      }
      else
      {
         ReaderFgenToolButton->ImageIndex = 13;
         //FieldGenONWarningLabel->Visible = true;
         fGenRedDisplay = true;
      }
   }
   else
   {
      ReaderFgenToolButton->ImageIndex = 12;
      //FieldGenONWarningLabel->Visible = false;
      ReaderFgenToolButton->Hint = "Set Programming Station To Field Generator Mode";
   }//readerFgenButtonActivated

   if (comPanelRect)
   {
       int left = 0;
       int top = 0;
       if (comPortOK || networkOn)
       {
           if (!startNetworkComm)
           {
              startNetworkComm = true;
              //justStartedUp = true;
              for (int i=0; i<MAX_DESCRIPTOR; i++)
                 justStartedUp[i] = true;
           }

           if (LEDon)
           {
              //Bitmap->LoadFromResourceName((int)HInstance, "COM_LED_OFF");
              if (readerOnLine || fieldGenOnLine)
                 Bitmap->LoadFromResourceName((int)HInstance, "COM_LED_READY");
              else
                 Bitmap->LoadFromResourceName((int)HInstance, "COM_LED_OFF");
              left = (comLEDRect.Width() - Bitmap->Width)/2;
              if (left < 0)
                 left = 0;
              top = (comLEDRect.Height() - Bitmap->Height)/2;
              if (top < 0)
                 top = 0;
              c.Draw(comLEDRect.Left+left, comLEDRect.Top+top, Bitmap);
              //c.Draw(comLEDRect.Left+3, comLEDRect.Top+2, Bitmap);
              LEDon = false;

              if (fieldGenOffLine && readerFgenButtonActivated)
              {
                 item1Str = "FieldGen Offline";
                 MainStatusBar->Panels->Items[1]->Text =  item1Str;
              }
              else if (fieldGenOnLine && readerFgenButtonActivated)
              {
                 item1Str = "FieldGen Online";
                 MainStatusBar->Panels->Items[1]->Text =  item1Str;
              }
              else if (networkOffline)
              {
                  readerOffLine = true;
                  readerOnLine = false;
                  fieldGenOffLine = true;
                  fieldGenOnLine = false;
                  comStatusStr = "No Network Connection";
                  item1Str = "Readers Offline";
                  MainStatusBar->Panels->Items[1]->Text = item1Str;
              }
              else if (IsReaderOffline()) //(readerOffLine)
              {
                 if (networkOn)
                 {
                    if (rdrWentOffline)
                    {
                       rdrWentOffline = false;
                       lastRdrOfflineIndex = 0;
                       item1Str = "Reader ";
                       item1Str += callingReaderID;
                       item1Str += " Offline";
                       MainStatusBar->Panels->Items[1]->Text =  item1Str;
                    }
                    else
                    {
                         item1Str = "Reader ";

                         if (lastRdrOfflineIndex >= listViewItemCount)
                             lastRdrOfflineIndex = 0;
                         for (int i=lastRdrOfflineIndex; i<listViewItemCount; i++, lastRdrOfflineIndex++)
                         {
                            //if((strcmp(listViewInfo[i].netStatus,"Active") == 0) &&
                            if (strcmp(listViewInfo[i].rdrStatus, "Offline") == 0)
                            {
                               item1Str += listViewInfo[i].reader;
                               item1Str += " ";
                               lastRdrOfflineIndex = i+1;
                               break;
                            }
                         } //for

                         item1Str += "Offline";
                         MainStatusBar->Panels->Items[1]->Text =  item1Str;

                         if (IsAllReaderOffline())
                         {
                            readerOffLine = true;
                            readerOnLine = false;
                            fieldGenOffLine = true;
                            fieldGenOnLine = false;
                            comStatusStr = "No Network Connection";
                         }

                     } //rdrWentOffline = false

                 }//networkon
                 else //networkon
                 {
                    //rs232
                    item1Str = "Reader Offline";
                    MainStatusBar->Panels->Items[1]->Text =  item1Str;
                 }

              } //IsReaderOffline
              else if (recording)
              {
                 item1Str = "Recording ...";
                 MainStatusBar->Panels->Items[1]->Text =  item1Str;

              }
              else if (readerOnLine)
              {
                 if (networkOn)
                    item1Str = "Reader(s) Online";
                 else
                    item1Str = "Reader Online";
                 MainStatusBar->Panels->Items[1]->Text =  item1Str;
              }
              else
              {
                 item1Str = "Reader Offline";
                 MainStatusBar->Panels->Items[1]->Text =  item1Str;
              }
              //else
              //{
                 //item1Str = " ";
                 //MainStatusBar->Panels->Items[1]->Text =  item1Str;
              //}

           }  //ledon
           else //ledon false
           {
              if (readerOnLine || fieldGenOnLine)
                 Bitmap->LoadFromResourceName((int)HInstance, "COM_LED_READY");
              else
                 Bitmap->LoadFromResourceName((int)HInstance, "READER_OFF_LINE");
              left = (comLEDRect.Width() - Bitmap->Width)/2;
              if (left < 0)
                 left = 0;
              top = (comLEDRect.Height() - Bitmap->Height)/2;
              if (top < 0)
                 top = 0;
              c.Draw(comLEDRect.Left+left, comLEDRect.Top+top, Bitmap);
              LEDon = true;
             if (recording || readerOffLine)
                 MainStatusBar->Panels->Items[1]->Text =  " ";
           }//ledon false
       }
       else  //(comPortOK || networkOn)  = false
       {
           if (LEDon)
           {
              Bitmap->LoadFromResourceName((int)HInstance, "COM_LED_OFF");
              left = (comLEDRect.Width() - Bitmap->Width)/2;
              if (left < 0)
                 left = 0;
              top = (comLEDRect.Height() - Bitmap->Height)/2;
              if (top < 0)
                 top = 0;
              c.Draw(comLEDRect.Left+left, comLEDRect.Top+top, Bitmap);
              LEDon = false;
           }
           else
           {
               Bitmap->LoadFromResourceName((int)HInstance, "COM_LED_NOT_READY");
               left = (comLEDRect.Width() - Bitmap->Width)/2;
              if (left < 0)
                 left = 0;
              top = (comLEDRect.Height() - Bitmap->Height)/2;
              if (top < 0)
                 top = 0;
              c.Draw(comLEDRect.Left+left, comLEDRect.Top+top, Bitmap);
               LEDon = true;
           }

       }  //(comPortOK || networkOn)  = false
   } //comPanelRect

   delete Bitmap;
}

//------------------------------------------------------------------------------
void __fastcall TProgStationForm::MainStatusBarDrawPanel(
      TStatusBar *StatusBar, TStatusPanel *Panel, const TRect &Rect)
{
    int l, h;
    TSize s;

    if (Panel->Index == 0)
    {
       MainStatusBar->Canvas->Font->Color = clBlack;
       MainStatusBar->Canvas->Font->Style = TFontStyles()<< fsBold;
       TSize s = MainStatusBar->Canvas->TextExtent(sysStr.c_str());
       l = (Rect.Width() - s.cx)/2;
       h = (Rect.Height() - s.cy)/2;
       MainStatusBar->Canvas->TextRect(Rect, Rect.Left+l, Rect.Top+h, sysStr.c_str());
    }
    else if (Panel->Index == 1)
    {
       if (networkOn)
       {
          if (IsReaderOffline() || networkOffline)
             MainStatusBar->Canvas->Font->Color = clYellow;
          else
             MainStatusBar->Canvas->Font->Color = clGreen;
       }
       else
       {
           if (readerOnLine || fieldGenOnLine)
              MainStatusBar->Canvas->Font->Color = clGreen; //clLime;
           else
              MainStatusBar->Canvas->Font->Color = clYellow;
       }

       MainStatusBar->Canvas->Font->Style = TFontStyles()<< fsBold;
       TSize s;

       if (readerOnLine || fieldGenOnLine)
          s = MainStatusBar->Canvas->TextExtent(item1Str.c_str());
       else
       {
          if (LEDon)
             s = MainStatusBar->Canvas->TextExtent(item1Str.c_str());
         else
             s = MainStatusBar->Canvas->TextExtent("  ");
       }

       l = (Rect.Width() - s.cx)/2;
       h = (Rect.Height() - s.cy)/2;
       MainStatusBar->Canvas->TextRect(Rect, Rect.Left+l, Rect.Top+h, item1Str.c_str());
    }
    else if (Panel->Index == 2)
    {
       if ((RS232On || networkOn) && !networkOffline)
          MainStatusBar->Canvas->Font->Color = clGreen;
       else if (networkOn && networkOffline)
          MainStatusBar->Canvas->Font->Color = clYellow;
       else
          MainStatusBar->Canvas->Font->Color = clRed;
       MainStatusBar->Canvas->Font->Style = TFontStyles()<< fsBold;
       if (RS232On)
       {
          TSize s = MainStatusBar->Canvas->TextExtent(comStatusStr.c_str());
          l = (Rect.Width() - s.cx)/2;
          h = (Rect.Height() - s.cy)/2;
          MainStatusBar->Canvas->TextRect(Rect, Rect.Left+l, Rect.Top+h, comStatusStr.c_str());
       }
       else //if (networkOn)
       {
          TSize s = MainStatusBar->Canvas->TextExtent(comStatusStr.c_str());
          l = (Rect.Width() - s.cx)/2;
          h = (Rect.Height() - s.cy)/2;
          MainStatusBar->Canvas->TextRect(Rect, Rect.Left+l, Rect.Top+h, comStatusStr.c_str());
       }
    }
    else if (Panel->Index == 3)
    {
       MainStatusBar->Canvas->Font->Color = clBlue;
       MainStatusBar->Canvas->Font->Style = TFontStyles()<< fsBold;
       TSize s = MainStatusBar->Canvas->TextExtent(timeStr.c_str());
       l = (Rect.Width() - s.cx)/2;
       h = (Rect.Height() - s.cy)/2;
       MainStatusBar->Canvas->TextRect(Rect, Rect.Left+l, Rect.Top+h, timeStr.c_str());
    }
    else if (Panel->Index == 4)
    {
       MainStatusBar->Canvas->Font->Color = clBlue;
       MainStatusBar->Canvas->Font->Style = TFontStyles()<< fsBold;
       TSize s = MainStatusBar->Canvas->TextExtent(version.c_str());
       l = (Rect.Width() - s.cx)/2;
       h = (Rect.Height() - s.cy)/2;
       MainStatusBar->Canvas->TextRect(Rect, Rect.Left+l, Rect.Top+h, version.c_str());
    }
    else if (Panel->Index == 5)
    {
       MainStatusBar->Canvas->Font->Color = clPurple;
       MainStatusBar->Canvas->Font->Style = TFontStyles()<< fsBold;
       TSize s = MainStatusBar->Canvas->TextExtent(hostIDStr.c_str());
       l = (Rect.Width() - s.cx)/2;
       h = (Rect.Height() - s.cy)/2;
       MainStatusBar->Canvas->TextRect(Rect, Rect.Left+l, Rect.Top+h, hostIDStr.c_str());
    }
    else if (Panel->Index == 6)
    {
      comLEDRect = Rect;
      comPanelRect = true;
    }
}
//------------------------------------------------------------------------------
AnsiString __fastcall TProgStationForm::BuildRecPktString(char* buf, int len, bool frameFlag, bool crcFlag)
{
   AnsiString str;
   char hByte[1];
   char tbuf[10];
   int length = len;  //temp fix - len keeps changing

   //-----------Debug Window

   lineCounter++;
   txRxCounter++;
   itoa(lineCounter, tbuf, 10);
   str = tbuf;
   str += " - R ";
   buf[len+1] = '\0';
   int data;

   for (int i=0; i<length; i++)
   {
      str += IntToHex(((int)(unsigned char)buf[i]), 2);
      str += ' ';
   }

   if (frameFlag)
      str += "  fEr";

   if (crcFlag)
      str += "  CRCEr";

   while(str.Length() < 100)
      str += ".";
   TDateTime DateTime = Time();  // store the current date and time
   str += TimeToStr(DateTime);
   str += " ";
   DateTime = Date();
   str += DateToStr(DateTime);

   return (str);
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::DisplayRecPackets(char buf[260], int len, bool frameFlag, bool crcFlag, AnsiString ip)
{

   //---------------Normal Window
   if (((unsigned char)buf[1]) != 0xFF)
      RxClearTagCtrls();

   int index = 45;

   /*if (!StopRX)
   {
      recDisplayStr = BuildRecPktString(buf, len);
      RecListBox->Items->Insert(0, recDisplayStr);
   }*/

   //-----------Debug Window
   AnsiString str;
   char hByte[1];
   char tbuf[10];
   int length = len;  //temp fix - len keeps changing

   //RecCounter++;
   if (!StopRX)
   {
      itoa(pktCounter, tbuf, 10);

      /*if (pktCounter > 99)
        index = 39;
      else if (pktCounter > 999)
        index = 38;
      else if (pktCounter > 9999)
        index = 39;
      else if (pktCounter > 99999)
        index = 38;*/

      if (pktCounter < 10)
      {
        str = "0";
        str += tbuf;
      }
      else
        str = tbuf;
      str += " - ";
      buf[len+1] = '\0';
      int data;

      if (frameFlag)
        str += "fEr ";

      if (crcFlag)
        str += "crcEr ";

      for (int i=0; i<length; i++)
      {
         if (HexFormat)
            str += IntToHex(((int)(unsigned char)buf[i]), 2);
         else
            str += (unsigned char)buf[i];
         str += ' ';
      }

      #ifdef _SOCKET_DBG
         if (ip != NULL)
         {
            str += "   ";
            str += ip;
         }
      #endif

       //int index = 38;
       if (str.Length() > index)
       {
          AnsiString str1;
          str1 = str.SubString(index, str.Length()+1 - index);

          //if (*(char *)str1.data() != ' ')
          /*if (str1.data() != NULL)
          {
            index += 1;
            str1 = str.SubString(index, str.Length() - index);
          }

          //if (*(char *)str1.data() != ' ')
          if (str1.data() != NULL)
          {
            index += 1;
            str1 = str.SubString(index, str.Length() - index);
          }

          //if (*(char *)str1.data() != ' ')
          if (str1.data() != NULL)
          {
            index += 1;
            str1 = str.SubString(index, str.Length() - index);
          } */

          str1 = "     " + str1;
          RecListBox->Items->Insert(0, str1);
          str1 = str.SubString(1, index-1);
          RecListBox->Items->Insert(0, str1);
       }
       else
       {
          RecListBox->Items->Insert(0, str);
           str.SetLength(0);
       }
      //RecListBox->Items->Insert(0, str);
      //str.SetLength(0);
   }

   //if (multiDisplayTagDetect)
      //Beep();
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::DisplayDumpedPackets(char buf[1002], int len)
{

   //---------------Normal Window
   if (((unsigned char)buf[1]) != 0xFF)
      RxClearTagCtrls();

   int index = 42;

   //-----------Debug Window
   AnsiString str;
   char hByte[1];
   char tbuf[10];
   int length = len;  //temp fix - len keeps changing

   //RecCounter++;
   if (!StopRX)
   {
      itoa(pktCounter, tbuf, 10);
      if (pktCounter < 10)
      {
        str = "0";
        str += tbuf;
      }
      else
        str = tbuf;
      str += " - ";
      buf[len+1] = '\0';
      int data;

      for (int i=0; i<length; i++)
      {
         if (HexFormat)
            str += IntToHex(((int)(unsigned char)buf[i]), 2);
         else
            str += (unsigned char)buf[i];
         str += ' ';
      }

      AnsiString str1;
      while (str.Length() > index)
      {
          str1 = str.SubString(1, index);
          str = str.SubString(1, str.Length() - index);
          RecListBox->Items->Insert(0, str1);
      }
   }
}
//------------------------------------------------------------------------------

bool __fastcall TProgStationForm::CheckValidWrite(int len)
{
    for (int i=0; i<len; i++)
    {
       if (largeDataLastRead[i] != largeDataLastSent[i])
          return (false);
    }

    return (true);
}
//------------------------------------------------------------------------------

AnsiString __fastcall TProgStationForm::BuildTxRecordPktStr(char* buf, int len)
{
   AnsiString str;
   char hByte[1];
   char tbuf[10];
   int length = len;  //temp fix - len keeps changing

   lineCounter++;
   txRxCounter++;
   itoa(lineCounter, tbuf, 10);
   str = tbuf;
   str += " - H ";

   buf[len+1] = '\0';
   int data;

   for (int i=0; i<length; i++)
   {
      str += IntToHex(((int)(unsigned char)buf[i]), 2);
      str += ' ';
   }

   while(str.Length() < 100)
      str += ".";
   TDateTime DateTime = Time();  // store the current date and time
   str += TimeToStr(DateTime);
   str += " ";
   DateTime = Date();
   str += DateToStr(DateTime);

   return (str);
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::DisplayTransmitPackets(char buf[64], int len, AnsiString ip)
{
   AnsiString str;
   char hByte[1];
   char tbuf[10];
   int length = len;  //temp fix - len keeps changing
   int index = 45;

   //TxCounter++;
   if (!StopTX)
   {
      itoa(pktCounter, tbuf, 10);

      /*if (pktCounter > 99)
        index = 39;
      else if (pktCounter > 999)
        index = 38;
      else if (pktCounter > 9999)
        index = 39;
      else if (pktCounter > 99999)
        index = 38;*/

      if (pktCounter < 10)
      {
        str = "0";
        str += tbuf;
      }
      else
        str = tbuf;
      str += " - ";

      buf[len+1] = '\0';
      int data;

      for (int i=0; i<length; i++)
      {
          if (HexFormat)
             str += IntToHex(((int)(unsigned char)buf[i]), 2);
          else
             str += (unsigned char)buf[i];
           str += ' ';
       }

       #ifdef _SOCKET_DBG
          if (ip != NULL)
          {
            str += "   ";
            str += ip;
          }
       #endif

       //int index = 40;
       if (str.Length() > index)
       {
          AnsiString str1;
          str1 = str.SubString(index, str.Length()+1 - index);



          //if (*(char *)str1.data() != ' ')
          /*if (str1.data() != NULL)
          {
            index += 1;
            str1 = str.SubString(index, str.Length() - index);
          }

          //if (*(char *)str1.data() != ' ')
          if (str1.data() != NULL)
          {
            index += 1;
            str1 = str.SubString(index, str.Length() - index);
          }

          //if (*(char *)str1.data() != ' ')
          if (str1.data() != NULL)
          {
            index += 1;
            str1 = str.SubString(index, str.Length() - index);
          } */

          str1 = "     " + str1;
          TxListBox->Items->Insert(0, str1);
          str1 = str.SubString(1, index-1);
          TxListBox->Items->Insert(0, str1);
       }
       else
       {
          TxListBox->Items->Insert(0, str);
           str.SetLength(0);
       }
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::FormActivate(TObject *Sender)
{
   Activated = true;
   modifyComm = false;
   ProgammingMode = false;
   StaticText->Caption = "";
   TamperSWMsg->Caption = "";
   DetectedMsg->Caption = "";
   TXNormalDisplayGroup->Visible = true;
   RXNormalDisplayGroup->Visible = true;
   TxListBox->Visible = false;
   RecListBox->Visible = false;
   //justStartedUp = false;

   if (RS232On || networkOn)
      WriteRS232Comm(RESET_DEVICE, 0, NULL, 0);

   if (DebugDisplayToolButton->Visible || TextDisplayToolButton->Visible)
      AssignReaderTXComboBox->Items->Insert(0, "Forever");
   //Temp Testing--------------------------------------------
   /*displayRx = true;
   TXNormalDisplayGroup->Visible = false;
   RXNormalDisplayGroup->Visible = false;

   TextDisplayToolButton->Visible = true;
   DebugDisplayToolButton->Visible = false;

   TxListBox->Visible = true;
   RecListBox->Visible = true;

   StopGoTXBitBtn->Visible = true;
   StopGoRXBitBtn->Visible = true;
   RecClear->Visible = true;
   TxClear->Visible = true;
   HexRadioButton->Checked = true;
   DecRadioButton->Enabled = true;
   HexRadioButton->Enabled = true;*/
   //--------------------------------------------

   //////////////////REMOVE////////////////////////////////
   /*TXNormalDisplayGroup->Visible = false;
   RXNormalDisplayGroup->Visible = false;

   TextDisplayToolButton->Visible = true;
   DebugDisplayToolButton->Visible = false;

   TxListBox->Visible = true;
   RecListBox->Visible = true;

   StopGoTXBitBtn->Visible = true;
   StopGoRXBitBtn->Visible = true;
   RecClear->Visible = true;
   TxClear->Visible = true;
   HexRadioButton->Checked = true;
   DecRadioButton->Enabled = true;
   HexRadioButton->Enabled = true;*/


    //////////REMOVE///////////////REMOVE//////07/02/04
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::RecClearClick(TObject *Sender)
{
   RecListBox->Clear();
   index = 0;
   //RecCounter = 0;
   pktCounter = 0;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::TxClearClick(TObject *Sender)
{
   TxListBox->Clear();
   pktCounter = 0;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ClosePort()
{
   if (PortOpen)
   {
      PortOpen = false;
      PurgeComm (comPortID, PURGE_TXCLEAR | PURGE_RXCLEAR );
      if (overlapRead.hEvent)
         CloseHandle(overlapRead.hEvent);
      if (overlapWrite.hEvent)
         CloseHandle(overlapWrite.hEvent);
      TerminateThread(hCommWatchThread, 0);
      SetCommState(comPortID, &oldDCBStruct );	  // restore old settings
      SetCommTimeouts(comPortID, &oldTimeouts );   // restore comm timeouts
      CloseHandle(comPortID);
      comPortOK = false;
      comStatusStr.SetLength(0);
      overlapRead.hEvent = 0x0;
      overlapWrite.hEvent = 0x0;

      //Timer1->Enabled = false;
      //Timer2->Enabled = false;

      //Registry-----------------------------
      AnsiString ComStr;
      AnsiString BaudStr;
      if (ReaderIDComboBox->Text.data() != NULL)
         lastReaderID = atoi(ReaderIDComboBox->Text.c_str());
      //if (HostIDEdit->Text.data() != NULL)
         //lastHostID = atoi(HostIDEdit->Text.c_str());
      TRegistry* Reg = new TRegistry;
      Reg->RootKey = HKEY_CURRENT_USER;
      bool b1;
      if (Reg->KeyExists("Software"))
      {
         Reg->OpenKey("Software", false);
         if (!Reg->KeyExists("Active Wave"))
            Reg->CreateKey("Active Wave");

         Reg->OpenKey("Active Wave", false);

         if (!Reg->KeyExists("Programming Station"))
            Reg->CreateKey("Programming Station");

         Reg->OpenKey("Programming Station", false);
         Reg->WriteInteger("Com", comPort);
         Reg->WriteInteger("Baud", lastBaudrate);
         Reg->WriteInteger("Reader", lastReaderID);
         Reg->WriteInteger("Host", sysHostID);
         Reg->WriteString("CommType", "RS232");
         Reg->WriteFloat("TagTempCalibC", tagTempCalibC);
      }
      delete Reg;
      //-----------------------------

      RS232On = false;

   }//if port open

}
//--------------------------------------------------------------------------
void __fastcall TProgStationForm::FormClose(TObject *Sender,
      TCloseAction &Action)
{
    //if(networkOn)
       //CloseNetworkConnection(openSock);
    PollTimer->Enabled = false;
    if(networkOn)
       CloseNetworkConnection();

     if(RS232On)
        ClosePort();

     //ClosePort();
     if (fileHandle != NULL)
     {
        fclose(fileHandle);
        fileHandle = NULL;
     }

     //free(networkInfo);
     delete[] listViewInfo;
     //free (sockConnectQue);
     //for (int i=0; i<MAX_DESCRIPTOR; i++)
       //delete AWSockets[i];
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::FormDestroy(TObject *Sender)
{
    ClosePort();
}
//---------------------------------------------------------------------------
bool __fastcall TProgStationForm::WriteRS232Comm(unsigned int Command, int Len, unsigned char* buf, unsigned int pktID)
{
   txCommand = Command;
   txLen = Len;
   //if (buf == NULL)
      //txBuf = NULL;
   //else
      //txBuf[0] = *buf;

   DWORD BytesSend;
   DWORD dwRes;
   int totalLen;
   int reader = 0;

   LastCommand = Command;

   if ((totalLen = BuildPacket(Command, Len, buf, pktID, &reader)) <= 0)
      return (false);

   if (RS232On)
   {
      if (Command != 0x30)   //powerup
         BootloadTimer->Enabled = true;  //reader offline
      pktLenToTransmit = totalLen;
      pktCommandToTransmit = Command;
      txWriteThread->Resume();
   }

   /*else if (networkOn)
   {
      if (WriteSocket(openSock, XBuf, totalLen, (struct sockaddr_in *)&peer) < totalLen)
      {
         //socket write error
         return(0);
      }

      lastLenBytesSent = totalLen;

      sysStr = "Transmit OK";
      MainStatusBar->Panels->Items[0]->Text =  "Transmit OK";

      if (displayTx)
      {
         pktCounter++;
         DisplayTransmitPackets(XBuf, totalLen);
       }

       if ((fileHandle != NULL) && recording)
       {
         txDebugStr = BuildTxRecordPktStr(XBuf, totalLen);
         txDebugStr += "\n";
         fwrite(txDebugStr.c_str(), txDebugStr.Length(), 1, fileHandle);
       }
   }


   /*
   //SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);
   if (RS232On)
   {
      SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);
   //Len += 4;  //Plus 2 bytes for CRC + 2 (herder + totalLen)
   for (int i=0; i<TotalLen; i++)
   {
      //if (!WriteFile(comPortID, &XBuf[0], TotalLen, &BytesSend, &overlapWrite))
      if (!WriteFile(comPortID, &XBuf[i], 1, &BytesSend, &overlapWrite))
      {
          if (GetLastError() != ERROR_IO_PENDING)
          {
              SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
              //WriteComm(LAST_COMMAND, XBufLast[0], NULL);
              return (0);
          }
          else
          {
              dwRes = WaitForSingleObject(overlapWrite.hEvent, WRITE_TIMEOUT);
              switch (dwRes)
              {
                  case WAIT_OBJECT_0:
                      if(!GetOverlappedResult(comPortID, &overlapWrite, &BytesSend, TRUE))
                      {
                         SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
                         //WriteComm(LAST_COMMAND, XBufLast[0], NULL);
                         return (0);
                      }
                  break;

                  default:
                  break;

              }//switch
          }
      }
   }//for loop
      SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
   }
   else  //socket
   {
       if (WriteSocket(openSock, XBuf, TotalLen, (struct sockaddr_in *)&peer) < TotalLen)
       {
          //socket write error
          return(0);
       }


   }

   //SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
   lastLenBytesSent = TotalLen;

   sysStr = "Transmit OK";
   MainStatusBar->Panels->Items[0]->Text =  "Transmit OK";

   if (displayTx && (((Command != POWER_UP) && (Command != TAG_DETECTED) && (Command != 0x11)) || readerFgenButtonActivated || networkOn))
   {
      pktCounter++;
      DisplayTransmitPackets(XBuf, TotalLen);
   }

   if ((fileHandle != NULL) && recording)
   {
      txDebugStr = BuildTxRecordPktStr(XBuf, TotalLen);
      txDebugStr += "\n";
      fwrite(txDebugStr.c_str(), txDebugStr.Length(), 1, fileHandle);
   }

   //Beep();

   return (true);
   */

   return (true);
}
//---------------------------------------------------------------------------
 bool __fastcall TProgStationForm::CheckCRC(unsigned int PktLen, Byte* buf)
{
   if (PktLen > 2)
   {
      crc = 0xFFFF;
      for (int i=0; i<(int)PktLen-2; i++)
         Generate_CRC(buf[i]);
      Byte c0 = (Byte)(crc & 0x00FF) ^ 0xFF;  //LSB
      Byte c1 = (Byte)((crc >> 8) & 0x00FF) ^ 0xFF;  //MSB
      if ((buf[PktLen-1] == c1) && (buf[PktLen-2] == c0))
         return(true);
   }
   return (false);
}
/*//------------------------------------------------------------------------------
void __fastcall TProgStationForm::Generate_CRC(char c)
{
   //testing -------------------------------------------------------------
   RecListBox->Items->Insert(0, "Starting crc --------------");
   char buf[10] = {'\0', '\0','\0', '\0','\0', '\0','\0', '\0','\0', '\0'};
   AnsiString str;
   //----------------------------------------------------------------------
   unsigned char d, e, f, g, h;
   d = 0;

   e = (Byte)(crc & 0x00FF) ^ c;
   itoa(e, buf, 10);
   str = "e = ";
   str += buf;
   RecListBox->Items->Insert(0, str);

   for(h=0; h<8; h++)   //for all 8 bits
   {
      g = d & 0x01;
      itoa(g, buf, 10);
      str = "g = ";
      str += buf;
      RecListBox->Items->Insert(0, str);

      d >>= 1;
      itoa(d, buf, 10);
      str = "d = ";
      str += buf;
      RecListBox->Items->Insert(0, str);

      d &= 0x7F;
      itoa(d, buf, 10);
      str = "d = ";
      str += buf;
      RecListBox->Items->Insert(0, str);

      f = e & 0x01;
      itoa(f, buf, 10);
      str = "f = ";
      str += buf;
      RecListBox->Items->Insert(0, str);

      e >>= 1;
      itoa(e, buf, 10);
      str = "e = ";
      str += buf;
      RecListBox->Items->Insert(0, str);

      e &= 0x7F;
      itoa(e, buf, 10);
      str = "e = ";
      str += buf;
      RecListBox->Items->Insert(0, str);

      if (g)
      {
         e |= 0x80;
         itoa(e, buf, 10);
         str = "e = ";
         str += buf;
         RecListBox->Items->Insert(0, str);
      }
      else
         RecListBox->Items->Insert(0, " No g");


      if (f)
      {
         d ^= 0x84;
         itoa(d, buf, 10);
         str = "d = ";
         str += buf;
         RecListBox->Items->Insert(0, str);

         e ^= 0x08;
         itoa(d, buf, 10);
         str = "d = ";
         str += buf;
         RecListBox->Items->Insert(0, str);

      } //end if carry out of e
      else
         RecListBox->Items->Insert(0, " No f");

   }// end for

   itoa(crc, buf, 10);
   str = "crc = ";
   str += buf;
   RecListBox->Items->Insert(0, str);

   e ^= (Byte)((crc >> 8) & 0x00FF);  //new crc lo
   itoa(e, buf, 10);
   str = "e = ";
   str += buf;
   RecListBox->Items->Insert(0, str);

   crc = (int)(( d << 8) & 0xFF00) + (int)e;

   //Testing -----------------------------------------------------------------
   str = "c = ";
   str += IntToHex(((int)(unsigned char)c), 2);
   str += "   crc = ";
   itoa(crc, buf, 10);
   str += buf;
   str += "    ";
   str += IntToHex(crc, 8);
   RecListBox->Items->Insert(0, str);
   RecListBox->Items->Insert(0, "Ending crc --------------");
   //-------------------------------------------------------------------------
}
*/
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::Generate_CRC(char c)
{
   unsigned char d, e, f, g, h;
   d = 0;
   e = (Byte)(crc & 0x00FF) ^ c;
   for(h=0; h<8; h++)   //for all 8 bits
   {
      g = d & 0x01;
      d >>= 1;
      d &= 0x7F;
      f = e & 0x01;
      e >>= 1;
      e &= 0x7F;
      if (g) e |= 0x80;
      if (f)
      {
         d ^= 0x84;
         e ^= 0x08;
      } //end if carry out of e
   }// end for
   e ^= (Byte)((crc >> 8) & 0x00FF);  //new crc lo
   crc = (int)(( d << 8) & 0xFF00) + (int)e;

}
//------------------------------------------------------------------------------
int __fastcall TProgStationForm::nBitTwosComplement(int data, int numBits)
{
   int result = - (data & (1 << numBits - 1));
   for(int i = numBits - 2; i >= 0; i--)
       result |= (data & (1 << i));
   return result;
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::doTagID(__int64 n, int *index)
{
   AnsiString s = IntToHex(n, 8);
   *index += 1;
   XBuf[*index] = HexToInt(s.c_str(), 2);
   if (CarRadioButton->Checked)
      XBuf[*index] |= 0x80;  //set msb to high for car type
   *index += 1;
   AnsiString s1 = s.SubString(3,2);
   XBuf[*index] = HexToInt(s1.c_str(), 2);
   *index += 1;
   s1 = s.SubString(5,2);
   XBuf[*index] = HexToInt(s1.c_str(), 2);
   s1 = s.SubString(7,2);
   *index += 1;
   XBuf[*index] = HexToInt(s1.c_str(), 2);
}
//------------------------------------------------------------------------------
int __fastcall TProgStationForm::BuildPacket(unsigned int Command, unsigned int Len, unsigned char* buf, unsigned int pktID, int* reader)
{
   int index=0, i;
   int initLen = 0;
   int rdrID;
   bool extended;
   char tgID[4];
   AnsiString str;
   AnsiString idStr;
   bool readerInit = false;
   Word Hour=0, Min=0, Sec=0, MSec=0;
   TDateTime time;
   char configByte = '\0';
   unsigned short hostID;

   /*if (Command == LAST_COMMAND)
   {
      for (i=0; i<Len; i++)
         XBuf[i] = XBufLast[i];
   }*/

   //TxTypeLabel->Caption = "Tag Type: ";
   //TxIDLabel->Caption = "Tag ID: ";
   //TxTagTypeLabel->Left = TxTypeLabel->Left + TxTypeLabel->Width + 2;
   //TxTagIDLabel->Left = TxIDLabel->Left + TxIDLabel->Width + 2;

   unsigned int nID = (unsigned int)NewTagID[0]*pow(2,24)+(unsigned int)NewTagID[1]*pow(2,16)+
                      (unsigned int)NewTagID[2]*pow(2, 8)+(unsigned int)NewTagID[3];


   unsigned int nTime = (unsigned int)TimePeriod[0]*pow(2, 8)+(unsigned int)TimePeriod[1];
   nTime = ceil (nTime * 0.018);

   FieldGenIDLabel01->Visible = false;
   FieldGenIDLabel->Visible = false;
   Label5->Caption = "ResendTime:";
   Label1->Caption = "TIF Time:";

   if (Command == RESET_DEVICE)
   {
      if (ResetHostIDEdit->Text.data() == NULL)
      {
         ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Need Host ID!",
         ( LPCSTR )"Programming Station Information Dialog",
         MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
         ResetDeviceBitBtn->Enabled = true;
         return (0);
      }
      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0x01;           //command
      if (ResetReaderIDComboBox->Text.data() == NULL)
      {
         if (ResetBroadcastReaderCheckBox->State == cbChecked)
            rdrID = 0;
         else if (buf != NULL)
         {
            if (buf[0] == 'G')
               rdrID = 0;
            else
               return(0);
         }
         else
         {
            Application->MessageBox("Error: Need Reader ID!",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST);
            ResetDeviceBitBtn->Enabled = true;
            return (0);
         }
      }
      else if (ResetBroadcastReaderCheckBox->State == cbChecked)
      {
         rdrID = 0;
      }
      else
      {
         if (buf == NULL)
            rdrID = (unsigned int)atoi(ResetReaderIDComboBox->Text.c_str());
         else if (buf[0] == 'G')
            rdrID = 0;
         else
            return(0);
      }
         //if ((rdrID == 0) && (!msgDisplayed))  //global reader

      *reader = rdrID;   //reader for socket

         /*if (rdrID == 0)  //global reader
         {
            XBuf[2] = 0x04;   //Len
            XBuf[3] = 0x0A;   //00 001 010
            XBuf[4] = atoi(ResetHostIDEdit->Text.c_str());   //host ID
            XBuf[5] = 0x00;
            XBuf[6] = 0x01;  //pktid
            index = 7;
         }*/
         if (rdrID <= 255)  //reg reader
         {
            XBuf[2] = 0x04;   //Len
            XBuf[3] = 0x0A;   //00 001 010
            XBuf[4] = atoi(ResetHostIDEdit->Text.c_str());   //host ID
            XBuf[5] = rdrID;  //reader ID
            XBuf[6] = 0x01;  //pktid
            index = 7;
         }
         else    //extended
         {
            XBuf[2] = 0x05;   //Len
            XBuf[3] = 0x0E;   //00 001 110
            XBuf[4] = atoi(ResetHostIDEdit->Text.c_str());  //host ID
            AnsiString str = IntToHex(rdrID, 4);
            XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
            str = str.SubString(3,2);
            XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
            XBuf[7] = 0x01;  //pktid
            index = 8;
         }
      //}


      if (ResetReaderIDComboBox->Text.data() != NULL)
         TxReaderIDLabel->Caption = ResetReaderIDComboBox->Text;
      else
         TxReaderIDLabel->Caption = "";

      //if (!MultiTagType)  //$$$ this is a temp fix - remove later  06/14/02

      if (rdrID == 0)
         TxCommandLabel->Caption = "Reset All Readers";
      else
         TxCommandLabel->Caption = "Reset Reader";

      time = Time();
      DecodeTime(time, Hour, Min, Sec, MSec);
      sendTime = Hour*60*60*1000 + Min*60*1000 + Sec*1000;
      waitingForRespone = true;
      waitResetRdrACK = true;
   }
   if (Command == BOOT_QUERY)   //0x6F
   {
      if (DownloadRdrHostEdit->Text.data() == NULL)
      {
         ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Need Host ID!",
         ( LPCSTR )"Programming Station Information Dialog",
         MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
         return (0);
      }
      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = BOOT_QUERY;     //command
      if (DownloadRdrReaderComboBox->Text.data() == NULL)
      {
            Application->MessageBox("Error: Need Reader ID!",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST);
            return (0);
      }

      rdrID = (unsigned int)atoi(DownloadRdrReaderComboBox->Text.c_str());

      if (rdrID <= 255)  //reg reader
      {
            XBuf[2] = 0x04;   //Len
            XBuf[3] = 0x0A;   //00 001 010
            XBuf[4] = atoi(DownloadRdrHostEdit->Text.c_str());   //host ID
            XBuf[5] = rdrID;  //reader ID
            XBuf[6] = 0x8B;  //pktid
            index = 7;
      }
      else    //extended
      {
            XBuf[2] = 0x05;   //Len
            XBuf[3] = 0x0E;   //00 001 110
            XBuf[4] = atoi(DownloadRdrHostEdit->Text.c_str());  //host ID
            AnsiString str = IntToHex(rdrID, 4);
            XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
            str = str.SubString(3,2);
            XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
            XBuf[7] = 0x8B;  //pktid
            index = 8;
      }

      if (DownloadRdrReaderComboBox->Text.data() != NULL)
         TxReaderIDLabel->Caption = DownloadRdrReaderComboBox->Text;
      else
         TxReaderIDLabel->Caption = "";

      TxCommandLabel->Caption = "Boot Query";
   }
   else if (Command == READ_CONFIG_TAG_MEMORY) //0x50
   {
      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0x0C;           //command

      if (ConfigTagHostIDEdit->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Host ID",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         ConfigTagGetConfigBitBtn->Enabled = true;
         return (0);
      }

      rdrID = atoi(ConfigTagReaderIDComboBox->Text.c_str());

      if (rdrID <= 255)  //reg reader
      {
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(ConfigTagHostIDEdit->Text.c_str());   //host ID
         XBuf[5] = rdrID;  //reader ID
         index = 6;
      }
      else    //extended
      {
         XBuf[3] = 0x0E;   //00 001 110
         XBuf[4] = atoi(ConfigTagHostIDEdit->Text.c_str());   //host ID
         AnsiString str = IntToHex(rdrID, 4);
         XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
         str = str.SubString(3,2);
         XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
         index = 7;
      }

      /*if (ConfigTagAnyTagRadioButton->Checked &&
          !ConfigTagAnyTagIDRadioButton->Checked)
         XBuf[index] = 0x40;  //specific tag type
      else if (!ConfigTagAnyTagRadioButton->Checked &&
               !ConfigTagAnyTagIDRadioButton->Checked)
         XBuf[index] = 0x80;  //specific tag type, specific tag id
      else if (ConfigTagAnyTagRadioButton->Checked &&
               ConfigTagAnyTagIDRadioButton->Checked)
         XBuf[index] = 0x00;  //any tag type, any tag id
      else
         return (0); */

      //CMD + starting address
      if ((ConfigTagTypeComboBox->Text != "All Tags") &&   //specific type
           ConfigTagAnyTagIDRadioButton->Checked)  //any id
         XBuf[index] = 0x40;  //specific tag type
      else if ((ConfigTagTypeComboBox->Text != "All Tags") &&   //specific type
               !ConfigTagAnyTagIDRadioButton->Checked)   //specific id
         XBuf[index] = 0x80;  //specific tag type, specific tag id
      else if ((ConfigTagTypeComboBox->Text == "All Tags") &&  //any type
               ConfigTagAnyTagIDRadioButton->Checked)  //any id
         XBuf[index] = 0x00;  //any tag type, any tag id
      else
      {
         Application->MessageBox("Need Tag Type!",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return (0);
      }

      index += 1;

      XBuf[index] = 0x81;  //starting address
      index += 1;

     //if (ConfigTagAnyTagRadioButton->Checked == cbUnchecked)

     if (ConfigTagTypeComboBox->Text != "All Tags")
     {
          if (!CheckVaildTagType(ConfigTagTypeComboBox->Text))
          {
               Application->MessageBox("Error: Invalid Tag Type (Not defined)",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
               ConfigTagBitBtn->Enabled = true;
               return (0);
          }

          int tagTypeVal = 0;

          //if ((tagTypeVal=GetTagTypeValue(ConfigTagTypeComboBox->ItemIndex)) < 0)
          if ((tagTypeVal=GetIndexTagType(ConfigTagTypeComboBox->Text)) < 0)
          {
              Application->MessageBox("Error in calculating tag type index",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
              ConfigTagBitBtn->Enabled = true;
              return (0);
          }

         /*if (ConfigTagAccessCtrlRadioButton->Checked)
           XBuf[index] = 0x20;  //001 0 0000
         else if (ConfigTagInvetRadioButton->Checked)
           XBuf[index] = 0x40;  //010 0 0000
         else if (ConfigTagAssetCtrlRadioButton->Checked)
           XBuf[index] = 0x60;  //011 0 0000*/

         //XBuf[index] = (tagTypeVal << 4);  //tagtype
         tagTypeVal += 1;
         XBuf[index] = (tagTypeVal << 5);


         if (ConfigTagRNLongRadioButton->Checked)
            XBuf[index] |= 0x01;  //long

         index += 1;
      }

      if (ConfigTagAnyTagIDRadioButton->Checked == cbUnchecked)
      {
         __int64  n = ((unsigned long)atol(ConfigTagTagIDEdit->Text.c_str()));
         AnsiString s = IntToHex(n, 8);
         XBuf[index] = HexToInt(s.c_str(), 2);
         index += 1;
         AnsiString s1 = s.SubString(3,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
         s1 = s.SubString(5,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         s1 = s.SubString(7,2);
         index += 1;
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
      }

      XBuf[index] = 0x08;  //bytes to read
      index += 1;

      XBuf[index] = READ_CONFIG_TAG_MEMORY;   //pktid
      index += 1;
      XBuf[2] = index - 3;   //Len

      TxCommandLabel->Caption = "Read Tag Configuration";
   } //0x50   READ_CONFIG_TAG_MEMORY
   else if (Command == SET_CONFIG_TAG_LED)   // 0xC9
   {

       if (ConfigTagLEDHostIDEdit->Text.data() == NULL)
       {
         Application->MessageBox("Error: Need Host ID!",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return (0);
       }

       int countCycle = atoi(ConfigTagLEDNumCyclesEdit->Text.c_str());

       if ((countCycle < 0) || (countCycle > 255))
       {
         Application->MessageBox("Error: Num cycles outside the limit.",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return (0);
       }

       XBuf[0] = 0x7E;           // start of Packet
       XBuf[1] = 0x0B;           //command

       if (ConfigTagLEDBroadcastReaderCheckBox->Checked)
          rdrID = 0x00;
       else if (ConfigTagLEDReaderIDComboBox->Text.data() == NULL)
       {
          Application->MessageBox("Error: Need Reader ID!",
                                  "Programming Station Information Dialog",
                                  MB_OK | MB_ICONSTOP | MB_TOPMOST);
          return (0);
       }
       else
          rdrID = atoi(ConfigTagLEDReaderIDComboBox->Text.c_str());

      /*if (ConfigTagLEDBroadcastRdrCheckBox->State == cbChecked)
         rdrID = 0x00;
      else
         rdrID = atoi(ConfigTagLEDReaderIDComboBox->Text.c_str());

      if (rdrID == 0)  //broadcast
      {
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(ConfigTagLEDHostIDEdit->Text.c_str());   //host ID
         index = 5;
      }
      else */

      if (rdrID <= 255)  //reg reader
      {
         //XBuf[2] = 0x07;   //Len
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(ConfigTagLEDHostIDEdit->Text.c_str());   //host ID
         XBuf[5] = rdrID;  //reader ID
         index = 6;
      }
      else    //extended
      {
         XBuf[3] = 0x0E;   //00 001 110
         XBuf[4] = atoi(ConfigTagLEDHostIDEdit->Text.c_str());   //host ID
         AnsiString str = IntToHex(rdrID, 4);
         XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
         str = str.SubString(3,2);
         XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
         index = 7;
      }

      unsigned char msbyte;
      //check tag type
      //if (!ConfigTagLEDAnyRadioButton->Checked)
      if (ConfigTagLEDTagTypeComboBox->Text != "All Types")
      {
         if (ConfigTagLEDAnyTagIDRadioButton->Checked)
            msbyte = 0x40;  //0100 0000  particular tag type
         else
            msbyte = 0x80;  //1000 0000  particular tag type
                            //           particular tag id
      }
      else
         msbyte = 0x00;  //00 00 0000


     XBuf[index] = msbyte;
     index += 1;
     XBuf[index] = 0x89; //start addr led control
     index += 1;

     int tagTypeVal = 0;
     if (ConfigTagLEDTagTypeComboBox->Text != "All Types")
     {
          if (ConfigTagLEDTagTypeComboBox->Text == "Factory")
          {
             tagTypeVal = 6;
          }
          else if ((tagTypeVal=GetIndexTagType(ConfigTagLEDTagTypeComboBox->Text)) < 0)
          {
              Application->MessageBox("Error in calculating tag type index",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
              ConfigTagLEDBitBtn->Enabled = true;
              return (0);
          }

          tagTypeVal += 1;
           XBuf[index] = (tagTypeVal << 5);

           if (ConfigTagLEDTagIDRangeRadioButton->Checked)
           {
               if (ConfigTagLEDTagIDRangeComboBox->Text.data() == NULL)
               {
                   Application->MessageBox("Error: Need value for the Range",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   ConfigTagLEDBitBtn->Enabled = true;
                   return (0);
               }
               XBuf[index] |= GetRangeIndex(atoi(ConfigTagLEDTagIDRangeComboBox->Text.c_str()));
               XBuf[index] |= 0x10;  //xxx 1 xxxx
          }
          else
          {
              if (ConfigTagLEDRNLongRadioButton->Checked)
                 XBuf[index] |= 0x01; //0000 0001    //long
              else
                 XBuf[index] &= 0xFE; //1111 1110    //short
           }

           initLen += 1;
           index += 1;
     } //!= "All Types"

     /*if (!ConfigTagLEDAnyRadioButton->Checked)
     {
         if (ConfigTagLEDAccRadioButton->Checked)
           XBuf[index] = 0x20;  //001 0 0000
         else if (ConfigTagLEDInvRadioButton->Checked)
           XBuf[index] = 0x40;  //010 0 0000
         else if (ConfigTagLEDAssRadioButton->Checked)
           XBuf[index] = 0x60;  //011 0 0000

         if (ConfigTagLEDTagIDRangeRadioButton->Checked)
         {
             if (ConfigTagLEDTagIDRangeComboBox->Text.data() == NULL)
             {
                   Application->MessageBox("Error: Need value for the Range",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   ConfigTagLEDBitBtn->Enabled = true;
                   return (0);
             }
             XBuf[index] |= GetRangeIndex(atoi(ConfigTagLEDTagIDRangeComboBox->Text.c_str()));
             XBuf[index] |= 0x10;  //xxx 1 xxxx
         }
         else
         {
             if (ConfigTagLEDRNLongRadioButton->Checked)
                XBuf[index] |= 0x01;  //long
         }

         index += 1;
      }*/

      if (!ConfigTagLEDAnyTagIDRadioButton->Checked)
      {
         __int64  n = ((unsigned long)atol(ConfigTagLEDTagIDEdit->Text.c_str()));
         AnsiString s = IntToHex(n, 8);
         XBuf[index] = HexToInt(s.c_str(), 2);
         index += 1;
         AnsiString s1 = s.SubString(3,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
         s1 = s.SubString(5,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         s1 = s.SubString(7,2);
         index += 1;
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
      }

      //Put data here --------------
      //int countCycle = atoi(ConfigTagLEDNumCyclesEdit->Text.c_str());
      //int countLEDon = atoi(ConfigTagLEDCountOnEdit->Text.c_str());
      //int countLEDoff = atoi(ConfigTagLEDCountOffEdit->Text.c_str());

      XBuf[index] = countCycle;
      index += 1;

      /*if (ConfigTagLED20msecDelayRadioButton->Checked)
         XBuf[index] |= 0x40;   //0100 0000      //use 20 msec else 1 msec
      if (ConfigTagLEDEnableCheckBox->Checked)
         XBuf[index] |= 0x80;   //1000 0000      //enable LED activity
      else
         XBuf[index] = 0x00;   //0xxx xxxx       //disable LED activity
      index += 1;

      XBuf[index] = countLEDon;
      index += 1;
      XBuf[index] = countLEDoff;
      index += 1;
      */

      XBuf[index] = SET_CONFIG_TAG_LED;   //pktid
      index += 1;
      XBuf[2] = index - 3;   //Len

      TxCommandLabel->Caption = "Config Tag LED";
      StaticText->Caption = "Configure Tag LED Settings";

   }// 0xC9 SET_CONFIG_TAG_LED
   else if (Command == SET_CONFIG_TAG_SPEAKER)   // 0xCC
   {

       if (ConfigTagLEDHostIDEdit->Text.data() == NULL)
       {
         Application->MessageBox("Error: Need Host ID!",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return (0);
       }

       int countCycle = atoi(ConfigTagLEDSpeakerEdit->Text.c_str());

       if ((countCycle < 0) || (countCycle > 255))
       {
         Application->MessageBox("Error: Num times outside the limit.",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return (0);
       }

       XBuf[0] = 0x7E;           // start of Packet
       XBuf[1] = 0x0B;           //command

       if (ConfigTagLEDBroadcastReaderCheckBox->Checked)
          rdrID = 0x00;
       else if (ConfigTagLEDReaderIDComboBox->Text.data() == NULL)
       {
         Application->MessageBox("Error: Need Reader ID!",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return (0);
       }
       else
          rdrID = atoi(ConfigTagLEDReaderIDComboBox->Text.c_str());

      if (rdrID <= 255)  //reg reader
      {
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(ConfigTagLEDHostIDEdit->Text.c_str());   //host ID
         XBuf[5] = rdrID;  //reader ID
         index = 6;
      }
      else    //extended
      {
         XBuf[3] = 0x0E;   //00 001 110
         XBuf[4] = atoi(ConfigTagLEDHostIDEdit->Text.c_str());   //host ID
         AnsiString str = IntToHex(rdrID, 4);
         XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
         str = str.SubString(3,2);
         XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
         index = 7;
      }

      unsigned char msbyte;
      //check tag type
      //if (!ConfigTagLEDAnyRadioButton->Checked)
      if (ConfigTagLEDTagTypeComboBox->Text != "All Types")
      {
         if (ConfigTagLEDAnyTagIDRadioButton->Checked)
            msbyte = 0x40;  //0100 0000  particular tag type
         else
            msbyte = 0x80;  //1000 0000  particular tag type
                            //           particular tag id
      }
      else
         msbyte = 0x00;  //00 00 0000


     XBuf[index] = msbyte;
     index += 1;
     XBuf[index] = 0x97; //ddr speaker control
     index += 1;

     int tagTypeVal = 0;
     if (ConfigTagLEDTagTypeComboBox->Text != "All Types")
     {
          if (ConfigTagLEDTagTypeComboBox->Text == "Factory")
          {
             tagTypeVal = 6;
          }
          else if ((tagTypeVal=GetIndexTagType(ConfigTagLEDTagTypeComboBox->Text)) < 0)
          {
              Application->MessageBox("Error in calculating tag type index",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
              ConfigTagLEDBitBtn->Enabled = true;
              return (0);
          }

          tagTypeVal += 1;
           XBuf[index] = (tagTypeVal << 5);

           if (ConfigTagLEDTagIDRangeRadioButton->Checked)
           {
               if (ConfigTagLEDTagIDRangeComboBox->Text.data() == NULL)
               {
                   Application->MessageBox("Error: Need value for the Range",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   ConfigTagLEDBitBtn->Enabled = true;
                   return (0);
               }
               XBuf[index] |= GetRangeIndex(atoi(ConfigTagLEDTagIDRangeComboBox->Text.c_str()));
               XBuf[index] |= 0x10;  //xxx 1 xxxx
          }
          else
          {
              if (ConfigTagLEDRNLongRadioButton->Checked)
                 XBuf[index] |= 0x01; //0000 0001    //long
              else
                 XBuf[index] &= 0xFE; //1111 1110    //short
           }

           initLen += 1;
           index += 1;
     } //!= "All Types"

     /*if (!ConfigTagLEDAnyRadioButton->Checked)
     {
         if (ConfigTagLEDAccRadioButton->Checked)
           XBuf[index] = 0x20;  //001 0 0000
         else if (ConfigTagLEDInvRadioButton->Checked)
           XBuf[index] = 0x40;  //010 0 0000
         else if (ConfigTagLEDAssRadioButton->Checked)
           XBuf[index] = 0x60;  //011 0 0000

         if (ConfigTagLEDTagIDRangeRadioButton->Checked)
         {
             if (ConfigTagLEDTagIDRangeComboBox->Text.data() == NULL)
             {
                   Application->MessageBox("Error: Need value for the Range",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   ConfigTagLEDBitBtn->Enabled = true;
                   return (0);
             }
             XBuf[index] |= GetRangeIndex(atoi(ConfigTagLEDTagIDRangeComboBox->Text.c_str()));
             XBuf[index] |= 0x10;  //xxx 1 xxxx
         }
         else
         {
             if (ConfigTagLEDRNLongRadioButton->Checked)
                XBuf[index] |= 0x01;  //long
         }

         index += 1;
      }*/

      if (!ConfigTagLEDAnyTagIDRadioButton->Checked)
      {
         __int64  n = ((unsigned long)atol(ConfigTagLEDTagIDEdit->Text.c_str()));
         AnsiString s = IntToHex(n, 8);
         XBuf[index] = HexToInt(s.c_str(), 2);
         index += 1;
         AnsiString s1 = s.SubString(3,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
         s1 = s.SubString(5,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         s1 = s.SubString(7,2);
         index += 1;
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
      }

      XBuf[index] = countCycle;
      index += 1;

      XBuf[index] = SET_CONFIG_TAG_SPEAKER;   //pktid
      index += 1;
      XBuf[2] = index - 3;   //Len

      TxCommandLabel->Caption = "Config Tag Speaker";
      StaticText->Caption = "Configure Tag Speaker Settings";

   }// 0xCC SET_CONFIG_TAG_SPEAKER
   else if (Command == GET_CONFIG_TAG_LED)   // 0xCA
   {
       if (ConfigTagLEDHostIDEdit->Text.data() == NULL)
       {
         Application->MessageBox("Error: Need Host ID!",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return (0);
       }

       if (ConfigTagLEDBroadcastReaderCheckBox->Checked)
          rdrID = 0x00;
       else if (ConfigTagLEDReaderIDComboBox->Text.data() == NULL)
       {
         Application->MessageBox("Error: Need Reader ID!",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return (0);
       }
       else
          rdrID = atoi(ConfigTagLEDReaderIDComboBox->Text.c_str());

       XBuf[0] = 0x7E;           // start of Packet
       XBuf[1] = 0x0C;           //command

      /*if (ConfigTagLEDBroadcastRdrCheckBox->State == cbChecked)
         rdrID = 0x00;
      else
         rdrID = atoi(ConfigTagLEDReaderIDComboBox->Text.c_str());

      if (rdrID == 0)  //broadcast
      {
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(ConfigTagLEDHostIDEdit->Text.c_str());   //host ID
         index = 5;
      }
      else */

      if (rdrID <= 255)  //reg reader
      {
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(ConfigTagLEDHostIDEdit->Text.c_str());   //host ID
         XBuf[5] = rdrID;  //reader ID
         index = 6;
      }
      else    //extended
      {
         XBuf[3] = 0x0E;   //00 001 110
         XBuf[4] = atoi(ConfigTagLEDHostIDEdit->Text.c_str());   //host ID
         AnsiString str = IntToHex(rdrID, 4);
         XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
         str = str.SubString(3,2);
         XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
         index = 7;
      }

      unsigned char msbyte;
      //check tag type
      //if (!ConfigTagLEDAnyRadioButton->Checked)
      if (ConfigTagLEDTagTypeComboBox->Text != "All Types")
      {
         if (ConfigTagLEDAnyTagIDRadioButton->Checked)
            msbyte = 0x40;  //0100 0000  particular tag type
         else
            msbyte = 0x80;  //1000 0000  particular tag type
                            //           particular tag id
      }
      else
         msbyte = 0x00;  //00 00 0000


     XBuf[index] = msbyte;
     index += 1;
     XBuf[index] = 0x89; //start addr led control
     index += 1;

     int tagTypeVal = 0;
     if (ConfigTagLEDTagTypeComboBox->Text != "All Types")
     {
          if (ConfigTagLEDTagTypeComboBox->Text == "Factory")
          {
             tagTypeVal = 6;
          }
          else if ((tagTypeVal=GetIndexTagType(ConfigTagLEDTagTypeComboBox->Text)) < 0)
          {
              Application->MessageBox("Error in calculating tag type index",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
              ConfigTagLEDBitBtn->Enabled = true;
              return (0);
          }

          tagTypeVal += 1;
          XBuf[index] = (tagTypeVal << 5);

           if (ConfigTagLEDTagIDRangeRadioButton->Checked)
           {
               if (ConfigTagLEDTagIDRangeComboBox->Text.data() == NULL)
               {
                   Application->MessageBox("Error: Need value for the Range",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   ConfigTagLEDBitBtn->Enabled = true;
                   return (0);
               }
               XBuf[index] |= GetRangeIndex(atoi(ConfigTagLEDTagIDRangeComboBox->Text.c_str()));
               XBuf[index] |= 0x10;  //xxx 1 xxxx
          }
          else
          {
              if (ConfigTagLEDRNLongRadioButton->Checked)
                 XBuf[index] |= 0x01; //0000 0001    //long
              else
                 XBuf[index] &= 0xFE; //1111 1110    //short
           }

           initLen += 1;
           index += 1;
     } //!= "All Types"

     /*if (!ConfigTagLEDAnyRadioButton->Checked)
     {
         if (ConfigTagLEDAccRadioButton->Checked)
           XBuf[index] = 0x20;  //001 0 0000
         else if (ConfigTagLEDInvRadioButton->Checked)
           XBuf[index] = 0x40;  //010 0 0000
         else if (ConfigTagLEDAssRadioButton->Checked)
           XBuf[index] = 0x60;  //011 0 0000

         if (ConfigTagLEDRNLongRadioButton->Checked)
            XBuf[index] |= 0x01;  //long

         index += 1;
      }*/

      if (!ConfigTagLEDAnyTagIDRadioButton->Checked)
      {
         __int64  n = ((unsigned long)atol(ConfigTagLEDTagIDEdit->Text.c_str()));
         AnsiString s = IntToHex(n, 8);
         XBuf[index] = HexToInt(s.c_str(), 2);
         index += 1;
         AnsiString s1 = s.SubString(3,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
         s1 = s.SubString(5,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         s1 = s.SubString(7,2);
         index += 1;
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
      }

      XBuf[index] = 0x01; //byte to read
      index += 1;
      XBuf[index] = GET_CONFIG_TAG_LED;   //pktid
      index += 1;
      XBuf[2] = index - 3;   //Len

      TxCommandLabel->Caption = "Config Tag LED";
      //StaticText->Caption = "Configure Tag LED Settings";

   }// 0xCA GET_TAG_LED
   else if (Command == GET_CONFIG_TAG_SPEAKER)   // 0xCB
   {
       if (ConfigTagLEDHostIDEdit->Text.data() == NULL)
       {
         Application->MessageBox("Error: Need Host ID!",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return (0);
       }

       if ((ConfigTagLEDReaderIDComboBox->Text.data() == NULL) &&
           (ConfigTagLEDBroadcastRdrCheckBox->Checked == false))
       {
         Application->MessageBox("Error: Need Reader ID!",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return (0);
       }

       XBuf[0] = 0x7E;           // start of Packet
       XBuf[1] = 0x0C;           //command

       rdrID = atoi(ConfigTagLEDReaderIDComboBox->Text.c_str());

      /*if (ConfigTagLEDBroadcastRdrCheckBox->State == cbChecked)
         rdrID = 0x00;
      else
         rdrID = atoi(ConfigTagLEDReaderIDComboBox->Text.c_str());

      if (rdrID == 0)  //broadcast
      {
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(ConfigTagLEDHostIDEdit->Text.c_str());   //host ID
         index = 5;
      }
      else */

      if (rdrID <= 255)  //reg reader
      {
         //XBuf[2] = 0x07;   //Len
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(ConfigTagLEDHostIDEdit->Text.c_str());   //host ID
         XBuf[5] = rdrID;  //reader ID
         index = 6;
      }
      else    //extended
      {
         XBuf[3] = 0x0E;   //00 001 110
         XBuf[4] = atoi(ConfigTagLEDHostIDEdit->Text.c_str());   //host ID
         AnsiString str = IntToHex(rdrID, 4);
         XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
         str = str.SubString(3,2);
         XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
         index = 7;
      }

      unsigned char msbyte;
      //check tag type
      //if (!ConfigTagLEDAnyRadioButton->Checked)
      if (ConfigTagLEDTagTypeComboBox->Text != "All Types")
      {
         if (ConfigTagLEDAnyTagIDRadioButton->Checked)
            msbyte = 0x40;  //0100 0000  particular tag type
         else
            msbyte = 0x80;  //1000 0000  particular tag type
                            //           particular tag id
      }
      else
         msbyte = 0x00;  //00 00 0000


     XBuf[index] = msbyte;
     index += 1;
     XBuf[index] = 0x97; //addr tag speaker control
     index += 1;

     int tagTypeVal = 0;
     if (ConfigTagLEDTagTypeComboBox->Text != "All Types")
     {
          if (ConfigTagLEDTagTypeComboBox->Text == "Factory")
          {
             tagTypeVal = 6;  //one will be added
          }
          else if ((tagTypeVal=GetIndexTagType(ConfigTagLEDTagTypeComboBox->Text)) < 0)
          {
              Application->MessageBox("Error in calculating tag type index",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
              ConfigTagLEDBitBtn->Enabled = true;
              return (0);
          }

           tagTypeVal += 1;  //index zero
           XBuf[index] = (tagTypeVal << 5);

           if (ConfigTagLEDTagIDRangeRadioButton->Checked)
           {
               if (ConfigTagLEDTagIDRangeComboBox->Text.data() == NULL)
               {
                   Application->MessageBox("Error: Need value for the Range",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   ConfigTagLEDBitBtn->Enabled = true;
                   return (0);
               }
               XBuf[index] |= GetRangeIndex(atoi(ConfigTagLEDTagIDRangeComboBox->Text.c_str()));
               XBuf[index] |= 0x10;  //xxx 1 xxxx
          }
          else
          {
              if (ConfigTagLEDRNLongRadioButton->Checked)
                 XBuf[index] |= 0x01; //0000 0001    //long
              else
                 XBuf[index] &= 0xFE; //1111 1110    //short
           }

           initLen += 1;
           index += 1;
     } //!= "All Types"

     /*if (!ConfigTagLEDAnyRadioButton->Checked)
     {
         if (ConfigTagLEDAccRadioButton->Checked)
           XBuf[index] = 0x20;  //001 0 0000
         else if (ConfigTagLEDInvRadioButton->Checked)
           XBuf[index] = 0x40;  //010 0 0000
         else if (ConfigTagLEDAssRadioButton->Checked)
           XBuf[index] = 0x60;  //011 0 0000

         if (ConfigTagLEDRNLongRadioButton->Checked)
            XBuf[index] |= 0x01;  //long

         index += 1;
      } */

      if (!ConfigTagLEDAnyTagIDRadioButton->Checked)
      {
         __int64  n = ((unsigned long)atol(ConfigTagLEDTagIDEdit->Text.c_str()));
         AnsiString s = IntToHex(n, 8);
         XBuf[index] = HexToInt(s.c_str(), 2);
         index += 1;
         AnsiString s1 = s.SubString(3,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
         s1 = s.SubString(5,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         s1 = s.SubString(7,2);
         index += 1;
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
      }

      XBuf[index] = 0x01; //byte to read
      index += 1;
      XBuf[index] = GET_CONFIG_TAG_SPEAKER;   //pktid
      index += 1;
      XBuf[2] = index - 3;   //Len

      TxCommandLabel->Caption = "Config Tag Speaker";
      //StaticText->Caption = "Configure Tag Speaker Settings";

   }// 0xCB GET_TAG_SPEAKER
   else if (Command == ABS_DPOT_SMART_FGEN)   //0x9C
   {
       if (FGenConfigSmartFieldGenIDComboBox->Text.data() == NULL)
       {
         Application->MessageBox("Error: Need FGen ID!",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return (0);
       }

       if (SFGenConfigHostIDEdit->Text.data() == NULL)
       {
         Application->MessageBox("Error: Need Host ID!",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return (0);
       }

       if (FGenConfigSmartFGenReaderIDComboBox->Text.data() == NULL)
       {
         Application->MessageBox("Error: Need Reader ID!",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return (0);
       }

       if (!FGenConfigPotentiModifyCheckBox->Checked &&
           !SFGenConfigFSRangeModifyCheckBox->Checked)
       {
         Application->MessageBox("No Modify check box is checked for Field Strength",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return (0);
       }

       if (FGenConfigPotentiComboBox->Text.data() == NULL)
       {
          Application->MessageBox("No Value is selected for Field Strength.",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return (0);
       }

       XBuf[0] = 0x7E;    // start of Packet
       XBuf[1] = 0x39;    //General command
       XBuf[2] = 0x02;    //init Len

       rdrID =  atoi(FGenConfigSmartFGenReaderIDComboBox->Text.c_str());

       if (rdrID <= 255)  //reg reader
       {
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(SFGenConfigHostIDEdit->Text.c_str());   //host ID
         XBuf[5] = rdrID;  //reader ID
         XBuf[2] += 1;     //Len
         index = 6;
       }
       else    //extended
       {
            XBuf[3] = 0x0E;   //00 001 110
            XBuf[4] = atoi(SFGenConfigHostIDEdit->Text.c_str());  //host ID
            AnsiString str = IntToHex(rdrID, 4);
            XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
            str = str.SubString(3,2);
            XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
            XBuf[2] += 2;     //Len
            index = 7;
       }

       XBuf[index] = 0x0B;
       index += 1;

       XBuf[index] = 0x10;
       index += 1;

       XBuf[index] = atoi(FGenConfigSmartFieldGenIDComboBox->Text.c_str());  //FGen ID
       index += 1;

       XBuf[index] = 0x3F;
       index += 1;

       XBuf[index] = 0x20;   //0010 0000     //DPOT
       if (SFGenConfigFSRangeModifyCheckBox->Checked)    //short or long range
       {
           XBuf[index] |= 0x80;   //1000 0000  set bit 6 for long/short range
           if (SFGenConfigShortRangeRadioButton->Checked)
              XBuf[index] |= 0x20;   //0010 0000
           else
              XBuf[index] |= 0x60;   //0110 0000
       }

       XBuf[index] |= atoi(FGenConfigPotentiComboBox->Text.c_str());
       index += 1;

       XBuf[index] = ABS_DPOT_SMART_FGEN;    //PKT ID
       index += 1;

       XBuf[2] = index - 3;   //len

       TxCommandLabel->Caption = "Config DPot";
       StaticText->Caption = "Configure Smart Field Gen Field Strength.";

   }
   else if (Command == RESET_SMART_FGEN)  //0x96
   {

      if (FGenResetHostIDEdit->Text.data() == NULL)
      {
         ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Need Host ID!",
                       ( LPCSTR )"Programming Station Information Dialog",
                       MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
         FGenResetBitBtn->Enabled = true;
         return (0);
      }

      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0x39;           //General command

      if ((FGenResetIDComboBox->Text.data() == NULL) &&
          !FGenResetBroadcastSmartFGenCheckBox->Checked)
      {
         Application->MessageBox("Error: Need FGen ID!",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         FGenResetBitBtn->Enabled = true;
         return (0);

      }

      if (FGenResetBroadcastRdrCheckBox->State == cbChecked)
         rdrID = 0x00;
      else if (FGenResetReaderIDComboBox->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Reader ID!",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         FGenResetBitBtn->Enabled = true;
         return (0);
      }
      else
         rdrID =  atoi(FGenResetReaderIDComboBox->Text.c_str());

      XBuf[2] = 0x02;   //init Len
      if (rdrID <= 255)  //reg reader
      {
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(FGenResetHostIDEdit->Text.c_str());   //host ID
         XBuf[5] = rdrID;  //reader ID
         XBuf[2] += 1;     //Len
         index = 6;
      }
      else    //extended
      {
            XBuf[3] = 0x0E;   //00 001 110
            XBuf[4] = atoi(ResetHostIDEdit->Text.c_str());  //host ID
            AnsiString str = IntToHex(rdrID, 4);
            XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
            str = str.SubString(3,2);
            XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
            XBuf[2] += 2;     //Len
            index = 7;
      }

      XBuf[index++] = 0x01;  //reset Command
      XBuf[index++] = 0x10;  //pkt type
      if (FGenResetBroadcastSmartFGenCheckBox->Checked)
         XBuf[index++] = 0x00;     //broadcast FGen
      else
         XBuf[index++] = atoi(FGenResetIDComboBox->Text.c_str());  //FGen ID
      XBuf[index++] = 0x79;  //pkt id
      XBuf[2] += 4;         //len

      if (rdrID > 0)
      {
         TxReaderIDLabel->Caption = rdrID;
         TxCommandLabel->Caption = "Reset Smart FGen";
         StaticText->Caption = "Reset Smart FGen";
      }
      else
      {
         TxReaderIDLabel->Caption = "Broadcast";
         TxCommandLabel->Caption = "Reset Smart FGen - Broadcast";
         StaticText->Caption = "Reset Smart FGen - Broadcast";
      }

      //time = Time();
      //DecodeTime(time, Hour, Min, Sec, MSec);
      //sendTime = Hour*60*60*1000 + Min*60*1000 + Sec*1000;
      //waitingForRespone = true;
      //waitResetRdrACK = true;
   }
   else if (Command == INPUT_STATUS) //0x11
   {
      XBuf[0] = 0x7E;   // start of Packet
      XBuf[1] = 0x11;   // command

      if (InputHostIDEdit->Text.data() == NULL)
      {
         ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Need Host ID!",
         ( LPCSTR )"Programming Station Information Dialog",
         MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
         return (0);
      }
      if ((InputReaderIDComboBox->Text.data() == NULL) &&
          (!InputBroadCastCheckBox->Checked))
      {
           ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Need Reader ID!",
           ( LPCSTR )"Programming Station Information Dialog",
           MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
           return (0);
      }

      if (InputBroadCastCheckBox->Checked)
         rdrID = 0x00;
      else
        rdrID = atoi(InputReaderIDComboBox->Text.c_str());

      if (rdrID <= 255)  //reg reader
      {
         XBuf[2] = 0x05;   //Len
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(InputHostIDEdit->Text.c_str());   //host ID
         XBuf[5] = rdrID;  //reader ID

         if (Input1ModifyCheckBox->Checked)
         {
            //if (Input1NoChangeRadioButton->Checked)  //input 1
               //configByte = 0x00;  //0000 0000       //no change
            if (Input1NoReportRadioButton->Checked)
               configByte = 0x10;  //0001 0000       // do not report stat chng
            else
               configByte = 0x11;  //0001 0001       //report stat chng
         }
         else
            configByte = 0x00;  //0000 0000       //no change

         if (Input2ModifyCheckBox->Checked)
         {
            //if (Input2NoChangeRadioButton->Checked) //input 2
               //configByte |= 0x00;  //00100 0000    //no change
            if (Input2NoReportRadioButton->Checked)
               configByte |= 0x20;  //0010 0000     //do not report stat chng
            else
               configByte |= 0x22;  //0010 0010    //report stat chng
         }
         else
            configByte |= 0x00;  //00100 0000    //no change

         XBuf[6] = configByte;   //config byte
         XBuf[7] = 0x31;  //pkt ID relay 1
         index = 8;
      }
      else    //extended
      {
         XBuf[2] = 0x06;   //Len
         XBuf[3] = 0x0E;   //00 001 110
         XBuf[4] = atoi(InputHostIDEdit->Text.c_str());  //host ID
         AnsiString str = IntToHex(rdrID, 4);
         XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
         str = str.SubString(3,2);
         XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID

         if (Input1ModifyCheckBox->Checked)
         {
            //if (Input1NoChangeRadioButton->Checked)  //input 1
               //configByte = 0x00;  //0000 0000       //no change
            if (Input1NoReportRadioButton->Checked)
               configByte = 0x10;  //0001 0000       // do not report stat chng
            else
               configByte = 0x11;  //0001 0001       //report stat chng
         }
         else
            configByte = 0x00;  //0000 0000       //no change

         if (Input2ModifyCheckBox->Checked)
         {
            //if (Input2NoChangeRadioButton->Checked) //input 2
               //configByte |= 0x00;  //00100 0000    //no change
            if (Input2NoReportRadioButton->Checked)
               configByte |= 0x20;  //0010 0000     //do not report stat chng
            else
               configByte |= 0x22;  //0010 0010    //report stat chng
         }
         else
            configByte |= 0x00;  //00100 0000    //no change

         XBuf[7] = configByte;  //config byte
         XBuf[8] = 0x32;  //pkt ID
         index = 9;
      }


      if (InputReaderIDComboBox->Text.data() != NULL)
         TxReaderIDLabel->Caption = InputReaderIDComboBox->Text;
      else
         TxReaderIDLabel->Caption = "";

      TxCommandLabel->Caption = "Input Status";
   }
   else if (Command == ENABLE_RELAY)  //0x02
   {
      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0x02;           //command
      if (RelayHostIDEdit->Text.data() == NULL)
      {
         ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Need Host ID!",
         ( LPCSTR )"Programming Station Information Dialog",
         MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
         return (0);
      }

      if ((RelayReaderIDComboBox->Text.data() == NULL) &&
          (!RelayBroadcastRdrCheckBox->Checked))
      {
           ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Need Reader ID!",
           ( LPCSTR )"Programming Station Information Dialog",
           MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
           return (0);
      }

      if (RelayBroadcastRdrCheckBox->Checked)
         rdrID = 0x00;  //broadcast reader
      else
        rdrID = atoi(RelayReaderIDComboBox->Text.c_str());

      //enable relay

      if (rdrID <= 255)  //reg reader
      {
         XBuf[2] = 0x05;   //Len
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(RelayHostIDEdit->Text.c_str());   //host ID
         XBuf[5] = rdrID;  //reader ID
         if (EnableRelay1RadioButton->Checked)
         {
               XBuf[6] = 0x01;
               XBuf[7] = 0x41;  //pkt ID relay 1
         }
         else if (EnableRelay2RadioButton->Checked)
         {
               XBuf[6] = 0x02;
               XBuf[7] = 0x42;  //pkt ID relay 2
         }
         else
         {
               ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Need Relay Number!",
               ( LPCSTR )"Programming Station Information Dialog",
               MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
               return (0);
         }

         index = 8;
      }
      else    //extended
      {
         XBuf[2] = 0x06;   //Len
         XBuf[3] = 0x0E;   //00 001 110
         XBuf[4] = atoi(RelayHostIDEdit->Text.c_str());  //host ID
         AnsiString str = IntToHex(rdrID, 4);
         XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
         str = str.SubString(3,2);
         XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
         if (EnableRelay1RadioButton->Checked)
         {
               XBuf[7] = 0x01; //relay Address
               XBuf[8] = 0x41;  //pkt ID relay 1
         }
         else if (EnableRelay2RadioButton->Checked)
         {
               XBuf[7] = 0x02; //relay Address
               XBuf[8] = 0x42;  //pkt ID relay 2
         }
         else
         {
               ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Need Relay Number!",
               ( LPCSTR )"Programming Station Information Dialog",
               MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
               return (0);
         }

         index = 9;
      }

      if (RelayReaderIDComboBox->Text.data() != NULL)
         TxReaderIDLabel->Caption = RelayReaderIDComboBox->Text;
      else
         TxReaderIDLabel->Caption = "";

      TxCommandLabel->Caption = "Enable Relay";
   }
   else if (Command == DISABLE_RELAY)  //0x03
   {
      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0x03;           //command

      if (RelayHostIDEdit->Text.data() == NULL)
      {
         ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Need Host ID!",
         ( LPCSTR )"Programming Station Information Dialog",
         MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
         return (0);
      }
      if (RelayReaderIDComboBox->Text.data() == NULL)
      {
           ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Need Reader ID!",
           ( LPCSTR )"Programming Station Information Dialog",
           MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
           return (0);
      }
      else
      {
         //disable relay
         rdrID = atoi(RelayReaderIDComboBox->Text.c_str());
         if (rdrID <= 255)  //reg reader
         {
            XBuf[2] = 0x05;   //Len
            XBuf[3] = 0x0A;   //00 001 010
            XBuf[4] = atoi(RelayHostIDEdit->Text.c_str());   //host ID
            XBuf[5] = rdrID;  //reader ID
            if (DisableRelay1RadioButton->Checked)
            {
               XBuf[6] = 0x01;
               XBuf[7] = 0x41;  //pkt ID relay 1
            }
            else if (DisableRelay2RadioButton->Checked)
            {
               XBuf[6] = 0x02;
               XBuf[7] = 0x42;  //pkt ID relay 2
            }
            else
            {
               ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Need Relay Number!",
               ( LPCSTR )"Programming Station Information Dialog",
               MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
               return (0);
            }
            //XBuf[7] = 0x41;  //pkt ID
            index = 8;
         }
         else    //extended
         {
            XBuf[2] = 0x06;   //Len
            XBuf[3] = 0x0E;   //00 001 110
            XBuf[4] = atoi(RelayHostIDEdit->Text.c_str());  //host ID
            AnsiString str = IntToHex(rdrID, 4);
            XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
            str = str.SubString(3,2);
            XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
            if (DisableRelay1RadioButton->Checked)
            {
               XBuf[7] = 0x01; //relay Address
               XBuf[8] = 0x41;  //pkt ID relay 1
            }
            else if (DisableRelay2RadioButton->Checked)
            {
               XBuf[7] = 0x02; //relay Address
               XBuf[8] = 0x42;  //pkt ID relay 2
            }
            else
            {
               ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Need Relay Number!",
               ( LPCSTR )"Programming Station Information Dialog",
               MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
               return (0);
            }

            //XBuf[8] = 0x41;  //pkt ID
            index = 9;
         }
      }

      if (RelayReaderIDComboBox->Text.data() != NULL)
         TxReaderIDLabel->Caption = RelayReaderIDComboBox->Text;
      else
         TxReaderIDLabel->Caption = "";

      TxCommandLabel->Caption = "Disable Relay";
   }
   else if (Command == SET_READER_DPOT)  //0x22
   {
      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0x22;           //command

      /*if (AssignReaderGroupBox->Visible)
      {
         if (AssignReaderHostIDEdit->Text.data() == NULL)
         {
             Application->MessageBox("Error: Need Host ID!",
                                     "Programming Station Information Dialog",
                                     MB_OK | MB_ICONSTOP | MB_TOPMOST);
             //SetFStrengthBitBtn->Enabled = true;
             return (0);
         }

         if ((AssignReaderModifyFSCheckBox->Checked) &&
             (AssignReaderFSComboBox->Text.data() == NULL))
         {
               Application->MessageBox( "Error: Field Strength.",
                                        "Programming Station Information Dialog",
                                        MB_OK | MB_ICONSTOP | MB_TOPMOST);
               return (0);
         }

         if ((!AssignReaderBroadcastReaderCheckBox->Checked) &&
             (AssignReaderIDComboBox->Text.data() == NULL))
         {
             Application->MessageBox("Error: Need Reader ID!",
                                     "Programming Station Information Dialog",
                                     MB_OK | MB_ICONSTOP | MB_TOPMOST);
             return (0);
         }

         if (AssignReaderBroadcastReaderCheckBox->Checked)
         {
            XBuf[2] = 0x04;   //Len
            XBuf[3] = 0x0A;   //00 001 010
            XBuf[4] = atoi(AssignReaderHostIDEdit->Text.c_str());   //host ID
            XBuf[5] = atoi(AssignReaderFSComboBox->Text.c_str());    //FS
            XBuf[6] = 0xC2;   //pkt
            index = 7;

           TxCommandLabel->Caption = "Set All Reader DPOTs";
         }
         else
         {
             //enable particular reader
             rdrID = atoi(AssignReaderIDComboBox->Text.c_str());
             if (rdrID <= 255)  //reg reader
             {
               XBuf[2] = 0x05;   //Len
               XBuf[3] = 0x0A;   //00 001 010
               XBuf[4] = atoi(AssignReaderHostIDEdit->Text.c_str());   //host ID
               XBuf[5] = rdrID;  //reader ID
               XBuf[6] = atoi(AssignReaderFSComboBox->Text.c_str());    //FS
               XBuf[7] = 0xC2;   //pkt
               index = 8;
               TxCommandLabel->Caption = "Enable Reader";
            }
            else    //extended
            {
               XBuf[2] = 0x06;   //Len
               XBuf[3] = 0x0E;   //00 001 110
               XBuf[4] = atoi(AssignReaderHostIDEdit->Text.c_str());  //host ID
               AnsiString str = IntToHex(rdrID, 4);
               XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
               str = str.SubString(3,2);
               XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
               XBuf[6] = atoi(AssignReaderFSComboBox->Text.c_str());    //FS
               XBuf[8] = 0xC2;   //pkt
               index = 9;

               TxCommandLabel->Caption = "Set Reader DPOT";
            }
         }
      }
      else  */
      {
      if (ReaderFStrengthHostEdit->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Host ID!",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         SetFStrengthBitBtn->Enabled = true;
         return (0);
      }

      if ((ReaderFStrengthReaderComboBox->Text.data() == NULL) &&
          (!ReaderFStrengthBroadcastCheckBox->Checked))
      {
          Application->MessageBox("Error: Need Reader ID",
                                      "Programming Station Information Dialog",
                                      MB_OK | MB_ICONSTOP | MB_TOPMOST);
              SetFStrengthBitBtn->Enabled = true;
              return (0);
      }

      if (ReaderSetABSTxFieldCheckBox->Checked)
      {
          if (ReaderModifyTXFComboBox->Text.data() == NULL)
          {
              Application->MessageBox("Error: Need value for Digital Potentiometer!",
                                      "Programming Station Information Dialog",
                                      MB_OK | MB_ICONSTOP | MB_TOPMOST);
              SetFStrengthBitBtn->Enabled = true;
              return (0);
          }
      }

      if (buf[0] == 'D')
      {
         configByte = 0x5F;  //dncrement POT  01 0 1 1111(01xb bbbb)
      }
      else if (buf[0] == 'I')
      {
         configByte = 0x9F;  //increment POT 10 0 1 1111(10xb bbbb)
      }
      else if (buf[0] == 'R')
      {
         if (ReaderShortRangeRadioButton->Checked)
            configByte = 0xDF;  //short range 11 0 1 1111(11xb bbbb)
         else
            configByte = 0xFF;  //long range  11 1 1 1111(11xb bbbb)
      }
      else if (buf[0] == 'A')
      {
         configByte = atoi(ReaderModifyTXFComboBox->Text.c_str());
         if (ReaderShortRangeRadioButton->Checked)
            configByte += 0xC0;  //short range 11 0 0 0000(11xn nnnn)
         else
            configByte += 0xE0;  //long range  11 1 0 0000(11xn nnnn)
      }
      else
         return(0);

      if (ReaderFStrengthBroadcastCheckBox->Checked)
         rdrID = 0x00;
      else
         rdrID = atoi(ReaderFStrengthReaderComboBox->Text.c_str());

      if (rdrID <= 255)
      {
         XBuf[2] = 0x05;   //Len
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(ReaderFStrengthHostEdit->Text.c_str());   //host ID
         XBuf[5] = rdrID;
         XBuf[6] = configByte;   //level ctl byte
         if (buf[0] == 'I')
            XBuf[7] = 0x85;   //pkt
         else
            XBuf[7] = 0x84;   //pkt
         index = 8;

         if (rdrID == 0)
            TxCommandLabel->Caption = "Set All Reader DPOTs";
         else
            TxCommandLabel->Caption = "Set Reader DPOT";
      }
      else    //extended
      {
            XBuf[2] = 0x06;   //Len
            XBuf[3] = 0x0E;   //00 001 110
            XBuf[4] = atoi(ReaderFStrengthHostEdit->Text.c_str());  //host ID
            AnsiString str = IntToHex(rdrID, 4);
            XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
            str = str.SubString(3,2);
            XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
            XBuf[7] = configByte;   //level ctl byte
            if (buf[0] == 'I')
               XBuf[8] = 0x85;   //pkt
            else
               XBuf[8] = 0x84;   //pkt
            index = 9;

            TxCommandLabel->Caption = "Set Reader DPOT";
      }

      if (ReaderFStrengthReaderComboBox->Text.data() != NULL)
         TxReaderIDLabel->Caption = ReaderFStrengthReaderComboBox->Text;
      else
         TxReaderIDLabel->Caption = "";
      }//else
   }//SET_READER_DPOT
   else if (Command == ENABLE_READER)  //0x04
   {
      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0x04;           //command
      if (EnableReaderHostIDEdit->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Host ID!",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         EnableReaderBitBtn->Enabled = true;
         return (0);
      }

      if (EnableReaderBroadcastRdrCheckBox->Checked)
      {
         //XBuf[2] = 0x03;   //Len
         //XBuf[3] = 0x0A;   //00 001 010
         //XBuf[4] = atoi(EnableReaderHostIDEdit->Text.c_str());   //host ID
         //XBuf[5] = 0xAA;   //pkt ID
         //XBuf[6] = 0x00;
         //index = 7;

         rdrID = 0x00;   //Global reader
         //TxCommandLabel->Caption = "Enable All Readers";
      }
      else if (EnableReaderIDComboBox->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Reader ID!",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         EnableReaderBitBtn->Enabled = true;
         return (0);
      }
      else
      {
         //enable particular reader
         rdrID = atoi(EnableReaderIDComboBox->Text.c_str());
      }

      if (rdrID <= 255)  //reg reader
      {
         XBuf[2] = 0x04;   //Len
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(EnableReaderHostIDEdit->Text.c_str());   //host ID
         XBuf[5] = rdrID;  //reader ID
         XBuf[6] = 0xAA;   //pkt ID
         index = 7;

         if (rdrID == 0x00)
            TxCommandLabel->Caption = "Enable All Readers";
         else
            TxCommandLabel->Caption = "Enable Reader";
      }
      else    //extended
      {
         XBuf[2] = 0x05;   //Len
         XBuf[3] = 0x0E;   //00 001 110
         XBuf[4] = atoi(EnableReaderHostIDEdit->Text.c_str());  //host ID
         AnsiString str = IntToHex(rdrID, 4);
         XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
         str = str.SubString(3,2);
         XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
         XBuf[7] = 0xAA;   //pkt ID
         index = 8;

         if (rdrID == 0x00)
            TxCommandLabel->Caption = "Enable All Readers";
         else
            TxCommandLabel->Caption = "Enable Reader";
      }


      if (EnableReaderIDComboBox->Text.data() != NULL)
         TxReaderIDLabel->Caption = EnableReaderIDComboBox->Text;
      else
         TxReaderIDLabel->Caption = "";
   }
   else if (Command == DISABLE_READER)   //0x05
   {
      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0x05;           //command

      if (DisableReaderHostIDEdit->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Host ID!",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         DisableReaderBitBtn->Enabled = true;
         return (0);
      }

      if (DisableReaderBroadcastRdrCheckBox->Checked)
      {
         //XBuf[2] = 0x03;   //Len
         //XBuf[3] = 0x0A;   //00 001 010
         //XBuf[4] = atoi(DisableReaderHostIDEdit->Text.c_str());   //host ID
         //XBuf[5] = 0xAA;   //pkt ID
         //index = 6;

         rdrID = 0x00;   //Global reader
         //TxCommandLabel->Caption = "Disable All Readers";
      }
      else if (DisableReaderIDComboBox->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Reader ID!",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         DisableReaderBitBtn->Enabled = true;
         return (0);
      }
      else
      {
         rdrID = atoi(DisableReaderIDComboBox->Text.c_str());
      }

      if (rdrID <= 255)  //reg reader
      {
         XBuf[2] = 0x04;   //Len
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(DisableReaderHostIDEdit->Text.c_str());   //host ID
         XBuf[5] = rdrID;  //reader ID
         XBuf[6] = 0xAB;   //pkt ID
         index = 7;

         if (rdrID == 0)
            TxCommandLabel->Caption = "Disable All Readers";
         else
            TxCommandLabel->Caption = "Disable Reader";
      }
      else    //extended
      {
          XBuf[2] = 0x05;   //Len
          XBuf[3] = 0x0E;   //00 001 110
          XBuf[4] = atoi(DisableReaderHostIDEdit->Text.c_str());   //host ID
          AnsiString str = IntToHex(rdrID, 4);
          XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
          str = str.SubString(3,2);
          XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
          XBuf[7] = 0xAB;   //pkt ID
          index = 8;

          if (rdrID == 0)
             TxCommandLabel->Caption = "Disable All Readers";
          else
             TxCommandLabel->Caption = "Disable Reader";
      }

      if (DisableReaderIDComboBox->Text.data() != NULL)
         TxReaderIDLabel->Caption = DisableReaderIDComboBox->Text;
      else
         TxReaderIDLabel->Caption = "";

   }
   else if (Command == CONFIG_TAG)  //0x06
   {
      int chgCount = 0;
      unsigned short index01 = 0;
      int startAddr = 0x00;
      unsigned char cByte = 0x00;
      bool doGetConfig = false;
      int mulStartAddr = 0x00;
      unsigned char XXBuf[10] = {'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0'};

      if (ConfigTagHostIDEdit->Text.data() == NULL)    //HOST ID
      {
         Application->MessageBox("Error: Need Host ID!",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         ConfigTagBitBtn->Enabled = true;
         return (0);
      }

      if (ConfigTagReaderIDComboBox->Text.data() == NULL)    //READER ID
      {
           Application->MessageBox("Error: Need Reader ID !",
                                   "Programming Station Information Dialog",
                                   MB_OK | MB_ICONSTOP | MB_TOPMOST);
           ConfigTagBitBtn->Enabled = true;
           return (0);
      }

      if (ConfigTagTagIDRadioButton->Checked)    //TAG ID
      {
          if (ConfigTagTagIDEdit->Text.data() == NULL)
          {
              Application->MessageBox("Error: Need Tag ID !",
                                   "Programming Station Information Dialog",
                                   MB_OK | MB_ICONSTOP | MB_TOPMOST);
              ConfigTagBitBtn->Enabled = true;
              return (0);
          }
      }

      //Changing Parameter Section ----------------------------
      if (ConfigTagNewTagTypeCheckBox->Checked)    //TAG TYPE
      {
         chgCount += 1;
         startAddr = 0x81;
         mulStartAddr = 0x81;
         cByte = 0x01;  //0000 0001
      }

      if (ConfigTagModifyRNCheckBox->Checked)    //RA - RN
      {
         chgCount += 1;
         startAddr = 0x81;
         mulStartAddr = 0x81;
         cByte = 0x01;  //0000 0001
      }

      if (ConfigTagModifyTamperCheckBox->Checked)    //TAMPER
      {
         chgCount += 1;
         startAddr = 0x81;
         mulStartAddr = 0x81;
         cByte = 0x01;  //0000 0001
      }

      if (ConfigTagNewTagIDCheckBox->Checked)    //NEW TAG ID
      {
         if (ConfigTagNewIDEdit->Text.data() == NULL)
         {
              Application->MessageBox("Error: Need New Tag ID !",
                                   "Programming Station Information Dialog",
                                   MB_OK | MB_ICONSTOP | MB_TOPMOST);
              ConfigTagBitBtn->Enabled = true;
              return (0);
         }

         chgCount += 1;
         startAddr = 0x82;
         if (cByte == 0x00)
            mulStartAddr = 0x82;
         cByte |= 0x02;  //0000 0010
      }

      if (ConfigTagTIFCheckBox->Checked)     //TIF - GC
      {
         if (ConfigTagTIFComboBox->Text.data() == NULL)
         {
            Application->MessageBox("Error: No value for Time in the Field(TIF) is Selected!",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST);
            ConfigTagBitBtn->Enabled = true;
            return (0);
         }

         if (ConfigTagGCComboBox->Text.data() == NULL)
         {
            Application->MessageBox("Error: No value for Group Count(GC) is Selected!",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST);
            ConfigTagBitBtn->Enabled = true;
            return (0);
         }

         chgCount += 1;
         startAddr = 0x86;
         if (cByte == 0x00)
            mulStartAddr = 0x86;
         cByte |= 0x04;  //0000 0100
      }

      if (ConfigTagEnableTimeCheckBox->Checked)  //RESEND TIME
      {
         if (GetTimePeriod() == -1)
         {
            Application->MessageBox("Error: No value for Resend Time is Selected!",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST);
            ConfigTagBitBtn->Enabled = true;
            return (0);
         }

         chgCount += 1;
         startAddr = 0x87;
         if (cByte == 0x00)
            mulStartAddr = 0x87;
         cByte |= 0x08;  //0000 1000
      }

      //-----------------------NEW CONFIGURATION ----------------------------
      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0x0B;           //command

      unsigned char oldTagType = 0x00;
      unsigned char newTagType = 0x00;
      AnsiString oldTagID;
      AnsiString newTagID;
      AnsiString TimePeriodStr;
      unsigned char tifGcValue = 0x00;
      int configIndex = 0;
      int addrIndex = 0;

      rdrID = atoi(ConfigTagReaderIDComboBox->Text.c_str());

      if (rdrID <= 255)  //reg reader
      {
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(ConfigTagHostIDEdit->Text.c_str());   //host ID
         XBuf[5] = rdrID;  //reader ID
         index = 6;
      }
      else    //extended
      {
         XBuf[3] = 0x0E;   //00 001 110
         XBuf[4] = atoi(ConfigTagHostIDEdit->Text.c_str());   //host ID
         AnsiString str = IntToHex(rdrID, 4);
         XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
         str = str.SubString(3,2);
         XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
         index = 7;
      }

      //CMD + starting address
      /*if (!ConfigTagAnyTagRadioButton->Checked &&   //specific type
           ConfigTagAnyTagIDRadioButton->Checked)  //any id
         XBuf[index] = 0x40;  //specific tag type
      else if (!ConfigTagAnyTagRadioButton->Checked &&   //specific type
               !ConfigTagAnyTagIDRadioButton->Checked)   //specific id
         XBuf[index] = 0x80;  //specific tag type, specific tag id
      else if (ConfigTagAnyTagRadioButton->Checked &&  //any type
               ConfigTagAnyTagIDRadioButton->Checked)  //any id
         XBuf[index] = 0x00;  //any tag type, any tag id
      else
      {
         Application->MessageBox("Need Tag Type!",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return (0);
      }*/

      if (!CheckVaildTagType(ConfigTagTypeComboBox->Text))
      {
           Application->MessageBox("Error: Invalid Tag Type (Not defined)",
                                   "Programming Station Information Dialog",
                                   MB_OK | MB_ICONSTOP | MB_TOPMOST);
           ConfigTagBitBtn->Enabled = true;
           return (0);
      }

      int tagTypeVal;
      if (ConfigTagTypeComboBox->Text == "All Types")
      {
         tagTypeVal = 0;
      }
      //if ((tagTypeVal=GetTagTypeValue(ConfigTagTypeComboBox->ItemIndex)) < 0)
      else if ((tagTypeVal=GetIndexTagType(ConfigTagTypeComboBox->Text)) < 0)
      {
          Application->MessageBox("Error in calculating tag type index",
                                   "Programming Station Information Dialog",
                                   MB_OK | MB_ICONSTOP | MB_TOPMOST);
          ConfigTagBitBtn->Enabled = true;
          return (0);
      }
      else
         tagTypeVal += 1;  //add one to the index based zero to get the tye num value

      //CMD + starting address
      if ((ConfigTagTypeComboBox->Text != "All Tags") &&   //specific type
           ConfigTagAnyTagIDRadioButton->Checked)  //any id
         XBuf[index] = 0x40;  //specific tag type
      else if ((ConfigTagTypeComboBox->Text != "All Tags") &&   //specific type
               !ConfigTagAnyTagIDRadioButton->Checked)   //specific id
         XBuf[index] = 0x80;  //specific tag type, specific tag id
      else if ((ConfigTagTypeComboBox->Text == "All Tags") &&  //any type
               ConfigTagAnyTagIDRadioButton->Checked)  //any id
         XBuf[index] = 0x00;  //any tag type, any tag id
      else
      {
         Application->MessageBox("Need Tag Type!",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return (0);
      }

      index += 1;

      //factory Setting --------------------
      if (ConfigTagFactoryIDCheckBox->Checked) //Factory Setting
      {
           XBuf[index] = 0xB0;  //action command address
           index += 1;

           if (ConfigTagTypeComboBox->Text == "All Tags")
              XBuf[index] = 0x00;  //000 0 0000
           else if (ConfigTagTypeComboBox->Text == "Factory")
              XBuf[index] = 0xE0;  //111 0 0000
           else  //all other types
           {
               XBuf[index] = tagTypeVal;

               if (ConfigTagIDRangeRadioButton->Checked)
               {
                   if (ConfigTagIDRangeComboBox->Text.data() == NULL)
                   {
                       Application->MessageBox("Error: Need value for the Range",
                                               "Programming Station Information Dialog",
                                               MB_OK | MB_ICONSTOP | MB_TOPMOST);
                       ConfigTagBitBtn->Enabled = true;
                       return (0);
                    }

                    XBuf[index] |= GetRangeIndex(atoi(ConfigTagIDRangeComboBox->Text.c_str()));
                    XBuf[index] |= 0x10;  //xxx 1 xxxx
               }
               index += 1;

           } //factory - all other types

           /*if (ConfigTagAccessCtrlRadioButton->Checked)  //ACCESS TYPE RANGE
           {
               XBuf[index] = 0x20;  //001 0 0000

               if (ConfigTagIDRangeRadioButton->Checked)
               {
                   if (ConfigTagIDRangeComboBox->Text.data() == NULL)
                   {
                       Application->MessageBox("Error: Need value for the Range",
                                               "Programming Station Information Dialog",
                                               MB_OK | MB_ICONSTOP | MB_TOPMOST);
                       ConfigTagBitBtn->Enabled = true;
                       return (0);
                    }

                    XBuf[index] |= GetRangeIndex(atoi(ConfigTagIDRangeComboBox->Text.c_str()));
                    XBuf[index] |= 0x10;  //xxx 1 xxxx
               }
               index += 1;
           }
           else if (ConfigTagInvetRadioButton->Checked)     //INVENT TYPE RANGE
           {
               XBuf[index] = 0x40;  //010 0 0000
               if (ConfigTagIDRangeRadioButton->Checked)
               {
                   if (ConfigTagIDRangeComboBox->Text.data() == NULL)
                   {
                       Application->MessageBox("Error: Need value for the Range",
                                               "Programming Station Information Dialog",
                                               MB_OK | MB_ICONSTOP | MB_TOPMOST);
                       ConfigTagBitBtn->Enabled = true;
                       return (0);
                    }

                    XBuf[index] |= GetRangeIndex(atoi(ConfigTagIDRangeComboBox->Text.c_str()));
                    XBuf[index] |= 0x10;  //xxx 1 xxxx
                }

                index += 1;
           }//invent
           else if (ConfigTagAssetCtrlRadioButton->Checked)  //ASSET TYPE RANGE
           {
               XBuf[index] = 0x60;  //011 0 0000
               if (ConfigTagIDRangeRadioButton->Checked)
               {
                   if (ConfigTagIDRangeComboBox->Text.data() == NULL)
                   {
                       Application->MessageBox("Error: Need value for the Range",
                                               "Programming Station Information Dialog",
                                               MB_OK | MB_ICONSTOP | MB_TOPMOST);
                       ConfigTagBitBtn->Enabled = true;
                       return (0);
                    }

                    XBuf[index] |= GetRangeIndex(atoi(ConfigTagIDRangeComboBox->Text.c_str()));
                    XBuf[index] |= 0x10;  //xxx 1 xxxx
                }
                index += 1;
           }//Asset  */

           if (ConfigTagAnyTagIDRadioButton->Checked == cbUnchecked)
           {
               __int64  n = ((unsigned long)atol(ConfigTagTagIDEdit->Text.c_str()));
               AnsiString s = IntToHex(n, 8);
               XBuf[index] = HexToInt(s.c_str(), 2);
               index += 1;
               AnsiString s1 = s.SubString(3,2);
               XBuf[index] = HexToInt(s1.c_str(), 2);
               index += 1;
               s1 = s.SubString(5,2);
               XBuf[index] = HexToInt(s1.c_str(), 2);
               s1 = s.SubString(7,2);
               index += 1;
               XBuf[index] = HexToInt(s1.c_str(), 2);
               index += 1;
           }

           XBuf[index] = 0x12;  //action cmd for factory setting
           index += 1;
      }
      else  //no factory setting checked
      {
          XBuf[index] = 0x81;  //starting address
          addrIndex = index;
          index += 1;

         //if (ConfigTagAnyTagRadioButton->Checked == cbUnchecked)   //Specific tag type
          if (ConfigTagTypeComboBox->Text != "All Tags")
          {
               XBuf[index] = (tagTypeVal<<5);

             /*if (ConfigTagAccessCtrlRadioButton->Checked)
                XBuf[index] = 0x20;  //001 0 0000
             else if (ConfigTagInvetRadioButton->Checked)
                XBuf[index] = 0x40;  //010 0 0000
             else if (ConfigTagAssetCtrlRadioButton->Checked)
                XBuf[index] = 0x60;  //011 0 0000
             else if (ConfigTagFactoryRadioButton->Checked)
                XBuf[index] = 0xE0;  //111 0 0000*/



             if (ConfigTagIDRangeRadioButton->Checked)
             {
                  if (ConfigTagIDRangeComboBox->Text.data() == NULL)
                  {
                      Application->MessageBox("Error: Need value for the Range",
                                              "Programming Station Information Dialog",
                                              MB_OK | MB_ICONSTOP | MB_TOPMOST);
                      ConfigTagBitBtn->Enabled = true;
                      return (0);
                  }

                  XBuf[index] |= GetRangeIndex(atoi(ConfigTagIDRangeComboBox->Text.c_str()));
                  XBuf[index] |= 0x10;  //xxx 1 xxxx
             }
             else
             {
                 if (ConfigTagModifyRNCheckBox->Checked)
                 {
                     if (ConfigTagRNLongRadioButton->Checked)
                        XBuf[index] |= 0x01;  //long  0000 00 01
                     else
                        XBuf[index] |= 0x00;  //short 0000 00 00
                  }
              }

              oldTagType = XBuf[index];
              index += 1;
              configIndex = index;
         }
         else   //Any tag type
         {
             XBuf[index] = 0x00;
             oldTagType = 0x00;
             index += 1;
             configIndex = index;
          }

          if ((ConfigTagAnyTagIDRadioButton->Checked == cbUnchecked) ||   //Specific TAG ID
              ConfigTagIDRangeRadioButton->Checked)
          {
              __int64  n = ((unsigned long)atol(ConfigTagTagIDEdit->Text.c_str()));
              AnsiString s = IntToHex(n, 8);
              oldTagID = s;
              XBuf[index] = HexToInt(s.c_str(), 2);
              index += 1;
              AnsiString s1 = s.SubString(3,2);
              XBuf[index] = HexToInt(s1.c_str(), 2);
              index += 1;
              s1 = s.SubString(5,2);
              XBuf[index] = HexToInt(s1.c_str(), 2);
              s1 = s.SubString(7,2);
              index += 1;
              XBuf[index] = HexToInt(s1.c_str(), 2);
              index += 1;
              configIndex = index;
          }

          //config data -------------------------------------------------

          if (chgCount >= 2)
          {
              if ((cByte == 0x05) || (cByte == 0x09) || (cByte == 0x0A) ||
                  (cByte == 0x0B) || (cByte == 0x0D))
              doGetConfig = true;
           }


           //New Tag Type ----------------
           if (ConfigTagNewTagTypeCheckBox->Checked)
           {
                /*if (ConfigTagNewAccessRadioButton->Checked)   //access
                {
                   newTagType = 0x20;   //001 0 0000
                   XBuf[index] = 0x20;
                }
                else if (ConfigTagNewInventRadioButton->Checked)  //inventory
                {
                    newTagType = 0x40;   //010 0 0000
                    XBuf[index] = 0x40;
                }
                else if (ConfigTagNewAssetRadioButton->Checked)   //asset
                {
                    newTagType = 0x60;   //011 0 0000
                    XBuf[index] = 0x60;
                }*/
                int typeVal = 0;
                //if ((typeVal=GetTagTypeValue(ConfigTagNewTagTypeComboBox->ItemIndex)) < 0)
                if ((typeVal=GetIndexTagType(ConfigTagNewTagTypeComboBox->Text)) < 0)
                {
                    Application->MessageBox("Error in calculating tag type index",
                                             "Programming Station Information Dialog",
                                             MB_OK | MB_ICONSTOP | MB_TOPMOST);
                    ConfigTagBitBtn->Enabled = true;
                    return (0);
                }
                else
                   typeVal += 1;


                //newTagType = typeVal;
                XBuf[index] = (typeVal<<5);
                newTagType = (typeVal<<5);

                XXBuf[index01] = XBuf[index];
                //index01 += 1;
           }
           else
              newTagType = oldTagType;

           //tamper switch -------------------
           if (ConfigTagModifyTamperCheckBox->Checked)
           {
                if (ConfigTagReportStatusRadioButton->Checked)
                {
                    newTagType |= 0x18;      //report status 000 11 000
                }
                else if (ConfigTagReportHistoryRadioButton->Checked)
                {
                    newTagType |= 0x10;      //report history 000 10 000
                    newTagType &= 0xF7;      //               111 10 111
                }
                else
                {
                    newTagType |= 0x08;    //don't report  000 01 000
                    newTagType &= 0xEF;    //              111 01 111
                }

                XBuf[index] = newTagType;

                if (ConfigTagNewTagTypeCheckBox->Checked)
                {
                    XXBuf[index01] |= XBuf[index];
                }
                else
                {
                    XXBuf[index01] = XBuf[index];
                   //index01 += 1;
                }
           }

           //RA/RN -----------------------
           if (ConfigTagModifyRNCheckBox->Checked)
           {
                newTagType |= 0x00;  //0000 000 0   short
                if (ConfigTagRNLongRadioButton->Checked)
                    newTagType |= 0x01;  //long   //0000 000 1  long

                XBuf[index] = newTagType;

                if (ConfigTagModifyTamperCheckBox->Checked)
                {
                    XXBuf[index01] |= XBuf[index];
                }
                else
                {
                    XXBuf[index01] = XBuf[index];
                    //index01 += 1;
                }
           }

           if ((ConfigTagModifyRNCheckBox->Checked) ||
               (ConfigTagNewTagTypeCheckBox->Checked) ||
               (ConfigTagModifyTamperCheckBox->Checked))
                index01 += 1;


           //New Tag ID ----------------
           if (ConfigTagNewTagIDCheckBox->Checked)  //NEW TAG ID
           {
                __int64  n = ((unsigned long)atol(ConfigTagNewIDEdit->Text.c_str()));
                newTagID = IntToHex(n, 8);

                XBuf[index] = HexToInt(newTagID.c_str(), 2);   //tag ID
                XXBuf[index01] = XBuf[index];
                index01 += 1;

                AnsiString s1 = newTagID.SubString(3,2);
                index += 1;
                XBuf[index] = HexToInt(s1.c_str(), 2);
                XXBuf[index01] = XBuf[index];
                index01 += 1;

                s1 = newTagID.SubString(5,2);
                index += 1;
                XBuf[index] = HexToInt(s1.c_str(), 2);
                XXBuf[index01] = XBuf[index];
                index01 += 1;

                s1 = newTagID.SubString(7,2);
                index += 1;
                XBuf[index] = HexToInt(s1.c_str(), 2);
                XXBuf[index01] = XBuf[index];
                index01 += 1;
           }
           else
                newTagID = oldTagID;

          // TIF ----------------------------
          if (ConfigTagTIFCheckBox->Checked)
          {
             XBuf[index] = (GetTimeTIF() << 4);
             XBuf[index] |= GetGC();

             XXBuf[index01] = XBuf[index];
             index01 += 1;
          }

          //Time in the field (TIF) --------------
          if ((chgCount > 1) && doGetConfig)
          {
              if (ConfigTagTIFComboBox->Text.data() == NULL)
              {
                 Application->MessageBox("ERROR TIF: No value. Click on 'Get Tag Configuration' button",
                                         "Programming Station Information Dialog", MB_OK );
                 ConfigTagBitBtn->Enabled = true;
                 return (0);
              }
              else
              {
                 if (GetTimeTIF() == -1)
                 {
                    Application->MessageBox("ERROR TIF: Value should match one of the values in the list.",
                                            "Programming Station Information Dialog", MB_OK );
                    ConfigTagBitBtn->Enabled = true;
                    return (0);
                 }

                 tifGcValue |= (GetTimeTIF() << 4);
              }
          }

          // Group Count (GC)  ------------------
          if ((chgCount > 1) && doGetConfig)
          {
              if (ConfigTagGCComboBox->Text.data() == NULL)
              {
                 Application->MessageBox("ERROR GC: No value. Click on 'Get Tag Configuration' button",
                                         "Programming Station Information Dialog", MB_OK );
                 ConfigTagBitBtn->Enabled = true;
                 return (0);
              }
              else
              {
                 if (GetGC() == -1)
                 {
                       Application->MessageBox("ERROR GC: Value should match one of the values in the list.",
                                               "Programming Station Information Dialog", MB_OK );
                       ConfigTagBitBtn->Enabled = true;
                       return (0);
                 }

                 tifGcValue |= GetGC();
              }
          }

          // Resend Time -------------------
          AnsiString str;
          //AnsiString TimePeriodStr;
          int TimePeriodInt;

          if ((chgCount > 1) && doGetConfig)
          {
             TimePeriodInt = GetTimePeriod();
             TimePeriodStr =  IntToHex(TimePeriodInt, 4);
             char buf[3];  //Resend Time
             str = TimePeriodStr.SubString(3, 2);
             strcpy(buf, (char*)str.data());
             TimePeriod[1] = HexToInt(buf, 2);
             str = TimePeriodStr.SubString(1, 2);
             strcpy(buf, (char*)str.data());
             TimePeriod[0] = HexToInt(buf, 2);
          }

          if (ConfigTagEnableTimeCheckBox->Checked)    //RESEND TIME
          {
             TimePeriodInt = GetTimePeriod();
             TimePeriodStr =  IntToHex(TimePeriodInt, 4);
             char buf[3];  //Resend Time
             str = TimePeriodStr.SubString(3, 2);
             strcpy(buf, (char*)str.data());
             TimePeriod[1] = HexToInt(buf, 2);
             str = TimePeriodStr.SubString(1, 2);
             strcpy(buf, (char*)str.data());
             TimePeriod[0] = HexToInt(buf, 2);
             XBuf[index] = TimePeriod[0];
             XXBuf[index01] = XBuf[index];
             index01 += 1;
             index += 1;
             XBuf[index] = TimePeriod[1];
             XXBuf[index01] = XBuf[index];
             index01 += 1;
          }

          if ((chgCount > 1) && doGetConfig)
          {
              if (ConfigTagDurationComboBox->Text.data() == NULL)
              {
                 Application->MessageBox("ERROR Resend Time: No value. Click on 'Get Tag Configuration' button",
                                         "Programming Station Information Dialog", MB_OK );
                 ConfigTagBitBtn->Enabled = true;
                 return (0);
              }
              else
              {

                 if (TimePeriodInt == -1)
                 {
                    Application->MessageBox("Error: No value for Resend Time is Selected!",
                                            "Programming Station Information Dialog",
                                            MB_OK | MB_ICONSTOP | MB_TOPMOST);
                    ConfigTagBitBtn->Enabled = true;
                    return (0);
                 }
                 //else
                 //{
                    //TimePeriodStr =  IntToHex(TimePeriodInt, 4);
                 //}
              }
          }

          if (chgCount == 0)
          {
             return(0);
          }
          else if (chgCount == 1)
          {
              XBuf[addrIndex] = startAddr;
              index += 1;
          }
          else   //chgCount > 1
          {
             index = configIndex;
             if (doGetConfig)
             {
                XBuf[index] = newTagType;    //tag type
                index += 1;

                XBuf[index] = HexToInt(newTagID.c_str(), 2);   //tag ID
                index += 1;
                AnsiString s1 = newTagID.SubString(3,2);
                XBuf[index] = HexToInt(s1.c_str(), 2);
                index += 1;
                s1 = newTagID.SubString(5,2);
                XBuf[index] = HexToInt(s1.c_str(), 2);
                s1 = newTagID.SubString(7,2);
                index += 1;
                XBuf[index] = HexToInt(s1.c_str(), 2);
                index += 1;

                XBuf[index] = tifGcValue;   //TIF & GC
                index += 1;

                //char buf[3];  //Resend Time
                //str = TimePeriodStr.SubString(3, 2);
                //strcpy(buf, (char*)str.data());
                //TimePeriod[1] = HexToInt(buf, 2);
                //str = TimePeriodStr.SubString(1, 2);
                //strcpy(buf, (char*)str.data());
                //TimePeriod[0] = HexToInt(buf, 2);
                XBuf[index] = TimePeriod[0];   //Resend Time
                index += 1;
                XBuf[index] = TimePeriod[1];
                index += 1;
             }
             else  //contineous multiple param addr
             {
                for (int i=configIndex, j=0; i<configIndex+index01; i++, j++)
                   XBuf[i] = XXBuf[j];
                index += index01;
                XBuf[addrIndex] = mulStartAddr;
             }
          }

      } // if not factory setting

      XBuf[index] = WRITE_CONFIG_TAG_MEMORY;   //pktid
      index += 1;
      XBuf[2] = index - 3;   //Len

      TxCommandLabel->Caption = "Write Tag Configuration";

      if (ConfigTagReaderIDComboBox->Text.data() != NULL)
         TxReaderIDLabel->Caption = ConfigTagReaderIDComboBox->Text;
      else
         TxReaderIDLabel->Caption = "";

      TxCommandLabel->Caption = "Configure Tag";

   } //config tag
   else if (Command == ENABLE_TAG)  //0x07
   {
      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0x07;           //command
      if (EnableTagHostIDEdit->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Host ID!",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         EnableTagBitBtn->Enabled = true;
         return (0);
      }

      if (EnableTagBroadcastRdrCheckBox->Checked)
      {
         rdrID = 0x00;  //broadcast

         //if (EnableTagIDComboBox->Text.data() == NULL)
         //{
           //Application->MessageBox("Error: Need Reader ID",
                                   //"Programming Station Information Dialog",
                                   //MB_OK | MB_ICONSTOP | MB_TOPMOST);
           //EnableTagBitBtn->Enabled = true;
           //return (0);
         //}
      }
      else if (EnableTagIDComboBox->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Reader ID",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         EnableTagBitBtn->Enabled = true;
         return (0);
      }
      else
         rdrID = atoi(EnableTagIDComboBox->Text.c_str());

      if (rdrID <= 255)  //reg reader
      {
            initLen = 4;
            XBuf[3] = 0x0A;      //00 001 110
            XBuf[4] = atoi(EnableTagHostIDEdit->Text.c_str());   //host ID
            XBuf[5] = rdrID;  //reader ID
            index = 5;   //initial index

            int tagTypeVal = 0;

            if (EnableTagTypeComboBox->Text == "All Types")
            {
               tagTypeVal = -1;   //one will be added later
            }
            else if (EnableTagTypeComboBox->Text == "Factory")
            {
               tagTypeVal = 6;   //one will be added later
            }
            else if ((tagTypeVal=GetIndexTagType(EnableTagTypeComboBox->Text)) < 0)
            {
                Application->MessageBox("Error in calculating tag type index",
                                         "Programming Station Information Dialog",
                                         MB_OK | MB_ICONSTOP | MB_TOPMOST);
                EnableTagBitBtn->Enabled = true;
                return (0);
            }

           tagTypeVal += 1;
           XBuf[6] = (tagTypeVal << 5);
           initLen += 1;
           index += 1;

           if (EnableTagIDRangeRadioButton->Checked)
           {
               if (EnableTagIDRangeComboBox->Text.data() == NULL)
               {
                   Application->MessageBox("Error: Need value for the Range",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   EnableTagBitBtn->Enabled = true;
                   return (0);
               }
               XBuf[6] |= GetRangeIndex(atoi(EnableTagIDRangeComboBox->Text.c_str()));
               XBuf[6] |= 0x10;  //xxx 1 xxxx
          }
          else
          {
              if (EnableTagRNLongRadioButton->Checked)
                 XBuf[6] |= 0x01; //0000 0001    //long
              else
                 XBuf[6] &= 0xFE; //1111 1110    //short

              if (EnableTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                 XBuf[6] |= 0x04;    //0000 0100

              if (EnableTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                 XBuf[6] |= 0x08;    //0000 1000
           }

            /*if (EnableTagAssRadioButton->Checked)
            {
               XBuf[6] = 0x60; //011 0 0000
               initLen += 1;
               index += 1;

               if (EnableTagIDRangeRadioButton->Checked)
               {
                  if (EnableTagIDRangeComboBox->Text.data() == NULL)
                  {
                      Application->MessageBox("Error: Need value for the Range",
                                              "Programming Station Information Dialog",
                                              MB_OK | MB_ICONSTOP | MB_TOPMOST);
                      EnableTagBitBtn->Enabled = true;
                      return (0);
                  }

                  XBuf[6] |= GetRangeIndex(atoi(EnableTagIDRangeComboBox->Text.c_str()));
                  XBuf[6] |= 0x10;  //xxx 1 xxxx
               }
               else
               {
                   if (EnableTagRNLongRadioButton->Checked)
                      XBuf[6] |= 0x01; //0000 0001    //long
                   else
                      XBuf[6] &= 0xFE; //1111 1110    //short

                   if (EnableTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                      XBuf[6] |= 0x04;    //0000 0100

                   if (EnableTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                      XBuf[6] |= 0x08;    //0000 1000
               }
            }
            else if (EnableTagAccRadioButton->Checked)
            {
               XBuf[6] = 0x20; //001 0 0000
               initLen += 1;
               index += 1;

               if (EnableTagIDRangeRadioButton->Checked)
               {
                  if (EnableTagIDRangeComboBox->Text.data() == NULL)
                  {
                      Application->MessageBox("Error: Need value for the Range",
                                              "Programming Station Information Dialog",
                                              MB_OK | MB_ICONSTOP | MB_TOPMOST);
                      EnableTagBitBtn->Enabled = true;
                      return (0);
                  }

                  XBuf[6] |= GetRangeIndex(atoi(EnableTagIDRangeComboBox->Text.c_str()));
                  XBuf[6] |= 0x10;  //xxx 1 xxxx
               }
               else
               {
                   if (EnableTagRNLongRadioButton->Checked)
                      XBuf[6] |= 0x01; //0000 0001    //long
                   else
                      XBuf[6] &= 0xFE; //1111 1110    //short

                   if (EnableTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                      XBuf[6] |= 0x04;    //0000 0100

                   if (EnableTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                      XBuf[6] |= 0x08;    //0000 1000
               }
            }
            else if (EnableTagInvRadioButton->Checked)  //inventory
            {
               XBuf[6] = 0x40; //010 0 0000
               initLen += 1;
               index += 1;

               if (EnableTagIDRangeRadioButton->Checked)
               {
                  if (EnableTagIDRangeComboBox->Text.data() == NULL)
                  {
                      Application->MessageBox("Error: Need value for the Range",
                                              "Programming Station Information Dialog",
                                              MB_OK | MB_ICONSTOP | MB_TOPMOST);
                      EnableTagBitBtn->Enabled = true;
                      return (0);
                  }

                  XBuf[6] |= GetRangeIndex(atoi(EnableTagIDRangeComboBox->Text.c_str()));
                  XBuf[6] |= 0x10;  //xxx 1 xxxx
               }
               else
               {
                   if (EnableTagRNLongRadioButton->Checked)
                      XBuf[6] |= 0x01; //0000 0001    //long
                   else
                      XBuf[6] &= 0xFE; //1111 1110    //short

                   if (EnableTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                      XBuf[6] |= 0x04;    //0000 0100

                   if (EnableTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                      XBuf[6] |= 0x08;    //0000 1000
               }
            }
            else if (EnableTagInvRadioButton->Checked)  //factory
            {
               XBuf[6] = 0xE0; //111 0 0000
               initLen += 1;
               index += 1;

               if (EnableTagIDRangeRadioButton->Checked)
               {
                  if (EnableTagIDRangeComboBox->Text.data() == NULL)
                  {
                      Application->MessageBox("Error: Need value for the Range",
                                              "Programming Station Information Dialog",
                                              MB_OK | MB_ICONSTOP | MB_TOPMOST);
                      EnableTagBitBtn->Enabled = true;
                      return (0);
                  }

                  XBuf[6] |= GetRangeIndex(atoi(EnableTagIDRangeComboBox->Text.c_str()));
                  XBuf[6] |= 0x10;  //xxx 1 xxxx
               }
               else
               {
                   if (EnableTagRNLongRadioButton->Checked)
                      XBuf[6] |= 0x01; //0000 0001    //long
                   else
                      XBuf[6] &= 0xFE; //1111 1110    //short

                   if (EnableTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                      XBuf[6] |= 0x04;    //0000 0100

                   if (EnableTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                      XBuf[6] |= 0x08;    //0000 1000
               }
            }
            else //any tag type
            {
               XBuf[6] = 0x00; //000 0 0000
               initLen += 1;
               index += 1;

               if (EnableTagIDRangeRadioButton->Checked)
               {
                  if (EnableTagIDRangeComboBox->Text.data() == NULL)
                  {
                      Application->MessageBox("Error: Need value for the Range",
                                              "Programming Station Information Dialog",
                                              MB_OK | MB_ICONSTOP | MB_TOPMOST);
                      EnableTagBitBtn->Enabled = true;
                      return (0);
                  }

                  XBuf[6] |= GetRangeIndex(atoi(EnableTagIDRangeComboBox->Text.c_str()));
                  XBuf[6] |= 0x10;  //xxx 1 xxxx
               }
               else
               {
                  if (EnableTagRNLongRadioButton->Checked)
                     XBuf[6] |= 0x01; //0000 0001    //long
                  else
                     XBuf[6] &= 0xFE; //1111 1110    //short

                  if (EnableTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                     XBuf[6] |= 0x04;    //0000 0100

                  if (EnableTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                     XBuf[6] |= 0x08;    //0000 1000
               }
            }
            */

            if ((EnableTagIDRadioButton->Checked) || (EnableTagIDRangeRadioButton->Checked))
            {
                if (EnableTagIDEdit->Text.data() == NULL)
                {
                   Application->MessageBox("Error: Need Tag ID",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   EnableTagBitBtn->Enabled = true;
                   return (0);
                }

                index += 1;
                __int64  n = ((unsigned long)atol(EnableTagIDEdit->Text.c_str()));
                AnsiString s = IntToHex(n, 8);
                XBuf[index] = HexToInt(s.c_str(), 2);
                //if (CarRadioButton->Checked)
                   //XBuf[index] |= 0x80;  //set msb to high for car type
                index += 1;
                AnsiString s1 = s.SubString(3,2);
                XBuf[index] = HexToInt(s1.c_str(), 2);
                index += 1;
                s1 = s.SubString(5,2);
                XBuf[index] = HexToInt(s1.c_str(), 2);
                s1 = s.SubString(7,2);
                index += 1;
                XBuf[index] = HexToInt(s1.c_str(), 2);
                initLen += 4;
                progStr += " ID = ";
                progStr += n;
                StaticText->Caption = progStr;
                TxTagIDLabel->Caption = EnableTagIDEdit->Text; //nID;
            }
            else
               TxTagIDLabel->Caption = "Broadcasting";

            XBuf[2] = initLen;   //len
            index += 1;
            XBuf[index] = 0xA1;  //pktid
            index += 1;

            //TxTagIDLabel->Caption = NewIDEdit->Text; //nID;
            TxTagTimeLabel->Caption = "";
      }
      else    //extended
      {
            initLen = 5;
            XBuf[3] = 0x0E;      //00 001 110
            XBuf[4] = atoi(EnableTagHostIDEdit->Text.c_str());   //host ID
            AnsiString str = IntToHex(rdrID, 4);
            XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
            str = str.SubString(3,2);
            XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
            index = 6;   //initial index

            int tagTypeVal = 0;

            if (EnableTagTypeComboBox->Text == "All Types")
            {
               tagTypeVal = -1;   //one will be added later
            }
            else if (EnableTagTypeComboBox->Text == "Factory")
            {
               tagTypeVal = 6;   //one will be added later
            }
            else if ((tagTypeVal=GetIndexTagType(EnableTagTypeComboBox->Text)) < 0)
            {
                Application->MessageBox("Error in calculating tag type index",
                                         "Programming Station Information Dialog",
                                         MB_OK | MB_ICONSTOP | MB_TOPMOST);
                EnableTagBitBtn->Enabled = true;
                return (0);
            }

           tagTypeVal += 1;
           XBuf[7] = (tagTypeVal << 5);
           initLen += 1;
           index += 1;

           if (EnableTagIDRangeRadioButton->Checked)
           {
               if (EnableTagIDRangeComboBox->Text.data() == NULL)
               {
                   Application->MessageBox("Error: Need value for the Range",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   EnableTagBitBtn->Enabled = true;
                   return (0);
               }
               XBuf[7] |= GetRangeIndex(atoi(EnableTagIDRangeComboBox->Text.c_str()));
               XBuf[7] |= 0x10;  //xxx 1 xxxx
          }
          else
          {
              if (EnableTagRNLongRadioButton->Checked)
                 XBuf[7] |= 0x01; //0000 0001    //long
              else
                 XBuf[7] &= 0xFE; //1111 1110    //short

              if (EnableTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                 XBuf[7] |= 0x04;    //0000 0100

              if (EnableTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                 XBuf[7] |= 0x08;    //0000 1000
           }

            /*if (EnableTagInvRadioButton->Checked)
            {
               XBuf[7] = 0x40; //010 0 0000
               initLen += 1;
               index += 1;

               if (EnableTagIDRangeRadioButton->Checked)
               {
                  if (EnableTagIDRangeComboBox->Text.data() == NULL)
                  {
                      Application->MessageBox("Error: Need value for the Range",
                                              "Programming Station Information Dialog",
                                              MB_OK | MB_ICONSTOP | MB_TOPMOST);
                      EnableTagBitBtn->Enabled = true;
                      return (0);
                  }

                  XBuf[7] |= GetRangeIndex(atoi(EnableTagIDRangeComboBox->Text.c_str()));
                  XBuf[7] |= 0x10;  //xxx 1 xxxx
               }
               else
               {
                   if (EnableTagRNLongRadioButton->Checked)
                      XBuf[7] |= 0x01; //0000 0001    //long
                   else
                      XBuf[7] &= 0xFE; //1111 1110    //short

                   if (EnableTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                      XBuf[7] |= 0x04;    //0000 0100

                   if (EnableTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                      XBuf[7] |= 0x08;    //0000 1000
               }
            }
            else if (EnableTagAccRadioButton->Checked)
            {
               XBuf[7] = 0x20; //001 0 0000
               initLen += 1;
               index += 1;

               if (EnableTagIDRangeRadioButton->Checked)
               {
                  if (EnableTagIDRangeComboBox->Text.data() == NULL)
                  {
                      Application->MessageBox("Error: Need value for the Range",
                                              "Programming Station Information Dialog",
                                              MB_OK | MB_ICONSTOP | MB_TOPMOST);
                      EnableTagBitBtn->Enabled = true;
                      return (0);
                  }

                  XBuf[7] |= GetRangeIndex(atoi(EnableTagIDRangeComboBox->Text.c_str()));
                  XBuf[7] |= 0x10;  //xxx 1 xxxx
               }
               else
               {
                   if (EnableTagRNLongRadioButton->Checked)
                      XBuf[7] |= 0x01; //0000 0001    //long
                   else
                      XBuf[7] &= 0xFE; //1111 1110    //short

                   if (EnableTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                      XBuf[7] |= 0x04;    //0000 0100

                   if (EnableTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                      XBuf[7] |= 0x08;    //0000 1000
               }
            }
            else if (EnableTagAssRadioButton->Checked)
            {
               XBuf[7] = 0x60; //011 0 0000
               initLen += 1;
               index += 1;

               if (EnableTagIDRangeRadioButton->Checked)
               {
                  if (EnableTagIDRangeComboBox->Text.data() == NULL)
                  {
                      Application->MessageBox("Error: Need value for the Range",
                                              "Programming Station Information Dialog",
                                              MB_OK | MB_ICONSTOP | MB_TOPMOST);
                      EnableTagBitBtn->Enabled = true;
                      return (0);
                  }

                  XBuf[7] |= GetRangeIndex(atoi(EnableTagIDRangeComboBox->Text.c_str()));
                  XBuf[7] |= 0x10;  //xxx 1 xxxx
               }
               else
               {
                   if (EnableTagRNLongRadioButton->Checked)
                      XBuf[7] |= 0x01; //0000 0001    //long
                   else
                      XBuf[7] &= 0xFE; //1111 1110    //short

                   if (EnableTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                      XBuf[7] |= 0x04;    //0000 0100

                   if (EnableTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                      XBuf[7] |= 0x08;    //0000 1000
               }
            }
            else if (EnableTagFactoryRadioButton->Checked)  //factory
            {
               XBuf[7] = 0xE0; //111 0 0000
               initLen += 1;
               index += 1;

               if (EnableTagIDRangeRadioButton->Checked)
               {
                  if (EnableTagIDRangeComboBox->Text.data() == NULL)
                  {
                      Application->MessageBox("Error: Need value for the Range",
                                              "Programming Station Information Dialog",
                                              MB_OK | MB_ICONSTOP | MB_TOPMOST);
                      EnableTagBitBtn->Enabled = true;
                      return (0);
                  }

                  XBuf[7] |= GetRangeIndex(atoi(EnableTagIDRangeComboBox->Text.c_str()));
                  XBuf[7] |= 0x10;  //xxx 1 xxxx
               }
               else
               {
                   if (EnableTagRNLongRadioButton->Checked)
                      XBuf[7] |= 0x01; //0000 0001    //long
                   else
                      XBuf[7] &= 0xFE; //1111 1110    //short

                   if (EnableTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                      XBuf[7] |= 0x04;    //0000 0100

                   if (EnableTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                      XBuf[7] |= 0x08;    //0000 1000
               }
            }
            else //any tag type
            {
               XBuf[7] = 0x00; //000 0 0000
               initLen += 1;
               index += 1;

               if (EnableTagIDRangeRadioButton->Checked)
               {
                  if (EnableTagIDRangeComboBox->Text.data() == NULL)
                  {
                      Application->MessageBox("Error: Need value for the Range",
                                              "Programming Station Information Dialog",
                                              MB_OK | MB_ICONSTOP | MB_TOPMOST);
                      EnableTagBitBtn->Enabled = true;
                      return (0);
                  }

                  XBuf[7] |= GetRangeIndex(atoi(EnableTagIDRangeComboBox->Text.c_str()));
                  XBuf[7] |= 0x10;  //xxx 1 xxxx
               }
               else
               {
                   if (EnableTagRNLongRadioButton->Checked)
                      XBuf[7] |= 0x01; //0000 0001    //long
                   else
                      XBuf[7] &= 0xFE; //1111 1110    //short

                   if (EnableTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                      XBuf[7] |= 0x04;    //0000 0100

                   if (EnableTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                      XBuf[7] |= 0x08;    //0000 1000
               }
            }*/


            if ((EnableTagIDRadioButton->Checked) || (EnableTagIDRangeRadioButton->Checked))
            {
                if (EnableTagIDEdit->Text.data() == NULL)
                {
                   Application->MessageBox("Error: Need Tag ID!",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   EnableTagBitBtn->Enabled = true;
                   return (0);
                }

                index += 1;
                __int64  n = ((unsigned long)atol(EnableTagIDEdit->Text.c_str()));
                AnsiString s = IntToHex(n, 8);
                XBuf[index] = HexToInt(s.c_str(), 2);
                //if (CarRadioButton->Checked)
                   //XBuf[index] |= 0x80;  //set msb to high for car type
                index += 1;
                AnsiString s1 = s.SubString(3,2);
                XBuf[index] = HexToInt(s1.c_str(), 2);
                index += 1;
                s1 = s.SubString(5,2);
                XBuf[index] = HexToInt(s1.c_str(), 2);
                s1 = s.SubString(7,2);
                index += 1;
                XBuf[index] = HexToInt(s1.c_str(), 2);
                initLen += 4;
                progStr += " ID = ";
                progStr += n;
                StaticText->Caption = progStr;
                TxTagIDLabel->Caption = n;
            }
            else
                TxTagIDLabel->Caption = "Broadcasting";


            XBuf[2] = initLen;   //len
            index += 1;
            XBuf[index] = 0xA1;  //pktid
            index += 1;

            //TxTagIDLabel->Caption = NewIDEdit->Text; //nID;
            TxTagTimeLabel->Caption = "";

      } //extended


      if (EnableTagIDComboBox->Text.data() != NULL)
         TxReaderIDLabel->Caption = EnableTagIDComboBox->Text;
      else
         TxReaderIDLabel->Caption = "";
      TxCommandLabel->Caption = "Enable Tag";
      TxTagTypeLabel->Caption = tagTypeStr;
   }
   else if (Command == DISABLE_TAG)  //0x08
   {
      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0x08;           //command
      if (DisableTagHostIDEdit->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Host ID!",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         DisableTagBitBtn->Enabled = true;
         return (0);
      }

      if (!DisableTagBroadcastRdrCheckBox->Checked)
      {
         if (DisableTagIDComboBox->Text.data() == NULL)
         {
           Application->MessageBox("Error: Need Reader ID",
                                   "Programming Station Information Dialog",
                                   MB_OK | MB_ICONSTOP | MB_TOPMOST);
           DisableTagBitBtn->Enabled = true;
           return (0);
         }
      }

      rdrID = atoi(DisableTagIDComboBox->Text.c_str());
      if (rdrID <= 255)  //reg reader
      {
            initLen = 4;
            XBuf[3] = 0x0A;      //00 001 110
            XBuf[4] = atoi(DisableTagHostIDEdit->Text.c_str());   //host ID
            XBuf[5] = rdrID;  //reader ID
            index = 5;   //initial index

            int tagTypeVal = 0;

            if (DisableTagTypeComboBox->Text == "All Types")
            {
               tagTypeVal = -1;   //one will be added later
            }
            else if (DisableTagTypeComboBox->Text == "Factory")
            {
               tagTypeVal = 6;   //one will be added later
            }
            else if ((tagTypeVal=GetIndexTagType(DisableTagTypeComboBox->Text)) < 0)
            {
                Application->MessageBox("Error in calculating tag type index",
                                         "Programming Station Information Dialog",
                                         MB_OK | MB_ICONSTOP | MB_TOPMOST);
                DisableTagBitBtn->Enabled = true;
                return (0);
            }

           tagTypeVal += 1;
           XBuf[6] = (tagTypeVal << 5);
           initLen += 1;
           index += 1;

           if (DisableTagIDRangeRadioButton->Checked)
           {
               if (DisableTagIDRangeComboBox->Text.data() == NULL)
               {
                   Application->MessageBox("Error: Need value for the Range",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   DisableTagBitBtn->Enabled = true;
                   return (0);
               }
               XBuf[6] |= GetRangeIndex(atoi(DisableTagIDRangeComboBox->Text.c_str()));
               XBuf[6] |= 0x10;  //xxx 1 xxxx
          }
          else
          {
              if (DisableTagRNLongRadioButton->Checked)
                 XBuf[6] |= 0x01; //0000 0001    //long
              else
                 XBuf[6] &= 0xFE; //1111 1110    //short

              if (DisableTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                 XBuf[6] |= 0x04;    //0000 0100

              if (DisableTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                 XBuf[6] |= 0x08;    //0000 1000
           }

            /*if (DisableTagAssRadioButton->Checked)
            {
               XBuf[6] = 0x60; //011 0 0000
               initLen += 1;
               index += 1;

               if (DisableTagIDRangeRadioButton->Checked)
               {
                  if (DisableTagIDRangeComboBox->Text.data() == NULL)
                  {
                      Application->MessageBox("Error: Need value for the Range",
                                              "Programming Station Information Dialog",
                                              MB_OK | MB_ICONSTOP | MB_TOPMOST);
                      DisableTagBitBtn->Enabled = true;
                      return (0);
                  }

                  XBuf[6] |= GetRangeIndex(atoi(DisableTagIDRangeComboBox->Text.c_str()));
                  XBuf[6] |= 0x10;  //xxx 1 xxxx
               }
               else
               {
                  if (DisableTagRNLongRadioButton->Checked)
                     XBuf[6] |= 0x01; //0000 0001    //long
                  else
                     XBuf[6] &= 0xFE; //1111 1110    //short

                  if (DisableTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                     XBuf[6] |= 0x04;    //0000 0100

                  if (DisableTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                     XBuf[6] |= 0x08;    //0000 1000
               }
            }
            else if (DisableTagAccRadioButton->Checked)
            {
               XBuf[6] = 0x20; //001 0 0000
               initLen += 1;
               index += 1;

               if (DisableTagIDRangeRadioButton->Checked)
               {
                  if (DisableTagIDRangeComboBox->Text.data() == NULL)
                  {
                      Application->MessageBox("Error: Need value for the Range",
                                              "Programming Station Information Dialog",
                                              MB_OK | MB_ICONSTOP | MB_TOPMOST);
                      DisableTagBitBtn->Enabled = true;
                      return (0);
                  }

                  XBuf[6] |= GetRangeIndex(atoi(DisableTagIDRangeComboBox->Text.c_str()));
                  XBuf[6] |= 0x10;  //xxx 1 xxxx
               }
               else
               {
                  if (DisableTagRNLongRadioButton->Checked)
                     XBuf[6] |= 0x01; //0000 0001    //long
                  else
                     XBuf[6] &= 0xFE; //1111 1110    //short

                  if (DisableTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                     XBuf[6] |= 0x04;    //0000 0100

                  if (DisableTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                     XBuf[6] |= 0x08;    //0000 1000
               }
            }
            else if (DisableTagInvRadioButton->Checked)   //inventory
            {
               XBuf[6] = 0x40; //010 0 0000
               initLen += 1;
               index += 1;

               if (DisableTagIDRangeRadioButton->Checked)
               {
                  if (DisableTagIDRangeComboBox->Text.data() == NULL)
                  {
                      Application->MessageBox("Error: Need value for the Range",
                                              "Programming Station Information Dialog",
                                              MB_OK | MB_ICONSTOP | MB_TOPMOST);
                      DisableTagBitBtn->Enabled = true;
                      return (0);
                  }

                  XBuf[6] |= GetRangeIndex(atoi(DisableTagIDRangeComboBox->Text.c_str()));
                  XBuf[6] |= 0x10;  //xxx 1 xxxx
               }
               else
               {
                  if (DisableTagRNLongRadioButton->Checked)
                     XBuf[6] |= 0x01; //0000 0001    //long
                  else
                     XBuf[6] &= 0xFE; //1111 1110    //short

                  if (DisableTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                     XBuf[6] |= 0x04;    //0000 0100

                  if (DisableTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                     XBuf[6] |= 0x08;    //0000 1000
               }
            }
            else if (DisableTagFactoryRadioButton->Checked)  //factory
            {
               XBuf[6] = 0xE0; //111 0 0000
               initLen += 1;
               index += 1;

               if (DisableTagIDRangeRadioButton->Checked)
               {
                  if (DisableTagIDRangeComboBox->Text.data() == NULL)
                  {
                      Application->MessageBox("Error: Need value for the Range",
                                              "Programming Station Information Dialog",
                                              MB_OK | MB_ICONSTOP | MB_TOPMOST);
                      DisableTagBitBtn->Enabled = true;
                      return (0);
                  }

                  XBuf[6] |= GetRangeIndex(atoi(DisableTagIDRangeComboBox->Text.c_str()));
                  XBuf[6] |= 0x10;  //xxx 1 xxxx
               }
               else
               {
                  if (DisableTagRNLongRadioButton->Checked)
                     XBuf[6] |= 0x01; //0000 0001    //long
                  else
                     XBuf[6] &= 0xFE; //1111 1110    //short

                  if (DisableTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                  XBuf[6] |= 0x04;    //0000 0100

                  if (DisableTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                  XBuf[6] |= 0x08;    //0000 1000
               }
            }
            else //any tag type
            {
               XBuf[6] = 0x00; //000 0 0000
               initLen += 1;
               index += 1;

               if (DisableTagIDRangeRadioButton->Checked)
               {
                  if (DisableTagIDRangeComboBox->Text.data() == NULL)
                  {
                      Application->MessageBox("Error: Need value for the Range",
                                              "Programming Station Information Dialog",
                                              MB_OK | MB_ICONSTOP | MB_TOPMOST);
                      DisableTagBitBtn->Enabled = true;
                      return (0);
                  }

                  XBuf[6] |= GetRangeIndex(atoi(DisableTagIDRangeComboBox->Text.c_str()));
                  XBuf[6] |= 0x10;  //xxx 1 xxxx
               }
               else
               {
                  if (DisableTagRNLongRadioButton->Checked)
                     XBuf[6] |= 0x01; //0000 0001    //long
                  else
                     XBuf[6] &= 0xFE; //1111 1110    //short

                  if (DisableTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                     XBuf[6] |= 0x04;    //0000 0100

                  if (DisableTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                     XBuf[6] |= 0x08;    //0000 1000
               }
            }*/

            if ((DisableTagIDRadioButton->Checked) || (DisableTagIDRangeRadioButton->Checked))
            {
                if (DisableTagIDEdit->Text.data() == NULL)
                {
                   Application->MessageBox("Error: Need Tag ID",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   DisableTagBitBtn->Enabled = true;
                   return (0);
                }

                index += 1;
                __int64  n = ((unsigned long)atol(DisableTagIDEdit->Text.c_str()));
                AnsiString s = IntToHex(n, 8);
                XBuf[index] = HexToInt(s.c_str(), 2);
                //if (CarRadioButton->Checked)
                   //XBuf[index] |= 0x80;  //set msb to high for car type
                index += 1;
                AnsiString s1 = s.SubString(3,2);
                XBuf[index] = HexToInt(s1.c_str(), 2);
                index += 1;
                s1 = s.SubString(5,2);
                XBuf[index] = HexToInt(s1.c_str(), 2);
                s1 = s.SubString(7,2);
                index += 1;
                XBuf[index] = HexToInt(s1.c_str(), 2);
                initLen += 4;
                progStr += " ID = ";
                progStr += n;
                StaticText->Caption = progStr;
                TxTagIDLabel->Caption = DisableTagIDEdit->Text; //nID;
            }
            else
               TxTagIDLabel->Caption = "Broadcasting";

            XBuf[2] = initLen;   //len
            index += 1;
            XBuf[index] = 0xA1;  //pktid
            index += 1;

            //TxTagIDLabel->Caption = NewIDEdit->Text; //nID;
            TxTagTimeLabel->Caption = "";
      }
      else    //extended
      {
            initLen = 5;
            XBuf[3] = 0x0E;      //00 001 110
            XBuf[4] = atoi(DisableTagHostIDEdit->Text.c_str());   //host ID
            AnsiString str = IntToHex(rdrID, 4);
            XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
            str = str.SubString(3,2);
            XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
            index = 6;   //initial index

            int tagTypeVal = 0;

            if (DisableTagTypeComboBox->Text == "All Types")
            {
               tagTypeVal = -1;   //one will be added later
            }
            else if (DisableTagTypeComboBox->Text == "Factory")
            {
               tagTypeVal = 6;   //one will be added later
            }
            else if ((tagTypeVal=GetIndexTagType(DisableTagTypeComboBox->Text)) < 0)
            {
                Application->MessageBox("Error in calculating tag type index",
                                         "Programming Station Information Dialog",
                                         MB_OK | MB_ICONSTOP | MB_TOPMOST);
                DisableTagBitBtn->Enabled = true;
                return (0);
            }

           tagTypeVal += 1;
           XBuf[7] = (tagTypeVal << 5);
           initLen += 1;
           index += 1;

           if (DisableTagIDRangeRadioButton->Checked)
           {
               if (DisableTagIDRangeComboBox->Text.data() == NULL)
               {
                   Application->MessageBox("Error: Need value for the Range",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   DisableTagBitBtn->Enabled = true;
                   return (0);
               }
               XBuf[7] |= GetRangeIndex(atoi(DisableTagIDRangeComboBox->Text.c_str()));
               XBuf[7] |= 0x10;  //xxx 1 xxxx
          }
          else
          {
              if (DisableTagRNLongRadioButton->Checked)
                 XBuf[7] |= 0x01; //0000 0001    //long
              else
                 XBuf[7] &= 0xFE; //1111 1110    //short

              if (DisableTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                 XBuf[7] |= 0x04;    //0000 0100

              if (DisableTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                 XBuf[7] |= 0x08;    //0000 1000
           }

            /*if (DisableTagInvRadioButton->Checked)     //inventory
            {
               XBuf[7] = 0x40; //010 0 0000
               initLen += 1;
               index += 1;

               if (DisableTagIDRangeRadioButton->Checked)
               {
                  if (DisableTagIDRangeComboBox->Text.data() == NULL)
                  {
                      Application->MessageBox("Error: Need value for the Range",
                                              "Programming Station Information Dialog",
                                              MB_OK | MB_ICONSTOP | MB_TOPMOST);
                      DisableTagBitBtn->Enabled = true;
                      return (0);
                  }

                  XBuf[7] |= GetRangeIndex(atoi(DisableTagIDRangeComboBox->Text.c_str()));
                  XBuf[7] |= 0x10;  //xxx 1 xxxx
               }
               else
               {
                  if (DisableTagRNLongRadioButton->Checked)
                     XBuf[7] |= 0x01; //0000 0001    //long
                  else
                     XBuf[7] &= 0xFE; //1111 1110    //short

                  if (DisableTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                     XBuf[7] |= 0x04;    //0000 0100

                  if (DisableTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                     XBuf[7] |= 0x08;    //0000 1000
               }
            }
            else if (DisableTagAccRadioButton->Checked)    //acess
            {
               XBuf[7] = 0x20; //001 0 0000
               initLen += 1;
               index += 1;

               if (DisableTagIDRangeRadioButton->Checked)
               {
                  if (DisableTagIDRangeComboBox->Text.data() == NULL)
                  {
                      Application->MessageBox("Error: Need value for the Range",
                                              "Programming Station Information Dialog",
                                              MB_OK | MB_ICONSTOP | MB_TOPMOST);
                      DisableTagBitBtn->Enabled = true;
                      return (0);
                  }

                  XBuf[7] |= GetRangeIndex(atoi(DisableTagIDRangeComboBox->Text.c_str()));
                  XBuf[7] |= 0x10;  //xxx 1 xxxx
               }
               else
               {
                  if (DisableTagRNLongRadioButton->Checked)
                     XBuf[7] |= 0x01; //0000 0001    //long
                  else
                     XBuf[7] &= 0xFE; //1111 1110    //short

                  if (DisableTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                     XBuf[7] |= 0x04;    //0000 0100

                  if (DisableTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                     XBuf[7] |= 0x08;    //0000 1000
               }
            }
            else if (DisableTagAssRadioButton->Checked)   //asset
            {
               XBuf[7] = 0x60; //011 0 0000
               initLen += 1;
               index += 1;

               if (DisableTagIDRangeRadioButton->Checked)
               {
                  if (DisableTagIDRangeComboBox->Text.data() == NULL)
                  {
                      Application->MessageBox("Error: Need value for the Range",
                                              "Programming Station Information Dialog",
                                              MB_OK | MB_ICONSTOP | MB_TOPMOST);
                      DisableTagBitBtn->Enabled = true;
                      return (0);
                  }

                  XBuf[7] |= GetRangeIndex(atoi(DisableTagIDRangeComboBox->Text.c_str()));
                  XBuf[7] |= 0x10;  //xxx 1 xxxx
               }
               else
               {
                  if (DisableTagRNLongRadioButton->Checked)
                     XBuf[7] |= 0x01; //0000 0001    //long
                  else
                     XBuf[7] &= 0xFE; //1111 1110    //short

                  if (DisableTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                     XBuf[7] |= 0x04;    //0000 0100

                  if (DisableTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                     XBuf[7] |= 0x08;    //0000 1000
               }
            }
            else if (DisableTagFactoryRadioButton->Checked)  //factory
            {
               XBuf[7] = 0xE0; //111 0 0000
               initLen += 1;
               index += 1;

               if (DisableTagIDRangeRadioButton->Checked)      //range
               {
                  if (DisableTagIDRangeComboBox->Text.data() == NULL)
                  {
                      Application->MessageBox("Error: Need value for the Range",
                                              "Programming Station Information Dialog",
                                              MB_OK | MB_ICONSTOP | MB_TOPMOST);
                      DisableTagBitBtn->Enabled = true;
                      return (0);
                  }

                  XBuf[7] |= GetRangeIndex(atoi(DisableTagIDRangeComboBox->Text.c_str()));
                  XBuf[7] |= 0x10;  //xxx 1 xxxx
               }
               else
               {
                  if (DisableTagRNLongRadioButton->Checked)
                     XBuf[7] |= 0x01; //0000 0001    //long
                  else
                     XBuf[7] &= 0xFE; //1111 1110    //short

                  if (DisableTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                     XBuf[7] |= 0x04;    //0000 0100

                  if (DisableTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                     XBuf[7] |= 0x08;    //0000 1000
               }
            }
            else //any tag type
            {
               XBuf[7] = 0x00; //000 0 0000
               initLen += 1;
               index += 1;

               if (DisableTagIDRangeRadioButton->Checked)
               {
                  if (DisableTagIDRangeComboBox->Text.data() == NULL)
                  {
                      Application->MessageBox("Error: Need value for the Range",
                                              "Programming Station Information Dialog",
                                              MB_OK | MB_ICONSTOP | MB_TOPMOST);
                      DisableTagBitBtn->Enabled = true;
                      return (0);
                  }

                  XBuf[7] |= GetRangeIndex(atoi(DisableTagIDRangeComboBox->Text.c_str()));
                  XBuf[7] |= 0x10;  //xxx 1 xxxx
               }
               else
               {
                  if (DisableTagRNLongRadioButton->Checked)
                     XBuf[7] |= 0x01; //0000 0001    //long
                  else
                     XBuf[7] &= 0xFE; //1111 1110    //short

                  if (DisableTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                     XBuf[7] |= 0x04;    //0000 0100

                  if (DisableTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                     XBuf[7] |= 0x08;    //0000 1000
               }
            }*/

            if ((DisableTagIDRadioButton->Checked) || (DisableTagIDRangeRadioButton->Checked))
            {
                if (DisableTagIDEdit->Text.data() == NULL)
                {
                   Application->MessageBox("Error: Need Tag ID!",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   DisableTagBitBtn->Enabled = true;
                   return (0);
                }

                index += 1;
                __int64  n = ((unsigned long)atol(DisableTagIDEdit->Text.c_str()));
                AnsiString s = IntToHex(n, 8);
                XBuf[index] = HexToInt(s.c_str(), 2);
                //if (CarRadioButton->Checked)
                   //XBuf[index] |= 0x80;  //set msb to high for car type
                index += 1;
                AnsiString s1 = s.SubString(3,2);
                XBuf[index] = HexToInt(s1.c_str(), 2);
                index += 1;
                s1 = s.SubString(5,2);
                XBuf[index] = HexToInt(s1.c_str(), 2);
                s1 = s.SubString(7,2);
                index += 1;
                XBuf[index] = HexToInt(s1.c_str(), 2);
                initLen += 4;
                progStr += " ID = ";
                progStr += n;
                StaticText->Caption = progStr;
                TxTagIDLabel->Caption = n;
            }
            else
                TxTagIDLabel->Caption = "Broadcasting";


            XBuf[2] = initLen;   //len
            index += 1;
            XBuf[index] = 0xA1;  //pktid
            index += 1;

            //TxTagIDLabel->Caption = NewIDEdit->Text; //nID;
            TxTagTimeLabel->Caption = "";

      } //extended


      if (DisableTagIDComboBox->Text.data() != NULL)
         TxReaderIDLabel->Caption = DisableTagIDComboBox->Text;
      else
         TxReaderIDLabel->Caption = "";
      TxCommandLabel->Caption = "Disable Tag";
      TxTagTypeLabel->Caption = tagTypeStr;
   }
   else if (Command == QUERY_TAG)  //0x09
   {
      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0x09;           //command

      if (QueryTagHostIDEdit->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Host ID",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         QueryTagBitBtn->Enabled = true;
         return (0);
      }

      if (QueryTagBroadcastRdrCheckBox->Checked)
      {
         rdrID = 0x00;   //Global reader ID

      }
      else if (QueryTagReaderIDComboBox->Text.data() == NULL)
      {
           Application->MessageBox("Error: Need Reader ID",
                                   "Programming Station Information Dialog",
                                   MB_OK | MB_ICONSTOP | MB_TOPMOST);
           QueryTagBitBtn->Enabled = true;
           return (0);
      }
      else
         rdrID = atoi(QueryTagReaderIDComboBox->Text.c_str());


      //rdrID = atoi(QueryTagReaderIDComboBox->Text.c_str());
      if (rdrID <= 255)  //reg reader
      {
         initLen = 4;
         XBuf[3] = 0x0A;      //00 001 110
         XBuf[4] = atoi(QueryTagHostIDEdit->Text.c_str());   //host ID
         XBuf[5] = rdrID;  //reader ID
         index = 5;   //initial index

         //1 - Get index or text of combobox
         //2 - Get index of tagTypes()
         //3 - Add one to index to get type val num

          int tagTypeVal = 0;

          if (QueryTagTypeComboBox->Text == "All Types")
          {
             tagTypeVal = -1;   //one will be added later
          }
          else if (QueryTagTypeComboBox->Text == "Factory")
          {
             tagTypeVal = 6;   //one will be added later
          }
          else if ((tagTypeVal=GetIndexTagType(QueryTagTypeComboBox->Text)) < 0)
          {
              Application->MessageBox("Error in calculating tag type index",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
              QueryTagBitBtn->Enabled = true;
              return (0);
          }

         tagTypeVal += 1;
         XBuf[6] = (tagTypeVal << 5);
         initLen += 1;
         index += 1;

         if (QueryTagIDRangeRadioButton->Checked)
         {
             if (QueryTagIDRangeComboBox->Text.data() == NULL)
             {
                 Application->MessageBox("Error: Need value for the Range",
                                         "Programming Station Information Dialog",
                                         MB_OK | MB_ICONSTOP | MB_TOPMOST);
                 QueryTagBitBtn->Enabled = true;
                 return (0);
             }
             XBuf[6] |= GetRangeIndex(atoi(QueryTagIDRangeComboBox->Text.c_str()));
             XBuf[6] |= 0x10;  //xxx 1 xxxx
        }
        else
        {
            if (QueryTagRNLongRadioButton->Checked)
               XBuf[6] |= 0x01; //0000 0001    //long
            else
               XBuf[6] &= 0xFE; //1111 1110    //short

            if (QueryTagEnableLEDRadioButton->Checked)  //TAG LED Enable
               XBuf[6] |= 0x04;    //0000 0100

            if (QueryTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
               XBuf[6] |= 0x08;    //0000 1000
         }

         StaticText->Caption = "Query ";
         StaticText->Caption += QueryTagTypeComboBox->Text;
         StaticText->Caption += " Tag";


         /*if (QueryTagInvRadioButton->Checked)  //inventory
         {
            XBuf[6] = 0x40; //010 0 0000
            initLen += 1;
            index += 1;

            if (QueryTagIDRangeRadioButton->Checked)
            {
               if (QueryTagIDRangeComboBox->Text.data() == NULL)
               {
                   Application->MessageBox("Error: Need value for the Range",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   QueryTagBitBtn->Enabled = true;
                   return (0);
               }
               XBuf[6] |= GetRangeIndex(atoi(QueryTagIDRangeComboBox->Text.c_str()));
               XBuf[6] |= 0x10;  //xxx 1 xxxx
            }
            else
            {
                if (QueryTagRNLongRadioButton->Checked)
                   XBuf[6] |= 0x01; //0000 0001    //long
                else
                   XBuf[6] &= 0xFE; //1111 1110    //short

                if (QueryTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                   XBuf[6] |= 0x04;    //0000 0100

                if (QueryTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                   XBuf[6] |= 0x08;    //0000 1000
             }

             StaticText->Caption = "Query Inventory Tag";
         }
         else if (QueryTagAccRadioButton->Checked)   //ACCESS
         {
            XBuf[6] = 0x20; //001 0 0000
            initLen += 1;
            index += 1;

            if (QueryTagIDRangeRadioButton->Checked)
            {
               if (QueryTagIDRangeComboBox->Text.data() == NULL)
               {
                   Application->MessageBox("Error: Need value for the Range",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   QueryTagBitBtn->Enabled = true;
                   return (0);
               }
               XBuf[6] |= GetRangeIndex(atoi(QueryTagIDRangeComboBox->Text.c_str()));
               XBuf[6] |= 0x10;  //xxx 1 xxxx
            }
            else
            {
               if (QueryTagRNLongRadioButton->Checked)
                  XBuf[6] |= 0x01; //0000 0001    //long
                else
                  XBuf[6] &= 0xFE; //1111 1110    //short

                if (QueryTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                   XBuf[6] |= 0x04;    //0000 0100

                if (QueryTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                   XBuf[6] |= 0x08;    //0000 1000
            }

            StaticText->Caption = "Query Access Tag";
         }
         else if (QueryTagAssRadioButton->Checked)     //ASSET
         {
             XBuf[6] = 0x60; //011 0 0000
             initLen += 1;
             index += 1;

            if (QueryTagIDRangeRadioButton->Checked)
            {
               if (QueryTagIDRangeComboBox->Text.data() == NULL)
               {
                   Application->MessageBox("Error: Need value for the Range",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   QueryTagBitBtn->Enabled = true;
                   return (0);
               }
               XBuf[6] |= GetRangeIndex(atoi(QueryTagIDRangeComboBox->Text.c_str()));
               XBuf[6] |= 0x10;  //xxx 1 xxxx
            }
            else
            {
                if (QueryTagRNLongRadioButton->Checked)
                   XBuf[6] |= 0x01; //0000 0001    //long
                else
                   XBuf[6] &= 0xFE; //1111 1110    //short

                 if (QueryTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                   XBuf[6] |= 0x04;    //0000 0100

                 if (QueryTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                   XBuf[6] |= 0x08;    //0000 1000
             }

             StaticText->Caption = "Query Asset Tag";
         }
         else if (QueryTagFactoryRadioButton->Checked)       //FACTORY
         {
             XBuf[6] = 0xE0; //111 0 0000
             initLen += 1;
             index += 1;

             if (QueryTagIDRangeRadioButton->Checked)
             {
               if (QueryTagIDRangeComboBox->Text.data() == NULL)
               {
                   Application->MessageBox("Error: Need value for the Range",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   QueryTagBitBtn->Enabled = true;
                   return (0);
              }
              XBuf[6] |= GetRangeIndex(atoi(QueryTagIDRangeComboBox->Text.c_str()));
              XBuf[6] |= 0x10;  //xxx 1 xxxx
            }
            else
            {
                if (QueryTagRNLongRadioButton->Checked)
                   XBuf[6] |= 0x01; //0000 0001    //long

                if (QueryTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                   XBuf[6] |= 0x04;    //0000 0100

                if (QueryTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                   XBuf[6] |= 0x08;    //0000 1000
             }

             StaticText->Caption = "Query Factory Tag";
         }
         else  //any tag type        //ANYTYPE
         {
             XBuf[6] = 0x00; //011 0 0000
             initLen += 1;
             index += 1;

             if (QueryTagIDRangeRadioButton->Checked)
             {
               if (QueryTagIDRangeComboBox->Text.data() == NULL)
               {
                   Application->MessageBox("Error: Need value for the Range",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   QueryTagBitBtn->Enabled = true;
                   return (0);
              }
              XBuf[6] |= GetRangeIndex(atoi(QueryTagIDRangeComboBox->Text.c_str()));
              XBuf[6] |= 0x10;  //xxx 1 xxxx
            }
            else
            {
                if (QueryTagRNLongRadioButton->Checked)
                   XBuf[6] |= 0x01; //0000 0001    //long
                else
                   XBuf[6] &= 0xFE; //1111 1110    //short

                if (QueryTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                   XBuf[6] |= 0x04;    //0000 0100

                if (QueryTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                   XBuf[6] |= 0x08;    //0000 1000
             }

             StaticText->Caption = "Query Any Tag Type";
         } */


         //if ((QueryTagRNChangeRadioButton->Checked) &&
                //(QueryTagRNChangeRadioButton->Enabled))
         //{
             //XBuf[6] |= 0x02; //0000 0010    //change
             //if (QueryTagRNLongRadioButton->Checked)
                //XBuf[6] |= 0x01; //0000 0001    //long
         //}

         if (QueryTagIDRadioButton->Checked || QueryTagIDRangeRadioButton->Checked)
         {
            if (QueryTagIDEdit->Text.data() == NULL)
            {
                Application->MessageBox("Error: Need Tag ID",
                                        "Programming Station Information Dialog",
                                        MB_OK | MB_ICONSTOP | MB_TOPMOST);
                QueryTagBitBtn->Enabled = true;
                return (0);
            }

            index += 1;
            __int64  n = ((unsigned long)atol(QueryTagIDEdit->Text.c_str()));
            AnsiString s = IntToHex(n, 8);
            XBuf[index] = HexToInt(s.c_str(), 2);
            index += 1;
            AnsiString s1 = s.SubString(3,2);
            XBuf[index] = HexToInt(s1.c_str(), 2);
            index += 1;
            s1 = s.SubString(5,2);
            XBuf[index] = HexToInt(s1.c_str(), 2);
            s1 = s.SubString(7,2);
            index += 1;
            XBuf[index] = HexToInt(s1.c_str(), 2);
            initLen += 4;
            progStr += " ";
            progStr += n;
            StaticText->Caption = progStr;
            TxTagIDLabel->Caption = n;
         }
         else
         {
            TxTagIDLabel->Caption = "Broadcasting";
            StaticText->Caption = "Query Any Tag";
         }

         XBuf[2] = initLen;   //len
         index += 1;
         XBuf[index] = 0xA3;  //pktid
         index += 1;

         TxTagTimeLabel->Caption = " ";
      }
      else    //extended
      {
         initLen = 5;
         XBuf[3] = 0x0E;      //00 001 110
         XBuf[4] = atoi(QueryTagHostIDEdit->Text.c_str());   //host ID
         AnsiString str = IntToHex(rdrID, 4);
         XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
         str = str.SubString(3,2);
         XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
         index = 6;   //initial index

         int tagTypeVal = 0;

          if ((tagTypeVal=GetIndexTagType(QueryTagTypeComboBox->Text)) < 0)
          {
              Application->MessageBox("Error in calculating tag type index",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
              QueryTagBitBtn->Enabled = true;
              return (0);
          }
          else
          {
             tagTypeVal += 1;
             XBuf[7] = (tagTypeVal << 5);
             initLen += 1;
             index += 1;

             if (QueryTagIDRangeRadioButton->Checked)
             {
                 if (QueryTagIDRangeComboBox->Text.data() == NULL)
                 {
                     Application->MessageBox("Error: Need value for the Range",
                                             "Programming Station Information Dialog",
                                             MB_OK | MB_ICONSTOP | MB_TOPMOST);
                     QueryTagBitBtn->Enabled = true;
                     return (0);
                 }
                 XBuf[7] |= GetRangeIndex(atoi(QueryTagIDRangeComboBox->Text.c_str()));
                 XBuf[7] |= 0x10;  //xxx 1 xxxx
            }
            else
            {
                if (QueryTagRNLongRadioButton->Checked)
                   XBuf[7] |= 0x01; //0000 0001    //long
                else
                   XBuf[7] &= 0xFE; //1111 1110    //short

                if (QueryTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                   XBuf[7] |= 0x04;    //0000 0100

                if (QueryTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                   XBuf[7] |= 0x08;    //0000 1000
             }

             StaticText->Caption = "Query ";
             StaticText->Caption += QueryTagTypeComboBox->Text;
             StaticText->Caption += " Tag";
          }

         /*if (QueryTagInvRadioButton->Checked)
         {
            XBuf[7] = 0x40; //010 0 0000
            initLen += 1;
            index += 1;

            if (QueryTagIDRangeRadioButton->Checked)
            {
               if (QueryTagIDRangeComboBox->Text.data() == NULL)
               {
                   Application->MessageBox("Error: Need value for the Range",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   QueryTagBitBtn->Enabled = true;
                   return (0);
               }
               XBuf[7] |= GetRangeIndex(atoi(QueryTagIDRangeComboBox->Text.c_str()));
               XBuf[7] |= 0x10;  //xxx 1 xxxx
            }
            else
            {
                if (QueryTagRNLongRadioButton->Checked)
                   XBuf[7] |= 0x01; //0000 0001    //long
                else
                   XBuf[7] &= 0xFE; //1111 1110    //short

                if (QueryTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                   XBuf[7] |= 0x04;    //0000 0100

                if (QueryTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                   XBuf[7] |= 0x08;    //0000 1000
            }

            StaticText->Caption = "Query Inventory Tag";
         }
         else if (QueryTagAccRadioButton->Checked)
         {
            XBuf[7] = 0x20; //001 0 0000
            initLen += 1;
            index += 1;

            if (QueryTagIDRangeRadioButton->Checked)
            {
               if (QueryTagIDRangeComboBox->Text.data() == NULL)
               {
                   Application->MessageBox("Error: Need value for the Range",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   QueryTagBitBtn->Enabled = true;
                   return (0);
               }
               XBuf[7] |= GetRangeIndex(atoi(QueryTagIDRangeComboBox->Text.c_str()));
               XBuf[7] |= 0x10;  //xxx 1 xxxx
            }
            else
            {
               if (QueryTagRNLongRadioButton->Checked)
                  XBuf[7] |= 0x01; //0000 0001    //long
               else
                  XBuf[7] &= 0xFE; //1111 1110    //short

               if (QueryTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                  XBuf[7] |= 0x04;    //0000 0100

               if (QueryTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                  XBuf[7] |= 0x08;    //0000 1000
            }
            StaticText->Caption = "Query Access Tag";
         }
         else if (QueryTagAssRadioButton->Checked)
         {
            XBuf[7] = 0x60; //011 0 0000
            initLen += 1;
            index += 1;

            if (QueryTagIDRangeRadioButton->Checked)
            {
               if (QueryTagIDRangeComboBox->Text.data() == NULL)
               {
                   Application->MessageBox("Error: Need value for the Range",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   QueryTagBitBtn->Enabled = true;
                   return (0);
               }
               XBuf[7] |= GetRangeIndex(atoi(QueryTagIDRangeComboBox->Text.c_str()));
               XBuf[7] |= 0x10;  //xxx 1 xxxx
            }
            else
            {
               if (QueryTagRNLongRadioButton->Checked)
                  XBuf[7] |= 0x01; //0000 0001    //long
               else
                  XBuf[7] &= 0xFE; //1111 1110    //short

               if (QueryTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                  XBuf[7] |= 0x04;    //0000 0100

               if (QueryTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                  XBuf[7] |= 0x08;    //0000 1000
            }

            StaticText->Caption = "Query Asset Tag";
         }
         else if (QueryTagFactoryRadioButton->Checked)
         {
            XBuf[7] = 0xE0; //111 0 0000
            initLen += 1;
            index += 1;

            if (QueryTagIDRangeRadioButton->Checked)
            {
               if (QueryTagIDRangeComboBox->Text.data() == NULL)
               {
                   Application->MessageBox("Error: Need value for the Range",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   QueryTagBitBtn->Enabled = true;
                   return (0);
               }
               XBuf[7] |= GetRangeIndex(atoi(QueryTagIDRangeComboBox->Text.c_str()));
               XBuf[7] |= 0x10;  //xxx 1 xxxx
            }
            else
            {
               if (QueryTagRNLongRadioButton->Checked)
                  XBuf[7] |= 0x01; //0000 0001    //long

               if (QueryTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                  XBuf[7] |= 0x04;    //0000 0100

               if (QueryTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                  XBuf[7] |= 0x08;    //0000 1000
             }
             StaticText->Caption = "Query Factory Tag";
         }
         else   //any tag type
         {
            XBuf[7] = 0x00; //000 0 0000
            initLen += 1;
            index += 1;

            if (QueryTagIDRangeRadioButton->Checked)
            {
               if (QueryTagIDRangeComboBox->Text.data() == NULL)
               {
                   Application->MessageBox("Error: Need value for the Range",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   QueryTagBitBtn->Enabled = true;
                   return (0);
               }
               XBuf[7] |= GetRangeIndex(atoi(QueryTagIDRangeComboBox->Text.c_str()));
               XBuf[7] |= 0x10;  //xxx 1 xxxx
            }
            else
            {
                if (QueryTagRNLongRadioButton->Checked)
                   XBuf[7] |= 0x01; //0000 0001    //long
                else
                   XBuf[7] &= 0xFE; //1111 1110    //short

                if (QueryTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                   XBuf[7] |= 0x04;    //0000 0100

                if (QueryTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                   XBuf[7] |= 0x08;    //0000 1000
            }

            StaticText->Caption = "Query Any Tag Type";
         }*/


         //if ((QueryTagRNChangeRadioButton->Checked) &&
                //(QueryTagRNChangeRadioButton->Enabled))
         //{
            //XBuf[7] |= 0x02; //0000 0010    //change
            //if (QueryTagRNLongRadioButton->Checked)
               //XBuf[7] |= 0x01; //0000 0001    //long
         //}

         if (QueryTagIDRadioButton->Checked || QueryTagIDRangeRadioButton->Checked)
         {
             if (QueryTagIDEdit->Text.data() == NULL)
             {
                 Application->MessageBox("Error: Need Tag ID",
                                         "Programming Station Information Dialog",
                                         MB_OK | MB_ICONSTOP | MB_TOPMOST);
                 QueryTagBitBtn->Enabled = true;
                 return (0);
             }

             index += 1;
             int n = atoi(QueryTagIDEdit->Text.c_str());
             AnsiString s = IntToHex(n, 8);
             XBuf[index] = HexToInt(s.c_str(), 2);

             index += 1;
             AnsiString s1 = s.SubString(3,2);
             XBuf[index] = HexToInt(s1.c_str(), 2);
             index += 1;
             s1 = s.SubString(5,2);
             XBuf[index] = HexToInt(s1.c_str(), 2);
             s1 = s.SubString(7,2);
             index += 1;
             XBuf[index] = HexToInt(s1.c_str(), 2);
             initLen += 4;
             progStr += " ";
             progStr += n;
             StaticText->Caption = progStr;
             TxTagIDLabel->Caption = n;
         }
         else
         {
             TxTagIDLabel->Caption = "Broadcasting";
             StaticText->Caption = "Query Any Tag";
         }

         XBuf[2] = initLen;   //len
         index += 1;
         XBuf[index] = 0xA3;  //pktid
         index += 1;

         TxTagTimeLabel->Caption = "";

      } //extended

      if (QueryTagReaderIDComboBox->Text.data() != NULL)
         TxReaderIDLabel->Caption = QueryTagReaderIDComboBox->Text;
      else
         TxReaderIDLabel->Caption = "";
      TxCommandLabel->Caption = "Query Tag";
      TxTagTypeLabel->Caption = tagTypeStr;
   }
   else if (Command == CALL_TAG)  //0x0A
   {
      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0x0A;           //command

      if (CallTagHostIDEdit->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Host ID",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         CallTagBitBtn->Enabled = true;
         return (0);
      }

      if (!CallTagBroadcastRdrCheckBox->Checked)
      {
         if (CallTagReaderIDComboBox->Text.data() == NULL)
         {
           Application->MessageBox("Error: Need Reader ID",
                                   "Programming Station Information Dialog",
                                   MB_OK | MB_ICONSTOP | MB_TOPMOST);
           CallTagBitBtn->Enabled = true;
           return (0);
         }
      }

      //else
      //{

      rdrID = atoi(CallTagReaderIDComboBox->Text.c_str());
      if (rdrID <= 255)  //reg reader
      {
         initLen = 4;
         XBuf[3] = 0x0A;      //00 001 110
         XBuf[4] = atoi(CallTagHostIDEdit->Text.c_str());   //host ID
         XBuf[5] = rdrID;  //reader ID
         index = 5;   //initial index

         int tagTypeVal = 0;

          if (CallTagTypeComboBox->Text == "All Types")
          {
             tagTypeVal = -1;   //one will be added later
          }
          else if (CallTagTypeComboBox->Text == "Factory")
          {
             tagTypeVal = 6;   //one will be added later
          }
          else if ((tagTypeVal=GetIndexTagType(CallTagTypeComboBox->Text)) < 0)
          {
              Application->MessageBox("Error in calculating tag type index",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
              CallTagBitBtn->Enabled = true;
              return (0);
          }

         tagTypeVal += 1;
         XBuf[6] = (tagTypeVal << 5);
         initLen += 1;
         index += 1;

         if (CallTagIDRangeRadioButton->Checked)
         {
             if (CallTagIDRangeComboBox->Text.data() == NULL)
             {
                 Application->MessageBox("Error: Need value for the Range",
                                         "Programming Station Information Dialog",
                                         MB_OK | MB_ICONSTOP | MB_TOPMOST);
                 CallTagBitBtn->Enabled = true;
                 return (0);
             }
             XBuf[6] |= GetRangeIndex(atoi(CallTagIDRangeComboBox->Text.c_str()));
             XBuf[6] |= 0x10;  //xxx 1 xxxx
        }
        else
        {
            if (CallTagRNLongRadioButton->Checked)
               XBuf[6] |= 0x01; //0000 0001    //long
            else
               XBuf[6] &= 0xFE; //1111 1110    //short

            if (CallTagEnableLEDRadioButton->Checked)  //TAG LED Enable
               XBuf[6] |= 0x04;    //0000 0100

            if (CallTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
               XBuf[6] |= 0x08;    //0000 1000
         }

         /*if (CallTagInvRadioButton->Checked)   //inventory tag
         {
            XBuf[6] = 0x40; //010 0 0000
            initLen += 1;
            index += 1;

            if (CallTagIDRangeRadioButton->Checked)
            {
                if (CallTagIDRangeComboBox->Text.data() == NULL)
                {
                    Application->MessageBox("Error: Need value for the Range",
                                            "Programming Station Information Dialog",
                                            MB_OK | MB_ICONSTOP | MB_TOPMOST);
                    CallTagBitBtn->Enabled = true;
                    return (0);
                }

                XBuf[6] |= GetRangeIndex(atoi(CallTagIDRangeComboBox->Text.c_str()));
                XBuf[6] |= 0x10;  //xxx 1 xxxx
            }
            else
            {
                if (CallTagRNLongRadioButton->Checked)
                   XBuf[6] |= 0x01; //0000 0001    //long
                else
                   XBuf[6] &= 0xFE; //1111 1110    //short

                if (CallTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                   XBuf[6] |= 0x04;    //0000 0100

               if (CallTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                   XBuf[6] |= 0x08;    //0000 1000
            }

         }
         else if (CallTagAccRadioButton->Checked)  //access tag
         {
            XBuf[6] = 0x20; //001 0 0000
            initLen += 1;
            index += 1;

            if (CallTagIDRangeRadioButton->Checked)
            {
                if (CallTagIDRangeComboBox->Text.data() == NULL)
                {
                    Application->MessageBox("Error: Need value for the Range",
                                            "Programming Station Information Dialog",
                                            MB_OK | MB_ICONSTOP | MB_TOPMOST);
                    CallTagBitBtn->Enabled = true;
                    return (0);
                }

                XBuf[6] |= GetRangeIndex(atoi(CallTagIDRangeComboBox->Text.c_str()));
                XBuf[6] |= 0x10;  //xxx 1 xxxx
            }
            else
            {
               if (CallTagRNLongRadioButton->Checked)
                   XBuf[6] |= 0x01; //0000 0001    //long
                else
                   XBuf[6] &= 0xFE; //1111 1110    //short

                if (CallTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                  XBuf[6] |= 0x04;    //0000 0100

                if (CallTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                  XBuf[6] |= 0x08;    //0000 1000
             }
         }
         else if (CallTagAssRadioButton->Checked)  //asset tag
         {
             XBuf[6] = 0x60; //011 0 0000
             initLen += 1;
             index += 1;

             if (CallTagIDRangeRadioButton->Checked)
            {
                if (CallTagIDRangeComboBox->Text.data() == NULL)
                {
                    Application->MessageBox("Error: Need value for the Range",
                                            "Programming Station Information Dialog",
                                            MB_OK | MB_ICONSTOP | MB_TOPMOST);
                    CallTagBitBtn->Enabled = true;
                    return (0);
                }

                XBuf[6] |= GetRangeIndex(atoi(CallTagIDRangeComboBox->Text.c_str()));
                XBuf[6] |= 0x10;  //xxx 1 xxxx
            }
            else
            {
                if (CallTagRNLongRadioButton->Checked)
                   XBuf[6] |= 0x01; //0000 0001    //long
                else
                   XBuf[6] &= 0xFE; //1111 1110    //short

                if (CallTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                   XBuf[6] |= 0x04;    //0000 0100

                if (CallTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                   XBuf[6] |= 0x08;    //0000 1000
             }
         }
         else  //any tag type       //any tag
         {
             XBuf[6] = 0x00; //000 0 0000
             initLen += 1;
             index += 1;

            if (CallTagIDRangeRadioButton->Checked)
            {
                if (CallTagIDRangeComboBox->Text.data() == NULL)
                {
                    Application->MessageBox("Error: Need value for the Range",
                                            "Programming Station Information Dialog",
                                            MB_OK | MB_ICONSTOP | MB_TOPMOST);
                    CallTagBitBtn->Enabled = true;
                    return (0);
                }

                XBuf[6] |= GetRangeIndex(atoi(CallTagIDRangeComboBox->Text.c_str()));
                XBuf[6] |= 0x10;  //xxx 1 xxxx
            }
            else
            {
                if (CallTagRNLongRadioButton->Checked)
                   XBuf[6] |= 0x01; //0000 0001    //long
                else
                   XBuf[6] &= 0xFE; //1111 1110    //short

                if (CallTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                   XBuf[6] |= 0x04;    //0000 0100

                if (CallTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                   XBuf[6] |= 0x08;    //0000 1000
             }
         }*/


         //if ((CallTagRNChangeRadioButton->Checked) &&
             //(CallTagRNChangeRadioButton->Enabled))
         //{
             //XBuf[6] |= 0x02; //0000 0010    //change
             //if (CallTagRNLongRadioButton->Checked)
                //XBuf[6] |= 0x01; //0000 0001    //long
             //else
                //XBuf[6] &= 0xFE; //1111 1110    //short
         //}

         if (CallTagIDRadioButton->Checked || CallTagIDRangeRadioButton->Checked)
         {
            if (CallTagIDEdit->Text.data() == NULL)
            {
                Application->MessageBox("Error: Need Tag ID",
                                        "Programming Station Information Dialog",
                                        MB_OK | MB_ICONSTOP | MB_TOPMOST);
                CallTagBitBtn->Enabled = true;
                return (0);
            }

            index += 1;
            __int64  n = ((unsigned long)atol(CallTagIDEdit->Text.c_str()));
            AnsiString s = IntToHex(n, 8);
            XBuf[index] = HexToInt(s.c_str(), 2);
            index += 1;
            AnsiString s1 = s.SubString(3,2);
            XBuf[index] = HexToInt(s1.c_str(), 2);
            index += 1;
            s1 = s.SubString(5,2);
            XBuf[index] = HexToInt(s1.c_str(), 2);
            s1 = s.SubString(7,2);
            index += 1;
            XBuf[index] = HexToInt(s1.c_str(), 2);
            initLen += 4;
            progStr += " ";
            progStr += n;
            StaticText->Caption = progStr;
            TxTagIDLabel->Caption = n;
         }
         else
            TxTagIDLabel->Caption = "Broadcasting";

         XBuf[2] = initLen;   //len
         index += 1;
         XBuf[index] = 0xA3;  //pktid
         index += 1;

         TxTagTimeLabel->Caption = " ";
      }
      else    //extended
      {
         initLen = 5;
         XBuf[3] = 0x0E;      //00 001 110
         XBuf[4] = atoi(CallTagHostIDEdit->Text.c_str());   //host ID
         AnsiString str = IntToHex(rdrID, 4);
         XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
         str = str.SubString(3,2);
         XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
         index = 6;   //initial index

         int tagTypeVal = 0;

          if (CallTagTypeComboBox->Text == "All Types")
          {
             tagTypeVal = -1;   //one will be added later
          }
          else if (CallTagTypeComboBox->Text == "Factory")
          {
             tagTypeVal = 6;   //one will be added later
          }
          else if ((tagTypeVal=GetIndexTagType(CallTagTypeComboBox->Text)) < 0)
          {
              Application->MessageBox("Error in calculating tag type index",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
              CallTagBitBtn->Enabled = true;
              return (0);
          }

         tagTypeVal += 1;
         XBuf[7] = (tagTypeVal << 5);
         initLen += 1;
         index += 1;

         if (CallTagIDRangeRadioButton->Checked)
         {
             if (CallTagIDRangeComboBox->Text.data() == NULL)
             {
                 Application->MessageBox("Error: Need value for the Range",
                                         "Programming Station Information Dialog",
                                         MB_OK | MB_ICONSTOP | MB_TOPMOST);
                 CallTagBitBtn->Enabled = true;
                 return (0);
             }
             XBuf[7] |= GetRangeIndex(atoi(CallTagIDRangeComboBox->Text.c_str()));
             XBuf[7] |= 0x10;  //xxx 1 xxxx
        }
        else
        {
            if (CallTagRNLongRadioButton->Checked)
               XBuf[7] |= 0x01; //0000 0001    //long
            else
               XBuf[7] &= 0xFE; //1111 1110    //short

            if (CallTagEnableLEDRadioButton->Checked)  //TAG LED Enable
               XBuf[7] |= 0x04;    //0000 0100

            if (CallTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
               XBuf[7] |= 0x08;    //0000 1000
         }

         /*if (CallTagInvRadioButton->Checked)
         {
            XBuf[7] = 0x40; //010 0 0000
            initLen += 1;
            index += 1;

            if (CallTagIDRangeRadioButton->Checked)
            {
                if (CallTagIDRangeComboBox->Text.data() == NULL)
                {
                    Application->MessageBox("Error: Need value for the Range",
                                            "Programming Station Information Dialog",
                                            MB_OK | MB_ICONSTOP | MB_TOPMOST);
                    CallTagBitBtn->Enabled = true;
                    return (0);
                }

                XBuf[7] |= GetRangeIndex(atoi(CallTagIDRangeComboBox->Text.c_str()));
                XBuf[7] |= 0x10;  //xxx 1 xxxx
            }
            else
            {
               if (CallTagRNLongRadioButton->Checked)
                  XBuf[7] |= 0x01; //0000 0001    //long
               else
                  XBuf[7] &= 0xFE; //1111 1110    //short

               if (CallTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                  XBuf[7] |= 0x04;    //0000 0100

                if (CallTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                  XBuf[7] |= 0x08;    //0000 1000
             }
         }
         else if (CallTagAccRadioButton->Checked)
         {
            XBuf[7] = 0x20; //001 0 0000
            initLen += 1;
            index += 1;

            if (CallTagIDRangeRadioButton->Checked)
            {
                if (CallTagIDRangeComboBox->Text.data() == NULL)
                {
                    Application->MessageBox("Error: Need value for the Range",
                                            "Programming Station Information Dialog",
                                            MB_OK | MB_ICONSTOP | MB_TOPMOST);
                    CallTagBitBtn->Enabled = true;
                    return (0);
                }

                XBuf[7] |= GetRangeIndex(atoi(CallTagIDRangeComboBox->Text.c_str()));
                XBuf[7] |= 0x10;  //xxx 1 xxxx
            }
            else
            {
               if (CallTagRNLongRadioButton->Checked)
                  XBuf[7] |= 0x01; //0000 0001    //long
               else
                  XBuf[7] &= 0xFE; //1111 1110    //short

               if (CallTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                  XBuf[7] |= 0x04;    //0000 0100

                if (CallTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                  XBuf[7] |= 0x08;    //0000 1000
             }
         }
         else if (CallTagAssRadioButton->Checked)
         {
            XBuf[7] = 0x60; //011 0 0000
            initLen += 1;
            index += 1;

            if (CallTagIDRangeRadioButton->Checked)
            {
                if (CallTagIDRangeComboBox->Text.data() == NULL)
                {
                    Application->MessageBox("Error: Need value for the Range",
                                            "Programming Station Information Dialog",
                                            MB_OK | MB_ICONSTOP | MB_TOPMOST);
                    CallTagBitBtn->Enabled = true;
                    return (0);
                }

                XBuf[7] |= GetRangeIndex(atoi(CallTagIDRangeComboBox->Text.c_str()));
                XBuf[7] |= 0x10;  //xxx 1 xxxx
            }
            else
            {
               if (CallTagRNLongRadioButton->Checked)
                  XBuf[7] |= 0x01; //0000 0001    //long
               else
                  XBuf[7] &= 0xFE; //1111 1110    //short

               if (CallTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                  XBuf[7] |= 0x04;    //0000 0100

                if (CallTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                  XBuf[7] |= 0x08;    //0000 1000
             }
         }
         else   //any tag type
         {
            XBuf[7] = 0x00; //000 0 0000
            initLen += 1;
            index += 1;

            if (CallTagIDRangeRadioButton->Checked)
            {
                if (CallTagIDRangeComboBox->Text.data() == NULL)
                {
                    Application->MessageBox("Error: Need value for the Range",
                                            "Programming Station Information Dialog",
                                            MB_OK | MB_ICONSTOP | MB_TOPMOST);
                    CallTagBitBtn->Enabled = true;
                    return (0);
                }

                XBuf[7] |= GetRangeIndex(atoi(CallTagIDRangeComboBox->Text.c_str()));
                XBuf[7] |= 0x10;  //xxx 1 xxxx
            }
            else
            {
               if (CallTagRNLongRadioButton->Checked)
                  XBuf[7] |= 0x01; //0000 0001    //long
               else
                  XBuf[7] &= 0xFE; //1111 1110    //short

               if (CallTagEnableLEDRadioButton->Checked)  //TAG LED Enable
                  XBuf[7] |= 0x04;    //0000 0100

               if (CallTagEnableSpeakerRadioButton->Checked)  //TAG Speaker Enable
                  XBuf[7] |= 0x08;    //0000 1000
            }
         }*/


         //if ((CallTagRNChangeRadioButton->Checked) &&
             //(CallTagRNChangeRadioButton->Enabled))
         //{
            //XBuf[7] |= 0x02; //0000 0010    //change
            //if (CallTagRNLongRadioButton->Checked)
               //XBuf[7] |= 0x01; //0000 0001    //long
            //else
               //XBuf[7] &= 0xFE; //1111 1110    //short
         //}

         if (CallTagIDRadioButton->Checked || CallTagIDRangeRadioButton->Checked)
         {
             if (CallTagIDEdit->Text.data() == NULL)
             {
                 Application->MessageBox("Error: Need Tag ID",
                                         "Programming Station Information Dialog",
                                         MB_OK | MB_ICONSTOP | MB_TOPMOST);
                 CallTagBitBtn->Enabled = true;
                 return (0);
             }

             index += 1;
             int n = atoi(CallTagIDEdit->Text.c_str());
             AnsiString s = IntToHex(n, 8);
             XBuf[index] = HexToInt(s.c_str(), 2);

             index += 1;
             AnsiString s1 = s.SubString(3,2);
             XBuf[index] = HexToInt(s1.c_str(), 2);
             index += 1;
             s1 = s.SubString(5,2);
             XBuf[index] = HexToInt(s1.c_str(), 2);
             s1 = s.SubString(7,2);
             index += 1;
             XBuf[index] = HexToInt(s1.c_str(), 2);
             initLen += 4;
             progStr += " ";
             progStr += n;
             StaticText->Caption = progStr;
             TxTagIDLabel->Caption = n;
         }
         else
             TxTagIDLabel->Caption = "Broadcasting";

         XBuf[2] = initLen;   //len
         index += 1;
         XBuf[index] = 0xA3;  //pktid
         index += 1;

         TxTagTimeLabel->Caption = "";

      } //extended

      if (CallTagReaderIDComboBox->Text.data() != NULL)
         TxReaderIDLabel->Caption = CallTagReaderIDComboBox->Text;
      else
         TxReaderIDLabel->Caption = "";
      TxCommandLabel->Caption = "Call Tag";
      TxTagTypeLabel->Caption = tagTypeStr;

      /*XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0x0A;           //command
      if (HostIDEdit->Text.data() == NULL)
      {
         ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Need Host ID!",
         ( LPCSTR )"Programming Station Information Dialog",
         MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
         CallTagBitBtn->Enabled = true;
         return (0);
      }
      if (ReaderIDComboBox->Text.data() == NULL)
      {
           ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Need Reader ID!",
           ( LPCSTR )"Programming Station Information Dialog",
           MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
           CallTagBitBtn->Enabled = true;
           return (0);
      }
      if (FieldGenIDEdit->Text.data() == NULL)
      {
           ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Need Field Generator ID!",
           ( LPCSTR )"Programming Station Information Dialog",
           MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
           CallTagBitBtn->Enabled = true;
           return (0);
      }
      //else
      {
         //NewListItemCheckBox->Checked = false;
         rdrID = atoi(ReaderIDComboBox->Text.c_str());
         if (rdrID <= 255)  //reg reader
         {
            initLen = 4;
            XBuf[3] = 0x0A;      //00 001 110
            XBuf[4] = atoi(HostIDEdit->Text.c_str());   //host ID
            XBuf[5] = rdrID;  //reader ID
            //XBuf[6] = atoi(FieldGenIDEdit->Text.c_str());   //field Gen ID
            index = 5;   //initial index

            if (InvetRadioButton->Checked)
            {
               XBuf[6] = 0x40; //010 0 0000
               initLen += 1;
               index += 1;
            }
            else if (CarRadioButton->Checked)
            {
              XBuf[6] = 0x80; //100 0 0000
              initLen += 1;
              index += 1;
            }
            else if (AccessCtrlRadioButton->Checked)
            {
               XBuf[6] = 0x20; //001 0 0000
               initLen += 1;
               index += 1;
            }
            else if (AssetCtrlRadioButton->Checked)
            {
               XBuf[6] = 0x60; //011 0 0000
               initLen += 1;
               index += 1;
            }
            //else //any tag type, same tag type
            //{
               //XBuf[6] = 0x00; //011 0 0000
               //initLen += 1;
               //index += 1;
            //}

            if (TagIDRadioButton->Checked)
            {
                if (TagIDEdit->Text.data() == NULL)
                {
                   ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Need Tag ID!",
                   ( LPCSTR )"Programming Station Information Dialog",
                   MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
                   CallTagBitBtn->Enabled = true;
                   return (0);
                }

                index += 1;
                __int64  n = ((unsigned long)atol(TagIDEdit->Text.c_str()));
                AnsiString s = IntToHex(n, 8);
                XBuf[index] = HexToInt(s.c_str(), 2);
                //if (CarRadioButton->Checked)
                   //XBuf[index] |= 0x80;  //set msb to high for car type
                index += 1;
                AnsiString s1 = s.SubString(3,2);
                XBuf[index] = HexToInt(s1.c_str(), 2);
                index += 1;
                s1 = s.SubString(5,2);
                XBuf[index] = HexToInt(s1.c_str(), 2);
                s1 = s.SubString(7,2);
                index += 1;
                XBuf[index] = HexToInt(s1.c_str(), 2);
                initLen += 4;
                progStr += n;
                StaticText->Caption = progStr;
                TxTagIDLabel->Caption = n;
            }
            else
                TxTagIDLabel->Caption = "Broadcasting";

            XBuf[2] = initLen;   //len
            index += 1;
            XBuf[index] = 0xA6;  //pktid
            index += 1;

            TxTagTimeLabel->Caption = " "; */
         /*}
         else    //extended
         {
            initLen = 5;
            XBuf[3] = 0x0E;      //00 001 110
            XBuf[4] = atoi(HostIDEdit->Text.c_str());   //host ID
            AnsiString str = IntToHex(rdrID, 4);
            XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
            str = str.SubString(3,2);
            XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
            //XBuf[7] = atoi(FieldGenIDEdit->Text.c_str());   //field Gen ID
            index = 6;   //initial index

            if (InvetRadioButton->Checked)
            {
               XBuf[7] = 0x40; //010 0 0000
               initLen += 1;
               index += 1;
            }
            else if (CarRadioButton->Checked)
            {
              XBuf[7] = 0x80; //100 0 0000
              initLen += 1;
              index += 1;
            }
            else if (AccessCtrlRadioButton->Checked)
            {
               XBuf[7] = 0x20; //001 0 0000
               initLen += 1;
               index += 1;
            }
            else if (AssetCtrlRadioButton->Checked)
            {
               XBuf[7] = 0x60; //011 0 0000
               initLen += 1;
               index += 1;
            }
            else //any tag type, same tag type
            {
               XBuf[7] = 0x00; //011 0 0000
               initLen += 1;
               index += 1;
            }

            if (TagIDRadioButton->Checked)
            {
                if (NewIDEdit->Text.data() == NULL)
                {
                   ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Need Tag ID!",
                   ( LPCSTR )"Programming Station Information Dialog",
                   MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
                   CallTagBitBtn->Enabled = true;
                   return (0);
                }

                index += 1;
                int n = atoi(NewIDEdit->Text.c_str());
                AnsiString s = IntToHex(n, 8);
                XBuf[index] = HexToInt(s.c_str(), 2);
                //if (CarRadioButton->Checked)
                   //XBuf[index] |= 0x80;  //set msb to high for car type
                index += 1;
                AnsiString s1 = s.SubString(3,2);
                XBuf[index] = HexToInt(s1.c_str(), 2);
                index += 1;
                s1 = s.SubString(5,2);
                XBuf[index] = HexToInt(s1.c_str(), 2);
                s1 = s.SubString(7,2);
                index += 1;
                XBuf[index] = HexToInt(s1.c_str(), 2);
                initLen += 4;
                progStr += n;
                StaticText->Caption = progStr;
                TxTagIDLabel->Caption = n;
            }
            else
                TxTagIDLabel->Caption = "Broadcasting";

            XBuf[2] = initLen;   //len
            index += 1;
            XBuf[index] = 0xA6;  //pktid
            index += 1;

            //TxTagIDLabel->Caption = NewIDEdit->Text; //nID;
            TxTagTimeLabel->Caption = "";

         } //extended
      }

      if (CallTagReaderIDComboBox->Text.data() != NULL)
         TxReaderIDLabel->Caption = CallTagReaderIDComboBox->Text;
      else
         TxReaderIDLabel->Caption = "";
      TxCommandLabel->Caption = "Call Tag";
      TxTagTypeLabel->Caption = tagTypeStr; */
   }
   else if (Command == READER_CODE_VER)  //0x0D
   {
      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0x0D;           //command
      if (RdrCodeVerHostEdit->Text.data() == NULL)
      {
         ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Need Host ID!",
         ( LPCSTR )"Programming Station Information Dialog",
         MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
         ReaderVersion->Enabled = true;
         return (0);
      }

      rdrID = atoi(RdrCodeVerReaderComboBox->Text.c_str());
      if (RdrCodeVerBroadcastRdrCheckBox->Checked)
         rdrID = 0x00;  //broadcast reader
      else if (RdrCodeVerReaderComboBox->Text.data() == NULL)
      {
         ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Need Reader ID!",
         ( LPCSTR )"Programming Station Information Dialog",
         MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
         ReaderVersion->Enabled = true;
         return (0);
      }

      if (rdrID <= 255)
      {
         XBuf[2] = 0x04;   //Len
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(HostIDEdit->Text.c_str());   //host ID
         XBuf[5] = rdrID;
         XBuf[6] = 0xC9;   //pkt ID
         index = 7;

         if (rdrID == 0x00)
            TxCommandLabel->Caption = "Get All Readers Code Version";
         else
            TxCommandLabel->Caption = "Get Reader Code Version";
      }
      else    //extended
      {
         XBuf[2] = 0x05;   //Len
         XBuf[3] = 0x0E;   //00 001 110
         XBuf[4] = atoi(HostIDEdit->Text.c_str());  //host ID
         AnsiString str = IntToHex(rdrID, 4);
         XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
         str = str.SubString(3,2);
         XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
         XBuf[7] = 0xC9;   //pkt ID
         index = 8;

         TxCommandLabel->Caption = "Get Reader Code Version";
            //10-9:->11 h
            //11h(1) +
            // 6h(1) = 17*7.5 = 130.00 Wa + 30.0 uti + 85.0 rnt + 15 extra = 260
            //460 - 260 = 200 -> 70*7= 490  70*7 = 490  60 roy
      }

      if (ReaderIDComboBox->Text.data() != NULL)
         TxReaderIDLabel->Caption = ReaderIDComboBox->Text;
      else
         TxReaderIDLabel->Caption = "";
   }
   else if (Command == ASSIGN_READER)  //0x0E
   {
      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0x0E;           // command
      unsigned short newRdrID;
      unsigned short hostID;
      unsigned short newHostID;

      /*rdrConfigFlag = false;
      rdrConfigTxFlag = false;
      fGenConfigFlag = false;

      if (AssignReaderNewRdrCheckBox->Checked ||
          AssignReaderNewHostCheckBox->Checked ||
          AssignReaderNoChangeCheckBox->Checked)
          rdrConfigFlag = true;

      if (AssignReaderModifyTXCheckBox->Checked)
          rdrConfigTxFlag = true; */

      if (!AssignReaderBroadcastRdrCheckBox->Checked && (AssignReaderIDComboBox->Text.data() == NULL))
      {
         Application->MessageBox("Error: Need Reader ID.",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         AssignReaderBitBtn->Enabled = true;
         return (0);
      }

      if (AssignReaderHostIDEdit->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Host ID.",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         AssignReaderBitBtn->Enabled = true;
         return (0);
      }

      hostID = atoi(AssignReaderHostIDEdit->Text.c_str());

      //if (AssignReaderBroadcastReaderCheckBox->Checked)
         //rdrID = 0;
      //else

      rdrID = atoi(AssignReaderIDComboBox->Text.c_str());

      if (rdrConfigTxFlag)
      {
          XBuf[1] = 0x20;
          if (rdrID <= 255)  //standard reader
          {
             XBuf[3] = 0x0A;
             XBuf[4] = hostID;
             XBuf[5] = rdrID;
             index = 6;
          }
          else
          {
             XBuf[3] = 0x0E;
             XBuf[4] = hostID;
             str = IntToHex(rdrID, 4);
             XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
             str = str.SubString(3,2);
             XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
             index = 7;
          }

          if (AssignReaderModifyTXCheckBox->Checked ||
              AssignReaderModifyMDCheckBox->Checked ||
              AssignReaderModifyWTCheckBox->Checked)
          {
              if (AssignReaderTXComboBox->Text.data() != NULL)
              {
                  XBuf[index] = atoi(AssignReaderTXComboBox->Text.c_str());

                  //if (AssignReaderModifyMDCheckBox->Checked)
                  //{
                     if (AssignReaderEnableMDCheckBox->Checked)  //Motion Det Enable/Disable
                        XBuf[index] |= 0x40; //0 1 00 0000   MD enable
                     else
                        XBuf[index] &= 0xBF; //0 0 00 0000   MD disable

                     if (AssignReaderMDActiveHiRadioButton->Checked)  //Active Hi/Lo
                        XBuf[index] |= 0x80; //1 000 0000 active hi
                     else
                        XBuf[index] &= 0x7F; //0 000 0000 active lo

                  //}
                  index += 1;
              }
              else
              {
                 Application->MessageBox("Error: need value for Transmit Time.",
                                         "Programming Station Information Dialog",
                                         MB_OK | MB_ICONSTOP | MB_TOPMOST);
                 return (0);  //need msg
              }
          //}

              //if (AssignReaderModifyWTCheckBox->Checked)
              //{
                  if (AssignReaderWTComboBox->Text.data() != NULL)   //wait time
                  {
                     if (AssignReaderWTSecRadioButton->Checked)
                         XBuf[index] = 0x00; //00 00 0000  sec
                     else if (AssignReaderWTMinRadioButton->Checked)
                         XBuf[index] = 0x40; //01 00 0000  min
                     else
                         XBuf[index] = 0x80; //10 00 0000  hour

                     XBuf[index] |= atoi(AssignReaderWTComboBox->Text.c_str());
                     index += 1;
                 }
                 else
                 {
                     Application->MessageBox("Error: need value for Wait Time.",
                                         "Programming Station Information Dialog",
                                         MB_OK | MB_ICONSTOP | MB_TOPMOST);
                     return (0);  //need msg
                 }
             //}
         }

         XBuf[index] = 0xB1;  //pktID
         XBuf[2] = index - 2; //len
         index += 1;

          /*if(networkOn)
          {
             int rdr = atoi(AssignReaderIDComboBox->Text.c_str());
             int index = GetSocketIndex(rdr);
             if (index >= 0)
             {
                WriteAWSocket(CONFIG_FIELD_GEN, 0, NULL, index, 'S', NULL, 0, index);
             }
             else
                StaticText->Caption = "No matching socket for the reader.";
          }
          else if (RS232On)
          {
              WriteRS232Comm(CONFIG_FIELD_GEN, 0, NULL, 0);
          } */
      }  //if rdrConfigTxFlag = true
      else if (rdrConfigFlag)
      {
         if (AssignReaderNewIDEdit->Text.data() == NULL)
            newRdrID = rdrID;
         else
         {
            newRdrID = atoi(AssignReaderNewIDEdit->Text.c_str());
            if (newRdrID > 255)
            {
               Application->MessageBox("Error: Extended Reader Has Not Been Implememted Yet.",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
               AssignReaderBitBtn->Enabled = true;
               StaticText->Caption = "";
               return (0);
            }
         }

         if (AssignReaderNewHostIDEdit->Text.data() == NULL)
         newHostID = hostID;
         else
         newHostID = atoi(AssignReaderNewHostIDEdit->Text.c_str());

         if (!newHostID)
         {
         Application->MessageBox("Error: New Host ID Can Not Be Zero",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         AssignReaderBitBtn->Enabled = true;
         return (0);
         }

         if (!newRdrID)
         {
         Application->MessageBox("Error: New Reader ID Can Not Be Zero",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         AssignReaderBitBtn->Enabled = true;
         return (0);
         }

         if (rdrID <= 255)  //standard reader
         {
            //if (rdrID > 0)
            //{
               XBuf[3] = 0x0A;
               XBuf[4] = hostID;
               XBuf[5] = rdrID;
               index = 6;
            //}
            //else //global
            //{
               //XBuf[3] = 0x0A;
               //XBuf[4] = hostID;
               //index = 5;
            //}

            //if ((AssignReaderNewIDEdit->Text.data() != NULL) ||
                //(AssignReaderNewHostIDEdit->Text.data() != NULL))
            {
               if (newRdrID <= 255)  //new standard reader address
               {
               XBuf[index++] = 0x0A;
               XBuf[index++] = newHostID;
               XBuf[index++] = newRdrID;
               //index = 9;
               }
               else
               {
               XBuf[index++] = 0x0E;
               XBuf[index++] = newHostID;

               //OLD---------------------------------------------------
               //str = AssignReaderNewIDEdit->Text;
               //XBuf[index++] = HexToInt(str.c_str(), 2);   //reader ID
               //str = str.SubString(3,2);
               //XBuf[index++] = HexToInt(str.c_str(), 2);   //reader ID
               //------------------------------------------------------
               str = IntToHex(newRdrID, 4);
               XBuf[index++] = HexToInt(str.c_str(), 2);   //reader ID
               str = str.SubString(3,2);
               XBuf[index++] = HexToInt(str.c_str(), 2);   //reader ID
               }
            }
            /*else if (NewHostIDCheckBox->Checked) //global new hID, old rID
            {
             XBuf[index++] = 0x0A;
             XBuf[index++] = newHostID;
             XBuf[index++] = rdrID;   //old id
            }*/
         }
         else   //extended reader
         {
            XBuf[3] = 0x0E;
            XBuf[4] = hostID;
         //OLD----------------------------------------------------
         //str = rdrID;
         //XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
         //str = str.SubString(3,2);
         //XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
         //index = 7;
         //------------------------------------------------------

            str = IntToHex(rdrID, 4);
            XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
            str = str.SubString(3,2);
            XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
            index = 7;

            //if ((AssignReaderNewIDEdit->Text.data() != NULL) ||
                //(AssignReaderNewHostIDEdit->Text.data() != NULL))
            {
               if (newRdrID <= 255)  //new standard reader address
               {
               XBuf[7] = 0x0A;
               XBuf[8] = newHostID;
               XBuf[9] = newRdrID;
               index = 10;
               }
               else
               {
               XBuf[7] = 0x0E;
               XBuf[8] = newHostID;

               //OLD-------------------------------------------
               //str = newRdrID;
               //XBuf[9] = HexToInt(str.c_str(), 2);   //reader ID
               //str = str.SubString(3,2);
               //XBuf[10] = HexToInt(str.c_str(), 2);   //reader ID
               //index = 11;
               //------------------------------------------
               str = IntToHex(newRdrID, 4);
               XBuf[9] = HexToInt(str.c_str(), 2);   //reader ID
               str = str.SubString(3,2);
               XBuf[10] = HexToInt(str.c_str(), 2);   //reader ID
               index = 11;
               //--------------------------------------------

               }
            }
         }

         XBuf[index] = 0x00;  //Config byte for reader - no change
         //if (!AssignReaderNoChangeCheckBox->Checked)  //modify button
         //XBuf[index] = 0x00;   //0 000 0000  //no change

         if (AssignReaderNoChangeCheckBox->Checked)  //modify button
         {
            if (AssignReaderTypeComboBox->Text.data() != NULL) {
               if (AssignReaderTypeComboBox->Text == "Standard Reader")
                  XBuf[index] = 2;  //Std Reader
               else if (AssignReaderTypeComboBox->Text == "Access Control")
                  XBuf[index] = 3;
               else if (AssignReaderTypeComboBox->Text == "Small RF Reader")
                  XBuf[index] = 4;
               else if (AssignReaderTypeComboBox->Text == "PDA Reader")
                  XBuf[index] = 5;
               else if (AssignReaderTypeComboBox->Text == "FGen Reader")
                  XBuf[index] = 6;  //FGen Reader
               else if (AssignReaderTypeComboBox->Text == "SaniFaucet Door Unit")
                  XBuf[index] = 7;
               else if (AssignReaderTypeComboBox->Text == "SaniFaucet Faucet Unit")
                  XBuf[index] = 8;
               else if (AssignReaderTypeComboBox->Text == "SaniFaucet Sanitization Unit")
                  XBuf[index] = 9;
               else if (AssignReaderTypeComboBox->Text == "SaniFaucet Contamination Unit")
                  XBuf[index] = 10;
               else if (AssignReaderTypeComboBox->Text == "SaniFaucet Bed Unit")
                  XBuf[index] = 11;
               else if (AssignReaderTypeComboBox->Text == "Query FGen Reader")
                  XBuf[index] = 12;
               else {
                  Application->MessageBox("Error: Could not determine reader type!",
                                          "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                  AssignReaderBitBtn->Enabled = true;
                  return (0);
               }
            }

            //ReaderType
            //if (AssignReaderTypeComboBox->ItemIndex >= 0)
            //XBuf[index] |= AssignReaderTypeComboBox->ItemIndex; //ReaderTypeComboBox->ItemIndex;
            //XBuf[index] = 0x02;   //Std reader

            //if (!AssignReaderBroadcastCheckBox->Checked)   //broadcast
               //XBuf[index] |= 0x10;   //0001 0000

            //if (!AssignReaderEnableCheckBox->Checked)   //enable pwrup
               //XBuf[index] |= 0x20;   //0010 0000

            if (AssignReaderRSSICheckBox->Checked)
               XBuf[index] |= 0x40;   //0100 0000   send RSSI

            XBuf[index] |= 0x80;   //1000 0000   reader enable (not on screen)
         }
         else  //reader config needs to be sent allways - reader type bit 0 = no change
         {
            if (!AssignReaderBroadcastCheckBox->Checked)   //broadcast
               XBuf[index] |= 0x10;   //0001 0000

            if (!AssignReaderEnableCheckBox->Checked)   //enable pwrup
               XBuf[index] |= 0x20;   //0010 0000

            if (AssignReaderRSSICheckBox->Checked)
               XBuf[index] |= 0x40;   //0100 0000   send RSSI

            XBuf[index] |= 0x80;   //1000 0000   reader enable (not on screen)

         }

         index += 1;

         XBuf[index] = 0x00;
         index += 1;
         XBuf[index] = 0x00;
         index += 1;
         XBuf[index] = 0xAF;  //pktID
         XBuf[2] = index - 2; //len
         index += 1;
      }//if rdrFlag TRUE
      else
      {
          return (0);
      }

      if (networkOn)
      {
         //pktID is used to pass the index
         AWSockets[pktID]->newReader = atoi(AssignReaderNewIDEdit->Text.c_str());
      }

      str = "Configuring Reader ID ";
      str += rdrID;
      StaticText->Caption = str;

      //if (ReaderIDComboBox->Text.data() != NULL)
         //TxReaderIDLabel->Caption = ReaderIDComboBox->Text;
      if (AssignReaderIDComboBox->Text.data() != NULL)
         TxReaderIDLabel->Caption = AssignReaderIDComboBox->Text;
      else
         TxReaderIDLabel->Caption = "";

      TxCommandLabel->Caption = "Config Reader";
   }
   else if (Command == QUERY_READER)  //0x0F
   {
      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0x0F;           //command

      if (AssignReaderGroupBox->Visible)   //Config reader screen **************
      {
          if (AssignReaderHostIDEdit->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Host ID!",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST);
            return (0);
         }

         if (AssignReaderBroadcastReaderCheckBox->Checked)
         {
            XBuf[2] = 0x03;   //Len
            XBuf[3] = 0x0A;   //00 001 010
            XBuf[4] = atoi(AssignReaderHostIDEdit->Text.c_str());   //host ID
            XBuf[5] = 0xA7;  //pkt ID
            index = 6;
            StaticText->Caption = "Searching for all Readers";
         }
         else if (AssignReaderIDComboBox->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Reader ID!",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST);
            return (0);
         }
         else
         {
            rdrID = atoi(AssignReaderIDComboBox->Text.c_str());
            str = "Searching for Reader ID ";
            str += rdrID;
            StaticText->Caption = str;
            if (rdrID <= 255)  //reg reader
            {
               XBuf[2] = 0x04;   //Len
               XBuf[3] = 0x0A;   //00 001 010
               XBuf[4] = atoi(AssignReaderHostIDEdit->Text.c_str());   //host ID
               XBuf[5] = rdrID;  //reader ID
               XBuf[6] = 0xA7;  //pkt ID
               index = 7;
            }
            else    //extended
            {
               XBuf[2] = 0x05;   //Len
               XBuf[3] = 0x0E;   //00 001 110
               XBuf[4] = atoi(AssignReaderHostIDEdit->Text.c_str());  //host ID
               AnsiString str = IntToHex(rdrID, 4);
               XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
               str = str.SubString(3,2);
               XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
               XBuf[7] = 0xA7;   //pkt ID
               index = 8;
            }
         }
      }  //if config reader screen
      else    //Query Reader
      {
         if (QueryReaderHostIDEdit->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Host ID!",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST);
            QueryReaderBitBtn->Enabled = true;
            return (0);
         }

         if (QueryReaderBroadcastRdrCheckBox->Checked)  //QUERY READER SCREEN
         {
            //XBuf[2] = 0x03;   //Len
            //XBuf[3] = 0x0A;   //00 001 010
            //XBuf[4] = atoi(QueryReaderHostIDEdit->Text.c_str());   //host ID
            //XBuf[5] = 0xA7;  //pkt ID
            //index = 6;
            //StaticText->Caption = "Searching for all Readers";

            rdrID = 0x00;  //global reader ID
         }
         else if (QueryReaderIDComboBox->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Reader ID!",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST);
            QueryReaderBitBtn->Enabled = true;
            return (0);
         }
         else
         {
            rdrID = atoi(QueryReaderIDComboBox->Text.c_str());
         }

         if (rdrID == 0x00)
            StaticText->Caption = "Searching for all Readers";
         else
         {
            str = "Searching for Reader ID ";
            str += rdrID;
            StaticText->Caption = str;
         }

         if (rdrID <= 255)  //reg reader
         {
            XBuf[2] = 0x04;   //Len
            XBuf[3] = 0x0A;   //00 001 010
            XBuf[4] = atoi(QueryReaderHostIDEdit->Text.c_str());   //host ID
            XBuf[5] = rdrID;  //reader ID
            XBuf[6] = 0xA7;  //pkt ID
            index = 7;
         }
         else    //extended
         {
            XBuf[2] = 0x05;   //Len
            XBuf[3] = 0x0E;   //00 001 110
            XBuf[4] = atoi(QueryReaderHostIDEdit->Text.c_str());  //host ID
            AnsiString str = IntToHex(rdrID, 4);
            XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
            str = str.SubString(3,2);
            XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
            XBuf[7] = 0xA7;   //pkt ID
            index = 8;
         }


         if (QueryReaderIDComboBox->Text.data() != NULL)
            TxReaderIDLabel->Caption = QueryReaderIDComboBox->Text;
         else
            TxReaderIDLabel->Caption = "";

         TxCommandLabel->Caption = "Query Reader";
      }   //Query reader screen *****
   }
   else if (Command == DEFINE_TAG_READER)   //0x10
   {
      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0x10;           //command

      if (AssignTagRdrHostIDEdit->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Host ID",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         AssignTagRdrBitBtn->Enabled = true;
         return (0);
      }


      if (AssignTagRdrTagRdrIDComboBox->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Assigned Reader ID",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         AssignTagRdrBitBtn->Enabled = true;
         return (0);
      }

      if (AssignTagRdrBroadcastRdrCheckBox->State == cbChecked)
         rdrID = 0x00;
      else if (AssignTagRdrRdrIDComboBox->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Reader ID",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         AssignTagRdrBitBtn->Enabled = true;
         return (0);
      }
      else
         rdrID = atoi(AssignTagRdrRdrIDComboBox->Text.c_str());

      if (rdrID <= 255)  //reg reader
      {
         //XBuf[2] = 0x07;   //Len
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(AssignTagRdrHostIDEdit->Text.c_str());   //host ID
         XBuf[5] = rdrID;  //reader ID
         index = 6;
      }
      else    //extended
      {
         //XBuf[2] = 0x08;   //Len
         XBuf[3] = 0x0E;   //00 001 110
         XBuf[4] = atoi(AssignTagRdrHostIDEdit->Text.c_str());   //host ID
         AnsiString str = IntToHex(rdrID, 4);
         XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
         str = str.SubString(3,2);
         XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
         index = 7;
      }

      int tagTypeVal = 0;

      if (AssignTagRdrTagTypeComboBox->Text != "All Types")
      {
          if (AssignTagRdrTagTypeComboBox->Text == "Factory")
          {
             tagTypeVal = 6;   //one will be added later
          }
          else if ((tagTypeVal=GetIndexTagType(AssignTagRdrTagTypeComboBox->Text)) < 0)
          {
              Application->MessageBox("Error in calculating tag type index",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
              AssignTagRdrLongRNDRadioButton->Enabled = true;
              return (0);
          }

          tagTypeVal += 1;
          XBuf[index] = (tagTypeVal << 5);

          if (AssignTagRdrTagIDRangeRadioButton->Checked)
          {
             if (AssignTagRdrTagIDRangeComboBox->Text.data() == NULL)
             {
                 Application->MessageBox("Error: Need value for the Range",
                                         "Programming Station Information Dialog",
                                         MB_OK | MB_ICONSTOP | MB_TOPMOST);
                 AssignTagRdrBitBtn->Enabled = true;
                 return (0);
             }
             XBuf[index] |= GetRangeIndex(atoi(AssignTagRdrTagIDRangeComboBox->Text.c_str()));
             XBuf[index] |= 0x10;  //xxx 1 xxxx
         }
         else
         {
            if (AssignTagRdrLongRNDRadioButton->Checked)
               XBuf[index] |= 0x01; //0000 0001    //long
            else
               XBuf[index] &= 0xFE; //1111 1110    //short
         }

         initLen += 1;
         index += 1;

     }//!= "All Types"

      /*//if (AssignTagRdrTagIDRangeRadioButton->Checked)
      {
         if (AssignTagRdrAccRadioButton->Checked)
           XBuf[index] = 0x20;  //001 0 0000
         else if (AssignTagRdrInvRadioButton->Checked)
           XBuf[index] = 0x40;  //010 0 0000
         else if (AssignTagRdrAssRadioButton->Checked)
           XBuf[index] = 0x60;  //011 0 0000

         XBuf[index] |= 0x02;  //set ass rdr bit 0000 00010

         if (AssignTagRdrTagIDRangeRadioButton->Checked)
         {
               if (AssignTagRdrTagIDRangeComboBox->Text.data() == NULL)
               {
                   Application->MessageBox("Error: Need value for the Range",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   AssignTagRdrBitBtn->Enabled = true;
                   return (0);
               }
               XBuf[index] |= GetRangeIndex(atoi(AssignTagRdrTagIDRangeComboBox->Text.c_str()));
               XBuf[index] |= 0x10;  //xxx 1 xxxx
         }
         else
         {
             if (AssignTagRdrLongRNDRadioButton->Checked)
                XBuf[index] |= 0x01;  //long
         }

         index += 1;
      } */

      if (!AssignTagRdrAnyTagIDRadioButton->Checked) //||
            //AssignTagRdrTagIDRangeRadioButton->Checked)
      {
         __int64  n = ((unsigned long)atol(AssignTagRdrTagIDEdit->Text.c_str()));
         AnsiString s = IntToHex(n, 8);
         XBuf[index] = HexToInt(s.c_str(), 2);
         index += 1;
         AnsiString s1 = s.SubString(3,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
         s1 = s.SubString(5,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         s1 = s.SubString(7,2);
         index += 1;
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
      }

      if (AssignTagRdrTagRdrIDComboBox->Text == "Any Reader")
         rdrID = 0x00;
      else
         rdrID = atoi(AssignTagRdrTagRdrIDComboBox->Text.c_str());
         //rdrID = 0x00;
      assignedTagRdrID = rdrID;
      if (rdrID <= 255)  //reg reader
      {
         XBuf[index] = rdrID;  //reader ID
         index += 1;
      }
      else    //extended
      {
         AnsiString str = IntToHex(rdrID, 4);
         XBuf[index] = HexToInt(str.c_str(), 2);   //reader ID
         str = str.SubString(3,2);
         index += 1;
         XBuf[index] = HexToInt(str.c_str(), 2);   //reader ID
         index += 1;
      }

      XBuf[index] = 0x77;   //pktid
      index += 1;
      XBuf[2] = index - 3;   //Len

      TxCommandLabel->Caption = "Assign Tag Reader";

   } //0x10
   else if (Command == CONFIG_TAG_RND)   //0x12
   {
      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0x12;           //command

      if (ConfigTagRNDHostIDEdit->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Host ID",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         ConfigTagRNDBitBtn->Enabled = true;
         return (0);
      }

      if ((ConfigTagRNDRdrIDComboBox->Text.data() == NULL) &&
          (!AssignTagRdrBroadcastRdrCheckBox->Checked))
      {
         Application->MessageBox("Error: Need Reader ID",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         ConfigTagRNDBitBtn->Enabled = true;
         return (0);
      }

      if (ConfigTagRNDShortUpEdit->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Value for UPPER Byte - Short Random Num Period",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         ConfigTagRNDBitBtn->Enabled = true;
         return (0);
      }

      if (ConfigTagRNDShortLowEdit->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Value for LOWER Byte - Short Random Num Period",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         ConfigTagRNDBitBtn->Enabled = true;
         return (0);
      }

      if (ConfigTagRNDLongUpEdit->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Value for UPPER Byte - Long Random Num Period",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         ConfigTagRNDBitBtn->Enabled = true;
         return (0);
      }

      if (ConfigTagRNDLongLowEdit->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Value for LOWER Byte - Long Random Num Period",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         ConfigTagRNDBitBtn->Enabled = true;
         return (0);
      }

      if (atoi(ConfigTagRNDShortUpEdit->Text.c_str()) -  atoi(ConfigTagRNDShortLowEdit->Text.c_str())  < 50)
      {
         Application->MessageBox("Error: Short Random Num Period - Upper Byte should be at least 50 msec greater than Lower Byte",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         ConfigTagRNDBitBtn->Enabled = true;
         return (0);
      }

      if (atoi(ConfigTagRNDLongUpEdit->Text.c_str()) -  atoi(ConfigTagRNDLongLowEdit->Text.c_str())  < 50)
      {
         Application->MessageBox("Error: Long Random Num Period - Upper Byte should be at least 50 msec greater than Lower Byte",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         ConfigTagRNDBitBtn->Enabled = true;
         return (0);
      }

      if (ConfigTagRNDBroadcastCheckBox->State == cbChecked)
         rdrID = 0x00;
      else
         rdrID = atoi(ConfigTagRNDRdrIDComboBox->Text.c_str());

      if (rdrID <= 255)  //reg reader
      {
         //XBuf[2] = 0x07;   //Len
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(ConfigTagRNDHostIDEdit->Text.c_str());   //host ID
         XBuf[5] = rdrID;  //reader ID
         index = 6;
      }
      else    //extended
      {
         //XBuf[2] = 0x08;   //Len
         XBuf[3] = 0x0E;   //00 001 110
         XBuf[4] = atoi(ConfigTagRNDHostIDEdit->Text.c_str());   //host ID
         AnsiString str = IntToHex(rdrID, 4);
         XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
         str = str.SubString(3,2);
         XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
         index = 7;
      }

      int tagTypeVal = 0;

      if (ConfigTagRNDTagTypeComboBox->Text != "All Types")
      {
          if (ConfigTagRNDTagTypeComboBox->Text == "Factory")
          {
             tagTypeVal = 6;   //one will be added later
          }
          else if ((tagTypeVal=GetIndexTagType(ConfigTagRNDTagTypeComboBox->Text)) < 0)
          {
              Application->MessageBox("Error in calculating tag type index",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
              ConfigTagRNDBitBtn->Enabled = true;
              return (0);
          }

          tagTypeVal += 1;
          XBuf[6] = (tagTypeVal << 5);

          if (ConfigTagRNDTagIDRangeRadioButton->Checked)
          {
             if (ConfigTagRNDTagIDRangeComboBox->Text.data() == NULL)
             {
                 Application->MessageBox("Error: Need value for the Range",
                                         "Programming Station Information Dialog",
                                         MB_OK | MB_ICONSTOP | MB_TOPMOST);
                 ConfigTagRNDBitBtn->Enabled = true;
                 return (0);
             }
             XBuf[6] |= GetRangeIndex(atoi(ConfigTagRNDTagIDRangeComboBox->Text.c_str()));
             XBuf[6] |= 0x10;  //xxx 1 xxxx
          }
          else
          {
            if (ConfigTagRNDLongRespRadioButton->Checked)
               XBuf[6] |= 0x01; //0000 0001    //long
            else
               XBuf[6] &= 0xFE; //1111 1110    //short
          }

          initLen += 1;
          index += 1;
      }//!= "All Types"

      /*if (!ConfigTagRNDAnyTypeRadioButton->Checked)
      {
         if (ConfigTagRNDAccRadioButton->Checked)
           XBuf[index] = 0x20;  //001 0 0000
         else if (ConfigTagRNDInvRadioButton->Checked)
           XBuf[index] = 0x40;  //010 0 0000
         else if (ConfigTagRNDAssRadioButton->Checked)
           XBuf[index] = 0x60;  //011 0 0000

         if (ConfigTagRNDTagIDRangeRadioButton->Checked)
         {
             if (ConfigTagRNDTagIDRangeComboBox->Text.data() == NULL)
             {
                   Application->MessageBox("Error: Need value for the Range",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   QueryTagBitBtn->Enabled = true;
                   return (0);
             }
             XBuf[index] |= GetRangeIndex(atoi(ConfigTagRNDTagIDRangeComboBox->Text.c_str()));
             XBuf[index] |= 0x10;  //xxx 1 xxxx
         }
         else
         {
            if (ConfigTagRNDLongRespRadioButton->Checked)
               XBuf[index] |= 0x01;
         }

         index += 1;
      }*/

      if ((ConfigTagRNDTagIDRadioButton->Checked) ||
           ConfigTagRNDTagIDRangeRadioButton->Checked)
      {
         if (ConfigTagRNDTagIDEdit->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Tag ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST );
            ConfigTagRNDBitBtn->Enabled = true;
            return (0);
         }

         __int64  n = ((unsigned long)atol(ConfigTagRNDTagIDEdit->Text.c_str()));
         AnsiString s = IntToHex(n, 8);
         XBuf[index] = HexToInt(s.c_str(), 2);
         index += 1;
         AnsiString s1 = s.SubString(3,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
         s1 = s.SubString(5,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         s1 = s.SubString(7,2);
         index += 1;
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
      }

      XBuf[index] = atoi(ConfigTagRNDShortUpEdit->Text.c_str());
      index += 1;
      XBuf[index] = atoi(ConfigTagRNDShortLowEdit->Text.c_str());
      index += 1;

      XBuf[index] = atoi(ConfigTagRNDLongUpEdit->Text.c_str());
      index += 1;
      XBuf[index] = atoi(ConfigTagRNDLongLowEdit->Text.c_str());
      index += 1;

      /*rdrID = atoi(AssignTagRdrTagRdrIDComboBox->Text.c_str());
      if (rdrID <= 255)  //reg reader
      {
         XBuf[index] = rdrID;  //reader ID
         index += 1;
      }
      else    //extended
      {
         AnsiString str = IntToHex(rdrID, 4);
         XBuf[index] = HexToInt(str.c_str(), 2);   //reader ID
         str = str.SubString(3,2);
         index += 1;
         XBuf[index] = HexToInt(str.c_str(), 2);   //reader ID
         index += 1;
      }*/

      XBuf[index] = 0x99;   //pktid
      index += 1;
      XBuf[2] = index - 3;   //Len

      TxCommandLabel->Caption = "Config Tag RND";

   } //0x12
   else if (Command == CONFIG_FIELD_GEN)    //0x20
            //(Command == CONFIG_TX_TIME))
   {
      if (ConfigFGenGroupBox->Visible)  //configuration of Field Generator *****
      {
         if (FGenConfigHostIDEdit->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Host ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST );
            return (0);
         }

         if (FGenConfigFieldGenIDEdit->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Field Generator ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST);
            return (0);
         }

         if (FGenConfigTxTimeModifyCheckBox->Checked)
         {
            if (FGenConfigTxTimeComboBox->Text.data() == NULL)
            {
               //if (!FGenConfigActivePIRCheckBox->Checked)
               //{
                  Application->MessageBox("Error: Need Transmit Time",
                                          "Programming Station Information Dialog",
                                          MB_OK | MB_ICONSTOP | MB_TOPMOST);
                  return (0);
               //}
            }

            int xt = atoi(SFGenConfigTxTimeComboBox->Text.c_str());  //0011 1111
            if (xt > 31)
            {
                Application->MessageBox("Transmit Time Value should be between 1-31",
                                        "Programming Station Information Dialog",
                                        MB_OK | MB_ICONSTOP | MB_TOPMOST);
                return (0);
            }
         }

         if (FGenConfigWaitTimeModifyCheckBox->Checked)
         {
            if (FGenConfigWaitTimeComboBox->Text.data() == NULL)
            {
               //if (!FGenConfigWaitTimeAllRadioButton->Checked)
               //{
                  Application->MessageBox("Error: Need Wait Time",
                                          "Programming Station Information Dialog",
                                          MB_OK | MB_ICONSTOP | MB_TOPMOST);
                  return (0);
               //}
            }
         }

         if (FGenConfigFGenIDModifyCheckBox->Checked)
         {
            if (FGenConfigFGenIDEdit->Text.data() == NULL)
            {
               Application->MessageBox("Error: Need New Field Generator ID",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
               return (0);
            }
            else if (atoi(FGenConfigFGenIDEdit->Text.c_str()) == 0)
            {
               Application->MessageBox("Error: New Field Generator ID Can Not Be Zero",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
               return (0);
            }
            else if (atoi(FGenConfigFGenIDEdit->Text.c_str()) > 250)
            {
               Application->MessageBox("Error: New Field Generator ID Can Not Be Larger Than 250",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
               return (0);
            }
         }

         if (FGenConfigAssignedReaderIDModifyCheckBox->Checked)
         {
            if (FGenConfigAssignedReaderIDEdit->Text.data() == NULL)
            {
               Application->MessageBox("Error: Need Reader ID",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
               return (0);
            }
         }

         if (FGenConfigTagIDModifyCheckBox->Checked)
         {
            if (FGenConfigTagIDRadioButton->Checked)
            {
               if (FGenConfigTagIDEdit->Text.data() == NULL)
               {
                  Application->MessageBox("Error: Need Tag ID",
                                          "Programming Station Information Dialog",
                                          MB_OK | MB_ICONSTOP | MB_TOPMOST);
                  return (0);
               }
            }
         }

         XBuf[0] = 0x7E;      // start of Packet
         XBuf[1] = 0x20;      //command
         XBuf[2] = 0x04;      //len
         initLen = 4;
         XBuf[3] = 0x08;      //packet type
         XBuf[4] = atoi(FGenConfigHostIDEdit->Text.c_str());   //host ID
         XBuf[5] = atoi(FGenConfigFieldGenIDEdit->Text.c_str());   //FG ID
         XBuf[6] = 0x00;      //config byte
         index = 7;

         if (FGenConfigAssignedReaderIDModifyCheckBox->Checked)   //rdr ID
         {
            XBuf[index] = atoi(FGenConfigAssignedReaderIDEdit->Text.c_str());
            configByte |= 0x02;    //0000 0010
            initLen += 1;
            index += 1;
         }

         if (FGenConfigFGenIDModifyCheckBox->Checked)   //fg ID
         {
            newFGID = FGenConfigFGenIDEdit->Text;
            XBuf[index] = atoi(FGenConfigFGenIDEdit->Text.c_str());
            configByte |= 0x01;    //0000 0001
            initLen += 1;
            index += 1;
         }

         if (FGenConfigTxTimeModifyCheckBox->Checked)   //tx time
         {
            XBuf[index] = atoi(FGenConfigTxTimeComboBox->Text.c_str());

            if (FGenConfigEnableISCheckBox->Checked)  //Enable Internal Sensor
               XBuf[index] |= 0x20;  //0010 0000

            if (FGenConfigMDActiveHiRadioButton->Checked)
               XBuf[index] |= 0x80; //1000 0000
            if (FGenConfigMDEnableCheckBox->Checked)
               XBuf[index] |= 0x40; //0100 0000

            configByte |= 0x04;    //0000 0100
            initLen += 1;
            index += 1;
         }

         if (FGenConfigWaitTimeModifyCheckBox->Checked)   //wait time
         {
               //if (FGenConfigWaitTimeCheckBox->Checked)
               {
                    if (FGenConfigWaitTimeSecRadioButton->Checked)
                        XBuf[index] = 0x00; //00 00 0000  sec
                    else if (FGenConfigWaitTimeMinRadioButton->Checked)
                        XBuf[index] = 0x40; //01 00 0000  min
                    else
                     XBuf[index] = 0x80; //10 00 0000  hour

                    //XBuf[index] = 0x00; //00 00 0000  sec
                    XBuf[index] |= atoi(FGenConfigWaitTimeComboBox->Text.c_str());

                    initLen += 1;
                    index += 1;
                }

                //if (FGenConfigHoldTimeCheckBox->Checked)
                {
                    if (stdFGenType > 0)
                    {
                       XBuf[index] = atoi(FGenConfigHoldTimeComboBox->Text.c_str());
                       initLen += 1;
                       index += 1;
                    }

                    configByte |= 0x08;    //0000 1000
                }
          }

          if ((FGenConfigTagTypeModifyCheckBox->Checked) ||  //tag type & RN RA
             (FGenConfigRaRnModifyCheckBox->Checked))
         {
            if (FGenConfigRaRnModifyCheckBox->Checked)
            {
                if (FGenConfigRNShortRadioButton->Checked)
                {
                   configByte |= 0x10;    //0001 0000
                   XBuf[index] = 0x00;    //short
                }
                else
                {
                   configByte |= 0x10;    //0001 0000
                   XBuf[index] = 0x01;    //long
                }
            }
            else
               XBuf[index] = 0x00;

            if (FGenConfigTagRdrIDModifyCheckBox->Checked)
            {
                configByte |= 0x20;    //0010 0000

                if (FGenConfigTagRdrIDCheckBox->Checked)
                   XBuf[index] |= 0x02;    //Tag reader ID assigned
            }


            if (FGenConfigTagTypeComboBox->Text == "All Types")
                XBuf[index] |= 0x00;
            else
                XBuf[index] |= GetTagTypeValue(FGenConfigTagTypeComboBox->ItemIndex);

            if (FGenConfigLEDCheckBox->Checked)      //LED Enable
                XBuf[index] |= 0x04;                 //0000 0100

            if (FGenConfigSPKCheckBox->Checked)      //SPK Enable
                XBuf[index] |= 0x08;                 //0000 1000


            /*if (FGenConfigAccessRadioButton->Checked)
               XBuf[index] |= 0x20;
            else if (FGenConfigInventoryRadioButton->Checked)
               XBuf[index] |= 0x40;
            else if (FGenConfigAssetRadioButton->Checked)
               XBuf[index] |= 0x60;*/

            configByte |= 0x80;    //1000 0000
            initLen += 1;
            index += 1;
         }//tag type

         /*else if (FGenConfigRaRnModifyCheckBox->Checked)   //RN RA
         {
            if (FGenConfigRNShortRadioButton->Checked)
            {
               configByte |= 0x10;    //0001 0000    //RN
               XBuf[index] = 0x01;
            }
            else
            {
               configByte |= 0x20;    //0010 0000    //RA
               XBuf[index] = 0x02;
            }

            initLen += 1;
            index += 1;
         }*/

         if (FGenConfigTagIDModifyCheckBox->Checked)   //tag ID
         {
            if (FGenConfigTagIDRadioButton->Checked)
            {
               __int64  n = ((unsigned long)atol(FGenConfigTagIDEdit->Text.c_str()));
               AnsiString s = IntToHex(n, 8);
               XBuf[index] = HexToInt(s.c_str(), 2);
               index += 1;
               AnsiString s1 = s.SubString(3,2);
               XBuf[index] = HexToInt(s1.c_str(), 2);
               index += 1;
               s1 = s.SubString(5,2);
               XBuf[index] = HexToInt(s1.c_str(), 2);
               s1 = s.SubString(7,2);
               index += 1;
               XBuf[index] = HexToInt(s1.c_str(), 2);
               index += 1;

               configByte |= 0x40;    //0100 0000    //tag id
               initLen += 4;
            }
            else    //Any Tag ID ??
            {
               XBuf[index] = 0x00;
               index += 1;
               XBuf[index] = 0x00;
               index += 1;
               XBuf[index] = 0x00;
               index += 1;
               XBuf[index] = 0x00;
               index += 1;

               configByte |= 0x40;    //0100 0000    //tag id
               initLen += 4;
            }
         }//tag ID

         XBuf[index] = 0xDC;   //pkt ID
         index += 1;
         initLen += 1;
         XBuf[2] = initLen;      //len
         XBuf[6] = configByte;   //config byte

         FieldGenIDLabel01->Visible = true;
         FieldGenIDLabel->Visible = true;
         if (QueryFGenIDEdit->Text.data() == NULL)
            FieldGenIDLabel->Caption = "0";
         else
            FieldGenIDLabel->Caption = QueryFGenIDEdit->Text;
         TxCommandLabel->Caption = "Config Field Generator";
      } //if page visible
      else if (AssignReaderGroupBox->Visible)   //Configuration of TX, WT for Reader configuation
      {                                         //===============================================
          //if ((AssignReaderModifyTXCheckBox->Checked) &&
          if (AssignReaderTXComboBox->Text.data() == NULL)
          {
              Application->MessageBox( "Error: Transmit Time.",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
               AssignReaderBitBtn->Enabled = true;
               return (0);
          }

          //if ((AssignReaderModifyWTCheckBox->Checked) &&
          if ((AssignReaderWTComboBox->Text.data() == NULL) && fGenConfigFlag)
          {
               Application->MessageBox( "Error: Wait Time.",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
               AssignReaderBitBtn->Enabled = true;
               return (0);
          }

          XBuf[0] = 0x7E;      // start of Packet
          XBuf[1] = 0x20;      //command
          //XBuf[2] = 0x04;      //len
          XBuf[4] = atoi(AssignReaderHostIDEdit->Text.c_str());   //host ID
          rdrID = atoi(AssignReaderIDComboBox->Text.c_str());
          if (rdrID > 255)
          {
             XBuf[3] = 0x0E;
             AnsiString str = IntToHex(rdrID, 4);
             XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
             str = str.SubString(3,2);
             XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
             index = 7;
          }
          else
          {
             XBuf[3] = 0x0A;   //00 001 010
             XBuf[5] = rdrID;
             index = 6;
          }


         //if (AssignReaderModifyTXCheckBox->Checked)   //tx time
         {
            XBuf[index] = atoi(AssignReaderTXComboBox->Text.c_str());
            //This Part is commented out till dennis fix the bug  DEC 14, 04
            /*if (rdrConfigTxFlag)
            {
               if (AssignReaderMDActiveHiRadioButton->Checked)
                  XBuf[index] |= 0x80; //1000 0000
               if (AssignReaderEnableMDCheckBox->Checked)
                  XBuf[index] |= 0x40; //0100 0000
            }*/
            index += 1;
         }

         //if (AssignReaderModifyWTCheckBox->Checked)   //wait time
         if (rdrConfigTxFlag)
         {
            if (AssignReaderWTSecRadioButton->Checked)
                 XBuf[index] = 0x00; //00 00 0000  sec
            else if (AssignReaderWTMinRadioButton->Checked)
                 XBuf[index] = 0x40; //01 00 0000  min
            else
                 XBuf[index] = 0x80; //10 00 0000  hour

            XBuf[index] |= atoi(AssignReaderWTComboBox->Text.c_str());
            index += 1;

            TxCommandLabel->Caption = "Config Rdr Field Gen";
         }
         else
         {
            XBuf[index] = 0x00;
            index += 1;

            TxCommandLabel->Caption = "Config Rdr TX time";
         }

         XBuf[index] = 0xC3;   //pkt ID
         index += 1;
         XBuf[2] = index - 3;   //len

      }//if assign reader page visible
   }
   else if (Command == CONFIG_SMART_FIELD_GEN)    //0x96
   {
      if (ConfigSFGenGroupBox->Visible)
      {
         if (SFGenConfigHostIDEdit->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Host ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST );
            return (0);
         }

         if (FGenConfigSmartFieldGenIDComboBox->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Field Generator ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST);
            return (0);
         }

         if (FGenConfigSmartFGenReaderIDComboBox->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Reader ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST );
            return (0);
         }

         XBuf[0] = 0x7E;      // start of Packet
         XBuf[1] = 0x39;      //command
         XBuf[2] = 0x04;      //len
         initLen = 4;
         XBuf[4] = atoi(SFGenConfigHostIDEdit->Text.c_str());   //host ID
         rdrID = atoi(FGenConfigSmartFGenReaderIDComboBox->Text.c_str());  //readerID
         if (rdrID >= 255)
         {
            XBuf[3] = 0x0E;      //packet type - extended reader
            AnsiString str = IntToHex(rdrID, 4);
            XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
            str = str.SubString(3,2);
            XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
            index = 7;
         }
         else
         {
            XBuf[3] = 0x0A;      //packet type - reg reader
            XBuf[5] = rdrID;    //rdr ID
            index = 6;
         }

         XBuf[index] = 0x0B;      //Write command
         index += 1;

         XBuf[index] = 0x10;      //packet type  00 010 000  host->Fgen
         index += 1;

         XBuf[index] = atoi(FGenConfigSmartFieldGenIDComboBox->Text.c_str());   //FG ID
         index += 1;


         //bool modify = false;
         //unsigned short chgCount = 0;
         unsigned char fgenID = 0;
         //unsigned short assRdrID = 0;
         unsigned char xTime = 0x00;
         unsigned char wTime = 0x00;
         unsigned char tType = 0;
         unsigned int  tagID = 0;
         //unsigned short pot = 0;
         //unsigned short inx = index;
         unsigned char chgBits = 0x00;

         //0000 0000 chgBit
         //0000 0001 new fgen
         //0000 0010 assign reaer
         //0000 0100 xtime
         //0000 1000 wtime
         //0001 0000 tagType
         //0010 0000 tagID
         //0100 0000 dpot
         //1000 0000 md

         //txtime ----------------------------
         if (SFGenConfigTxTimeComboBox->Text.data() == NULL)
         {
             if (SFGenConfigTxTimeModifyCheckBox->Checked)
             {
                 Application->MessageBox("Error: Need Transmit Time",
                                         "Programming Station Information Dialog",
                                         MB_OK | MB_ICONSTOP | MB_TOPMOST);
                 return (0);
             }
             else if (SFGenConfigMDCheckBox->Checked)
             {
                 Application->MessageBox("Transmit Time Modify Check Box needs to be checked",
                                         "Programming Station Information Dialog",
                                         MB_OK | MB_ICONSTOP | MB_TOPMOST);
                 return (0);
             }
         }

         xTime = atoi(SFGenConfigTxTimeComboBox->Text.c_str());  //0011 1111
         if (xTime > 60)
         {
             Application->MessageBox("Transmit Time Value should be between 1-60",
                                     "Programming Station Information Dialog",
                                     MB_OK | MB_ICONSTOP | MB_TOPMOST);
             return (0);
         }

         if (SFGenConfigMDActiveHiRadioButton->Checked)
            xTime |= 0x80; //1000 0000
         if (SFGenConfigMDEnableCheckBox->Checked)
            xTime |= 0x40; //0100 0000

         //wait time ---------------------------------
         if ((SFGenConfigWaitTimeComboBox->Text.data() == NULL) &&
             SFGenConfigWaitTimeModifyCheckBox->Checked)
         {
               Application->MessageBox("Error: Need Wait Time",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
                  return (0);
         }

         wTime = atoi(SFGenConfigWaitTimeComboBox->Text.c_str());
         if (SFGenConfigWaitTimeMinRadioButton->Checked)
            wTime |= 0x40;
         else if (SFGenConfigWaitTimeHourRadioButton->Checked)
            wTime |= 0x80;

         //field gen id ---------------------------
         if (SFGenConfigFGenIDModifyCheckBox->Checked)
         {
            if (SFGenConfigFGenIDEdit->Text.data() == NULL)
            {
                Application->MessageBox("Error: Need New Field Generator ID",
                                        "Programming Station Information Dialog",
                                        MB_OK | MB_ICONSTOP | MB_TOPMOST);
                return (0);
            }

            fgenID = atoi(SFGenConfigFGenIDEdit->Text.c_str());
            if (fgenID == 0)
            {
               Application->MessageBox("Error: New Field Generator ID Can Not Be Zero",
                                        "Programming Station Information Dialog",
                                        MB_OK | MB_ICONSTOP | MB_TOPMOST);
                return (0);
            }
            else if (fgenID > 250)
            {
                Application->MessageBox("Error: New Field Generator ID Can Not Be larger than 250",
                                        "Programming Station Information Dialog",
                                        MB_OK | MB_ICONSTOP | MB_TOPMOST);
                return (0);
            }
         }
         else
           fgenID = atoi(FGenConfigSmartFieldGenIDComboBox->Text.c_str());

         //tag id ----------------------------------
         if ((SFGenConfigTagIDEdit->Text.data() == NULL) &&
              SFGenConfigTagIDRadioButton->Checked && SFGenConfigTagIDModifyCheckBox->Checked)
         {
               Application->MessageBox("Error: Need Tag ID",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
               return (0);
         }

         tagID = ((unsigned int)atol(SFGenConfigTagIDEdit->Text.c_str()));

         //tag type ra/rn -----------------------
         if (SFGenConfigTagTypeComboBox->Text == "All Types")
             XBuf[index] |= 0x00;
         else
             XBuf[index] |= GetTagTypeValue(SFGenConfigTagTypeComboBox->ItemIndex);

         /*if (SFGenConfigAccessRadioButton->Checked)
              tType = 0x20;  //001 0 0000
         else if (SFGenConfigInventoryRadioButton->Checked)
              tType = 0x40;  //010 0 0000
         else if (SFGenConfigAssetRadioButton->Checked)
              tType = 0x60;  //011 0 0000
         else
              tType = 0x00;  //000 0 0000  //any type */

         if (SFGenConfigRaRnModifyCheckBox->Checked)
         {
            tType |= 0x02;   //0000 00010  //change ra/rn
            if (SFGenConfigRALongRadioButton->Checked)
               tType |= 0x01; //long
         }
         else
         {
            if (SFGenConfigRALongRadioButton->Checked)
                  tType |= 0x01; //long
         }

         //field strength pot ----------------------
         if ((FGenConfigPotentiComboBox->Text.data() == NULL) &&
              FGenConfigPotentiModifyCheckBox->Checked)
         {
               Application->MessageBox("Error: Need Value for Field Strength",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
               return (0);
         }
         //pot = atoi(FGenConfigPotentiComboBox->Text.c_str());

         //assigned reader ID --------------------
         if (SFGenConfigAssignedReaderIDModifyCheckBox->Checked)
         {
            if (SFGenConfigAssignedReaderIDEdit->Text.data() == NULL)
            {
               Application->MessageBox("Error: Need Assigned Reader ID",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
               return (0);
            }

            rdrID = atoi(SFGenConfigAssignedReaderIDEdit->Text.c_str());
         }
         else
         {
            if (SFGenConfigAssignedReaderIDEdit->Text.data() == NULL)
               rdrID = 0;
            else
               rdrID = atoi(SFGenConfigAssignedReaderIDEdit->Text.c_str());
         }



         bool configAll = false;
         int ct = 0;
         if ((ct = GetSFGenConfigCount()) > 1)
         {
            configAll = true;
         }
         else if (ct == 0)
         {
             Application->MessageBox("No Modify Check Box is checked",
                                     "Programming Station Information Dialog",
                                     MB_OK | MB_ICONSTOP | MB_TOPMOST);
             EnableAllStaticTextCommands();
             return (0);
         }

         // populating transmit buffer -----------------------------
         //---------------------------------------------------------

         if ((SFGenConfigFGenIDModifyCheckBox->Checked) || configAll)  //fgen id
         {
            XBuf[index] = 0x40;   //address
            index += 1;

            XBuf[index] = fgenID;
            index += 1;

            //modify = true;
            //chgCount += 1;
            chgBits |= 0x01; //0000 0001 new fgen
         }

         if ((SFGenConfigAssignedReaderIDModifyCheckBox->Checked) || configAll)   //assigned rdr ID
         {
            if (!configAll)
            {
               XBuf[index] =  0x41;  //address
               index += 1;
            }

            if (rdrID >= 255)
            {
                AnsiString str = IntToHex(rdrID, 4);
                XBuf[index] = HexToInt(str.c_str(), 2);   //ext reader ID
                index += 1;
                str = str.SubString(3,2);
                XBuf[index] = HexToInt(str.c_str(), 2);   //ext reader ID
                index += 1;
             }
             else if (rdrID == 0)
             {
                Application->MessageBox("Need Assigned Reader ID. Click on 'Get Configuration' button.",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
                return (0);
             }
             else
             {
                XBuf[index] = 0x00;    //reg reader ID
                index += 1;
                XBuf[index] = rdrID;   //reg reader ID
                index += 1;
             }

            //modify = true;
            //chgCount += 1;
            chgBits |= 0x02; //0000 0010
         }

         if ((SFGenConfigTxTimeModifyCheckBox->Checked) || configAll)   //tx time
         {
            if (!configAll)
            {
               XBuf[index] = 0x43;   //address
               index += 1;
            }

            XBuf[index] = xTime;
            index += 1;
            //modify = true;
            //chgCount += 1;
            chgBits |= 0x04; //0000 0100 xtime
         }

         if ((SFGenConfigWaitTimeModifyCheckBox->Checked) || configAll)   //wait time
         {
            if (!configAll)
            {
               XBuf[index] = 0x44;   //address
               index += 1;
            }

            XBuf[index] = wTime;
            index += 1;

            //modify = true;
            //chgCount += 1;
            chgBits |= 0x08; //0000 1000 wait time
         }

         if ((SFGenConfigTagTypeModifyCheckBox->Checked) || configAll)   //tag type
         {
            if (!configAll)
            {
               XBuf[index] = 0x45;   //address
               index += 1;
            }

             XBuf[index] = tType;
             index += 1;

             //modify = true;
             //chgCount += 1;
             chgBits |= 0x10; //0001 0000 tag type
         }

         if (SFGenConfigTagIDModifyCheckBox->Checked || configAll)   //Tag ID
         {
            if (!configAll)
            {
               XBuf[index] = 0x46;    //aadress
               index += 1;
            }

            AnsiString s = IntToHex((__int64)tagID, 8);
            XBuf[index] = HexToInt(s.c_str(), 2);
            index += 1;
            AnsiString s1 = s.SubString(3,2);
            XBuf[index] = HexToInt(s1.c_str(), 2);
            index += 1;
            s1 = s.SubString(5,2);
            XBuf[index] = HexToInt(s1.c_str(), 2);
            s1 = s.SubString(7,2);
            index += 1;
            XBuf[index] = HexToInt(s1.c_str(), 2);
            index += 1;

            //modify = true;
            //chgCount += 1;
            chgBits |= 0x20; //0010 0000 tagID
         }

         /*if (FGenConfigRaRnModifyCheckBox->Checked)   //tag type  RA/RN
         {
            if (!FGenConfigTagTypeModifyCheckBox->Checked)
            {
               Application->MessageBox("Tag Type Modify Check Box needs to be checked",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
               return (0);
            }

            if (FGenConfigRaRnModifyCheckBox->Checked)
               tType |= 0x02;   //0000 00010  //change ra/rn

            XBuf[inx] =  0x45;  //address
            inx += 1;

            XBuf[inx] = tType;
            inx += 1;

            modify = true;
            chgCount += 1;
         }

         if (FGenConfigPotentiModifyCheckBox->Checked)  //Field Strength , Digital Pot
         {
            XBuf[inx] =  0x4A;  //address
            inx += 1;

            XBuf[inx] = pot;
            inx += 1;

            modify = true;
            chgCount += 1;
            chgBits |= 0x40; //0100 0000 dpot
         } */


         //------------Populating TX Buffer----------------------------------------

         if (chgBits == 0x00)
            return (0);

         if (configAll)
         {
            if (chgBits != 0x3F)
            {
               Application->MessageBox("Need to do 'Get Configuration' first.",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
               return (0);
            }
         }

         /*
            XBuf[index] = 0x40;   //start address
            index += 1;
            XBuf[index] = fgenID;
            index += 1;

            if (rdrID >= 256)
            {
                AnsiString str = IntToHex(rdrID, 4);
                XBuf[index] = HexToInt(str.c_str(), 2);   //ext reader ID
                index += 1;
                str = str.SubString(3,2);
                XBuf[index] = HexToInt(str.c_str(), 2);   //ext reader ID
             }
             else
                XBuf[index] = rdrID;   //reg reader ID

            index += 1;
            XBuf[index] = xTime;
            index += 1;
            XBuf[index] = wTime;
            index += 1;
            XBuf[index] = tType;
            index += 1;

            AnsiString s = IntToHex((__int64)tagID, 8);
            XBuf[index] = HexToInt(s.c_str(), 2);
            index += 1;
            AnsiString s1 = s.SubString(3,2);
            XBuf[index] = HexToInt(s1.c_str(), 2);
            index += 1;
            s1 = s.SubString(5,2);
            XBuf[index] = HexToInt(s1.c_str(), 2);
            s1 = s.SubString(7,2);
            index += 1;
            XBuf[index] = HexToInt(s1.c_str(), 2);
            index += 1;

            XBuf[index] = pot;
            index += 1;
         }
         else
            index = inx;
         */

         XBuf[index] = CONFIG_SMART_FIELD_GEN;    //pkt ID
         index += 1;
         XBuf[2] = index - 3;   //len

         FieldGenIDLabel01->Visible = true;
         FieldGenIDLabel->Visible = true;
         if (FGenConfigSmartFieldGenIDComboBox->Text.data() == NULL)
            FieldGenIDLabel->Caption = "0";
         else
            FieldGenIDLabel->Caption = FGenConfigSmartFieldGenIDComboBox->Text;
         TxCommandLabel->Caption = "Config Smart Field Gen";
         StaticText->Caption = "Config Smart Field Gen ...";
      } //if page visible
   }   //config smart field gen
   else if (Command == QUERY_SMART_FIELD_GEN)    //0x97
   {
      if (QuerySFGenGroupBox->Visible)    //QUERY FIELD GENERATOR -----------
      {
         if (QuerySFGenHostIDEdit->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Host ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST );
            return (0);
         }

         if ((QueryFGenSmartFGenIDComboBox->Text.data() == NULL) &&
             !QuerySFGenSmartFGenBroadcastCheckBox->Checked)
         {
            Application->MessageBox("Error: Need Field Generator ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST);
            return (0);
         }

         if (QuerySFGenSmartFGenBroadcastRdrCheckBox->Checked)
            rdrID = 0x00;
         else if (QueryFGenSmartFGenRdrIDComboBox->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Reader ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST );
            return (0);
         }
         else
            rdrID = atoi(QueryFGenSmartFGenRdrIDComboBox->Text.c_str());  //readerID

         XBuf[0] = 0x7E;      // start of Packet
         XBuf[1] = 0x39;      //command
         XBuf[4] = atoi(QuerySFGenHostIDEdit->Text.c_str());   //host ID

         if (rdrID >= 255)
         {
            XBuf[3] = 0x0E;      //packet type - extended reader
            AnsiString str = IntToHex(rdrID, 4);
            XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
            str = str.SubString(3,2);
            XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
            index = 7;
         }
         else
         {
            XBuf[3] = 0x0A;      //packet type - reg reader
            XBuf[5] = rdrID;    //rdr ID
            index = 6;
         }

         XBuf[index] = 0x0C;      //Read command
         index += 1;

         XBuf[index] = 0x10;      //packet type  00 010 000  host->Fgen
         index += 1;

         if (QuerySFGenSmartFGenBroadcastCheckBox->Checked)
         {
             if (QuerySFGenSpecificRdrRadioButton->Checked)
                XBuf[index] = 0x00;  //broadcast to All FGen
             else
                XBuf[index] = 0xFF;  //broadcast to All FGen
         }
         else
             XBuf[index] = atoi(QueryFGenSmartFGenIDComboBox->Text.c_str());   //FG ID
         index += 1;

         XBuf[index] = 0x40;      //starting address
         index += 1;

         XBuf[index] = 0x0B;      //num of bytes
         index += 1;

         XBuf[index] = QUERY_SMART_FIELD_GEN;    //Query smart pkt ID sepecific will be use in ack read
         index += 1;

         XBuf[2] = index - 3;   //len

         if (QueryFGenSmartFGenIDComboBox->Text.data() == NULL)
            FieldGenIDLabel->Caption = "0";
         else
            FieldGenIDLabel->Caption = QueryFGenSmartFGenIDComboBox->Text;
         TxCommandLabel->Caption = "Query Smart Field Gen";
      } //if page visible
      else if (ConfigSFGenGroupBox->Visible)   //CONFIG FIELD GENERATOR
      {
         if (SFGenConfigHostIDEdit->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Host ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST );
            return (0);
         }

         if (FGenConfigSmartFieldGenIDComboBox->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Field Generator ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST);
            return (0);
         }

         if (FGenConfigSmartFGenReaderIDComboBox->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Reader ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST );
            return (0);
         }

         XBuf[0] = 0x7E;      // start of Packet
         XBuf[1] = 0x39;      //command
         XBuf[4] = atoi(SFGenConfigHostIDEdit->Text.c_str());   //host ID
         rdrID = atoi(FGenConfigSmartFGenReaderIDComboBox->Text.c_str());  //readerID
         if (rdrID >= 255)
         {
            XBuf[3] = 0x0E;      //packet type - extended reader
            AnsiString str = IntToHex(rdrID, 4);
            XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
            str = str.SubString(3,2);
            XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
            index = 7;
         }
         else
         {
            XBuf[3] = 0x0A;      //packet type - reg reader
            XBuf[5] = rdrID;    //rdr ID
            index = 6;
         }

         XBuf[index] = 0x0C;      //Read command
         index += 1;

         XBuf[index] = 0x10;      //packet type  00 010 000  host->Fgen
         index += 1;

         XBuf[index] = atoi(FGenConfigSmartFieldGenIDComboBox->Text.c_str());   //FG ID
         index += 1;

         XBuf[index] = 0x40;      //starting address
         index += 1;

         XBuf[index] = 0x0B;      //num of bytes
         index += 1;

         XBuf[index] = QUERY_SMART_FIELD_GEN;    //Query smart pkt ID sepecific will be use in ack read
         index += 1;

         XBuf[2] = index - 3;   //len

         FieldGenIDLabel01->Visible = true;
         FieldGenIDLabel->Visible = true;
         if (FGenConfigSmartFieldGenIDComboBox->Text.data() == NULL)
            FieldGenIDLabel->Caption = "0";
         else
            FieldGenIDLabel->Caption = FGenConfigSmartFieldGenIDComboBox->Text;
         TxCommandLabel->Caption = "Query Smart Field Gen";
      } //if page visible
   }//query smart field gen
   else if (Command == QUERY_PROC_SMART_FIELD_GEN)    //0x98
   {

      if (QuerySFGenGroupBox->Visible)
      {
         if (QuerySFGenHostIDEdit->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Host ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST );
            return (0);
         }

         if (QueryFGenSmartFGenIDComboBox->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Field Generator ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST);
            return (0);
         }

         if (QuerySFGenSmartFGenBroadcastRdrCheckBox->Checked)
            rdrID = 0x00;
         else if (QueryFGenSmartFGenRdrIDComboBox->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Reader ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST );
            return (0);
         }
         else
            rdrID = atoi(QueryFGenSmartFGenRdrIDComboBox->Text.c_str());  //readerID

         XBuf[0] = 0x7E;      // start of Packet
         XBuf[1] = 0x39;      //command
         XBuf[4] = atoi(QuerySFGenHostIDEdit->Text.c_str());   //host ID

         if (rdrID >= 255)
         {
            XBuf[3] = 0x0E;      //packet type - extended reader
            AnsiString str = IntToHex(rdrID, 4);
            XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
            str = str.SubString(3,2);
            XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
            index = 7;
         }
         else
         {
            XBuf[3] = 0x0A;      //packet type - reg reader
            XBuf[5] = rdrID;    //rdr ID
            index = 6;
         }

         XBuf[index] = 0x0C;      //Read command
         index += 1;

         XBuf[index] = 0x10;      //packet type  00 010 000  host->Fgen
         index += 1;

         XBuf[index] = atoi(QueryFGenSmartFGenIDComboBox->Text.c_str());   //FG ID
         index += 1;

         XBuf[index] = 0xE0;      //starting address
         index += 1;

         XBuf[index] = 0x0A;      //num of bytes
         index += 1;

         XBuf[index] = QUERY_PROC_SMART_FIELD_GEN; //Query proc smart pkt ID sepecific will be use in ack read
         index += 1;

         XBuf[2] = index - 3;   //len

         if (QueryFGenSmartFGenIDComboBox->Text.data() == NULL)
            FieldGenIDLabel->Caption = "0";
         else
            FieldGenIDLabel->Caption = QueryFGenSmartFGenIDComboBox->Text;
         TxCommandLabel->Caption = "Query Proc Smart Field Gen";
      } //if page visible
   }//query proc smart field gen
   else if (Command == GET_DPOT_SMART_FGEN)    //0x99
   {

      if (QuerySFGenGroupBox->Visible)
      {
         if (QuerySFGenHostIDEdit->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Host ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST );
            return (0);
         }

         if (QueryFGenSmartFGenIDComboBox->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Field Generator ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST);
            return (0);
         }

         if (QueryFGenSmartFGenRdrIDComboBox->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Reader ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST );
            return (0);
         }

         XBuf[0] = 0x7E;      // start of Packet
         XBuf[1] = 0x39;      //command
         XBuf[4] = atoi(QuerySFGenHostIDEdit->Text.c_str());   //host ID
         rdrID = atoi(QueryFGenSmartFGenRdrIDComboBox->Text.c_str());  //readerID
         if (rdrID >= 255)
         {
            XBuf[3] = 0x0E;      //packet type - extended reader
            AnsiString str = IntToHex(rdrID, 4);
            XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
            str = str.SubString(3,2);
            XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
            index = 7;
         }
         else
         {
            XBuf[3] = 0x0A;      //packet type - reg reader
            XBuf[5] = rdrID;    //rdr ID
            index = 6;
         }

         XBuf[index] = 0x0C;      //Read command
         index += 1;

         XBuf[index] = 0x10;      //packet type  00 010 000  host->Fgen
         index += 1;

         XBuf[index] = atoi(QueryFGenSmartFGenIDComboBox->Text.c_str());   //FG ID
         index += 1;

         XBuf[index] = 0x4A;      //starting address
         index += 1;

         XBuf[index] = 0x01;      //num of bytes
         index += 1;

         XBuf[index] = GET_DPOT_SMART_FGEN; //Get dpot smart pkt ID sepecific will be use in ack read
         index += 1;

         XBuf[2] = index - 3;   //len

         if (QueryFGenSmartFGenIDComboBox->Text.data() == NULL)
            FieldGenIDLabel->Caption = "0";
         else
            FieldGenIDLabel->Caption = QueryFGenSmartFGenIDComboBox->Text;
         TxCommandLabel->Caption = "Get DPot Smart Field Gen";
      } //if Query FGen page visible
      else if (SmartFGenGroupBox->Visible)
      {
         if (SmartFGenHostIDEdit->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Host ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST );
            return (0);
         }

         if (SmartFGenIDComboBox->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Field Generator ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST);
            return (0);
         }

         if (SmartFGenReaderIDComboBox->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Reader ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST );
            return (0);
         }

         XBuf[0] = 0x7E;      // start of Packet
         XBuf[1] = 0x39;      //command
         XBuf[4] = atoi(SmartFGenHostIDEdit->Text.c_str());   //host ID
         rdrID = atoi(SmartFGenReaderIDComboBox->Text.c_str());  //readerID
         if (rdrID >= 255)
         {
            XBuf[3] = 0x0E;      //packet type - extended reader
            AnsiString str = IntToHex(rdrID, 4);
            XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
            str = str.SubString(3,2);
            XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
            index = 7;
         }
         else
         {
            XBuf[3] = 0x0A;      //packet type - reg reader
            XBuf[5] = rdrID;    //rdr ID
            index = 6;
         }

         XBuf[index] = 0x0C;      //Read command
         index += 1;

         XBuf[index] = 0x10;      //packet type  00 010 000  host->Fgen
         index += 1;

         XBuf[index] = atoi(SmartFGenIDComboBox->Text.c_str());   //FG ID
         index += 1;

         XBuf[index] = 0x4A;      //starting address
         index += 1;

         XBuf[index] = 0x01;      //num of bytes
         index += 1;

         XBuf[index] = GET_DPOT_SMART_FGEN; //Get dpot smart pkt ID sepecific will be use in ack read
         index += 1;

         XBuf[2] = index - 3;   //len

         if (SmartFGenIDComboBox->Text.data() == NULL)
            FieldGenIDLabel->Caption = "0";
         else
            FieldGenIDLabel->Caption = SmartFGenIDComboBox->Text;
         TxCommandLabel->Caption = "Get DPot Smart Field Gen";
      } //if smart FGen page visible
   }//qet dpot smart field gen
   else if ((Command == DEC_DPOT_SMART_FGEN ) || (Command == INC_DPOT_SMART_FGEN))
   {
      if (SmartFGenGroupBox->Visible)
      {
         if (SmartFGenHostIDEdit->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Host ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST );
            return (0);
         }

         if (SmartFGenIDComboBox->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Field Generator ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST);
            return (0);
         }

         if (SmartFGenReaderIDComboBox->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Reader ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST );
            return (0);
         }

         XBuf[0] = 0x7E;      // start of Packet
         XBuf[1] = 0x39;      //command
         XBuf[4] = atoi(SmartFGenHostIDEdit->Text.c_str());   //host ID
         rdrID = atoi(SmartFGenReaderIDComboBox->Text.c_str());  //readerID
         if (rdrID >= 255)
         {
            XBuf[3] = 0x0E;      //packet type - extended reader
            AnsiString str = IntToHex(rdrID, 4);
            XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
            str = str.SubString(3,2);
            XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
            index = 7;
         }
         else
         {
            XBuf[3] = 0x0A;      //packet type - reg reader
            XBuf[5] = rdrID;    //rdr ID
            index = 6;
         }

         XBuf[index] = 0x0B;      //write command
         index += 1;

         XBuf[index] = 0x10;      //packet type  00 010 000  host->Fgen
         index += 1;

         XBuf[index] = atoi(SmartFGenIDComboBox->Text.c_str());   //FG ID
         index += 1;

         XBuf[index] = 0x3F;      //Action cmd address
         index += 1;

         if (Command == INC_DPOT_SMART_FGEN)
            XBuf[index] = 0x11; //INC_DPOT_SMART_FGEN
         else
            XBuf[index] = 0x12; //DEC_DPOT_SMART_FGEN
         index += 1;

         XBuf[index] = Command; //0x9B, 0x9C
         index += 1;

         XBuf[2] = index - 3;   //len

         if (SmartFGenIDComboBox->Text.data() == NULL)
            FieldGenIDLabel->Caption = "0";
         else
            FieldGenIDLabel->Caption = SmartFGenIDComboBox->Text;
         if (Command == INC_DPOT_SMART_FGEN)
         {
            TxCommandLabel->Caption = "Inc. DPot Smart Field Gen";
            StaticText->Caption = "Increment Smart FGen Field Strength.";
         }
         else
         {
            TxCommandLabel->Caption = "Dec. DPot Smart Field Gen";
            StaticText->Caption = "Decrement Smart FGen Field Strength.";
         }

      } //if smart FGen page visible
   }//set dpot value
   else if (Command == CALL_TAG_SMART_FGEN)    //0x2A
   {

      if (SmartFGenGroupBox->Visible)
      {
         if (SmartFGenHostIDEdit->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Host ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST );
            return (0);
         }

         if (SmartFGenIDComboBox->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Field Generator ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST);
            return (0);
         }

         if (SmartFGenBroadcastAllRdrCheckBox->Checked)
            rdrID = 0x00;
         else if (SmartFGenReaderIDComboBox->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Reader ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST );
            return (0);
         }
         else
            rdrID = atoi(SmartFGenReaderIDComboBox->Text.c_str());  //readerID

         if (SmartFGenTagIDRadioButton->Checked)  //tag ID
         {
            if (SmartFGenTagIDEdit->Text.data() == NULL)
            {
               Application->MessageBox("Error: Need Tag ID",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST );
               return (0);
            }
         }

         XBuf[0] = 0x7E;      // start of Packet
         XBuf[1] = 0x39;      //command
         XBuf[4] = atoi(SmartFGenHostIDEdit->Text.c_str());   //host ID

         if (rdrID >= 255)
         {
            XBuf[3] = 0x0E;      //packet type - extended reader
            AnsiString str = IntToHex(rdrID, 4);
            XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
            str = str.SubString(3,2);
            XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
            index = 7;
         }
         else
         {
            XBuf[3] = 0x0A;      //packet type - reg reader
            XBuf[5] = rdrID;    //rdr ID
            index = 6;
         }

         XBuf[index] = 0x2A;      //Call command
         index += 1;

         XBuf[index] = 0x10;      //packet type  00 010 000  host->Fgen
         index += 1;

         if (SmartFGenBroadcastAllCheckBox->Checked)  //FG ID
            XBuf[index] = 0x00;
         else
            XBuf[index] = atoi(SmartFGenIDComboBox->Text.c_str());   //FG ID
         index += 1;

         //tag type
         XBuf[index] = 0x00;
         //if (!SmartFGenAnyTagTypeRadioButton->Checked)
         if (SmartFGenTagTypeComboBox->Text != "All Types")
         {
            int tagTypeVal = 0;

            if (SmartFGenTagTypeComboBox->Text == "Factory")
            {
               tagTypeVal = 6;   //one will be added later
            }
            else if ((tagTypeVal=GetIndexTagType(SmartFGenTagTypeComboBox->Text)) < 0)
            {
                Application->MessageBox("Error in calculating tag type index",
                                         "Programming Station Information Dialog",
                                         MB_OK | MB_ICONSTOP | MB_TOPMOST);
                SmartFGenBitBtn->Enabled = true;
                return (0);
            }

            tagTypeVal += 1;
            XBuf[index] = (tagTypeVal << 5);


            /*if (SmartFGenInventoryRadioButton->Checked)
               XBuf[index] = 0x40; //010 0 0000
            else if (SmartFGenAccessRadioButton->Checked)
               XBuf[index] = 0x20; //001 0 0000
            else if (SmartFGenAssetRadioButton->Checked)
               XBuf[index] = 0x60; //011 0 0000*/


           if (SmartFGenShortRNRadioButton->Checked)
             XBuf[index] |= 0x02; //0000 00 10    //short
           else
             XBuf[index] |= 0x03; //0000 00 11    //long

            if (SmartFGenLEDEnableRadioButton->Checked)  //TAG LED Enable
               XBuf[index] |= 0x04;    //0000 0100

            if (SmartFGenSpkEnableRadioButton->Checked)  //TAG Speaker Enable
               XBuf[index] |= 0x08;    //0000 1000

            index += 1;
         }
         else  //any type
         {
             if (SmartFGenShortRNRadioButton->Checked)
                XBuf[index] = 0x02; //0000 0010    //short
             else
                XBuf[index] = 0x03; //0000 0011    //long

             if (SmartFGenLEDEnableRadioButton->Checked)  //TAG LED Enable
                XBuf[index] |= 0x04;    //0000 0100

             if (SmartFGenSpkEnableRadioButton->Checked)  //TAG Speaker Enable
                XBuf[index] |= 0x08;    //0000 1000

             index += 1;

         }

         if (SmartFGenTagIDRadioButton->Checked)  //tag ID
         {
            __int64  n = ((unsigned long)atol(SmartFGenTagIDEdit->Text.c_str()));
            AnsiString s = IntToHex(n, 8);
            XBuf[index] = HexToInt(s.c_str(), 2);
            index += 1;
            AnsiString s1 = s.SubString(3,2);
            XBuf[index] = HexToInt(s1.c_str(), 2);
            index += 1;
            s1 = s.SubString(5,2);
            XBuf[index] = HexToInt(s1.c_str(), 2);
            s1 = s.SubString(7,2);
            index += 1;
            XBuf[index] = HexToInt(s1.c_str(), 2);
            index += 1;
         }

         //XBuf[index] = atoi(SmartFGenReaderIDComboBox->Text.c_str());   //Rdr ID
         //index += 1;

         XBuf[index] = 0xBF; //pkt id - Call tag smart fgen -  pkt ID sepecific will be use in ack read
         index += 1;

         XBuf[2] = index - 3;   //len

         if (SmartFGenIDComboBox->Text.data() == NULL)
            FieldGenIDLabel->Caption = "0";
         else
            FieldGenIDLabel->Caption = SmartFGenIDComboBox->Text;
         TxCommandLabel->Caption = "Call Tag Smart Field Gen";
      } //if page visible
   }//call tag smart fgen
   else if (Command == QUERY_FIELD_GEN) //0x21
   {
      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0x21;           //command

      //////////////////////////////////////////////////////////////////////////
      if (AssignReaderGroupBox->Visible)
      {
          if (!AssignReaderBroadcastReaderCheckBox->Checked && (AssignReaderIDComboBox->Text.data() == NULL))
          {
             Application->MessageBox("Error: Need Reader ID.",
                                     "Programming Station Information Dialog",
                                     MB_OK | MB_ICONSTOP | MB_TOPMOST);
             AssignReaderBitBtn->Enabled = true;
             return (0);
          }

          if (AssignReaderHostIDEdit->Text.data() == NULL)
          {
             Application->MessageBox("Error: Need Host ID.",
                                     "Programming Station Information Dialog",
                                     MB_OK | MB_ICONSTOP | MB_TOPMOST);
             AssignReaderBitBtn->Enabled = true;
             return (0);
          }

          hostID = atoi(AssignReaderHostIDEdit->Text.c_str());

          if (AssignReaderBroadcastReaderCheckBox->Checked)
             rdrID = 0;
          else
             rdrID = atoi(AssignReaderIDComboBox->Text.c_str());

          if (rdrID <= 255)  //standard reader
          {
             XBuf[3] = 0x0A;
             XBuf[4] = hostID;
             XBuf[5] = rdrID;
             index = 6;
         }
         else   //extended reader
         {
            XBuf[3] = 0x0E;
            XBuf[4] = hostID;
            str = IntToHex(rdrID, 4);
            XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
            str = str.SubString(3,2);
            XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
            index = 7;
         }

         XBuf[index] = 0xC0;  //pktID
         XBuf[2] = index - 2; //len
         index += 1;

         str = "Getting Configuration For Reader ";
         str += rdrID;
         StaticText->Caption = str;
         TxCommandLabel->Caption = "Get Reader Config";
      }//if Set Field Strength GroupBox
      else if (SetFStrengthGroupBox->Visible)
      {
          if (!ReaderFStrengthBroadcastCheckBox->Checked && (ReaderFStrengthReaderComboBox->Text.data() == NULL))
          {
             Application->MessageBox("Error: Need Reader ID.",
                                     "Programming Station Information Dialog",
                                     MB_OK | MB_ICONSTOP | MB_TOPMOST);
             //AssignReaderBitBtn->Enabled = true;
             return (0);
          }

          if (ReaderFStrengthHostEdit->Text.data() == NULL)
          {
             Application->MessageBox("Error: Need Host ID.",
                                     "Programming Station Information Dialog",
                                     MB_OK | MB_ICONSTOP | MB_TOPMOST);
             //AssignReaderBitBtn->Enabled = true;
             return (0);
          }

          hostID = atoi(ReaderFStrengthHostEdit->Text.c_str());

          if (ReaderFStrengthBroadcastCheckBox->Checked)
             rdrID = 0;
          else
             rdrID = atoi(ReaderFStrengthReaderComboBox->Text.c_str());

          if (rdrID <= 255)  //standard reader
          {
             XBuf[3] = 0x0A;
             XBuf[4] = hostID;
             XBuf[5] = rdrID;
             index = 6;
         }
         else   //extended reader
         {
            XBuf[3] = 0x0E;
            XBuf[4] = hostID;
            str = IntToHex(rdrID, 4);
            XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
            str = str.SubString(3,2);
            XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
            index = 7;
         }

         XBuf[index] = 0xC0;  //pktID
         XBuf[2] = index - 2; //len
         index += 1;

         str = "Getting Field Strength For Reader ";
         str += rdrID;
         StaticText->Caption = str;
         TxCommandLabel->Caption = "Get Field Strength";
      }//if Set Field Strength GroupBox
      else
      {
         if (QueryFGenHostIDEdit->Text.data() == NULL)
         {
            Application->MessageBox("Error: Need Host ID",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST);
            QueryFGenBitBtn->Enabled = true;
            return (0);
         }

         if (!QueryFGenFgRadioButton->Checked && !QueryFGenSmartFGRadioButton->Checked &&
             !QueryFGenRdrRadioButton->Checked)
         {
             Application->MessageBox("Error: Select one of the following Fields: Field Generator, Smart Field Generator, or Reader Field Generator.",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST);
             QueryFGenBitBtn->Enabled = true;
             return (0);
         }

         //if (!QueryFGenSmartFGenBroadcastCheckBox->Checked && (QueryFGenIDEdit->Text.data() == NULL))
         //{
            //Application->MessageBox("Error: Need Field Gen ID",
                                    //"Programming Station Information Dialog",
                                    //MB_OK | MB_ICONSTOP | MB_TOPMOST);
            //QueryFGenBitBtn->Enabled = true;
            //return (0);
         //}

         if (QueryFGenFgRadioButton->Checked ||  ConfigFGenGroupBox->Visible || QueryFGenGroupBox->Visible)
         {
            if (QueryFGenSmartFGenBroadcastCheckBox->Checked) //field gen
            {
               XBuf[2] = 0x03;   //Len
               XBuf[3] = 0x08;   //00 001 000
               XBuf[4] = atoi(QueryFGenHostIDEdit->Text.c_str());     //host ID
               index = 5;
            }
            else
            {
               XBuf[2] = 0x04;   //Len
               XBuf[3] = 0x08;   //00 001 000
               if (QueryFGenGroupBox->Visible)
               {
                  if (!QueryFGenSmartFGenBroadcastCheckBox->Checked && (QueryFGenIDEdit->Text.data() == NULL))
                  {
                       Application->MessageBox("Error: Need Field Gen ID",
                       "Programming Station Information Dialog",
                       MB_OK | MB_ICONSTOP | MB_TOPMOST);

                       QueryFGenBitBtn->Enabled = true;
                       return (0);
                  }

                  XBuf[4] = atoi(QueryFGenHostIDEdit->Text.c_str());   //host ID
                  XBuf[5] = atoi(QueryFGenIDEdit->Text.c_str());       //FGen ID
               }
               else //ConfigFGenGroupBox
               {
                  XBuf[4] = atoi(FGenConfigHostIDEdit->Text.c_str());    //host ID
                  XBuf[5] = atoi(FGenConfigFieldGenIDEdit->Text.c_str());  //FGen ID
               }
               index = 6;
            }
         }
         else if (QueryFGenSmartFGRadioButton->Checked)  //smart field Gen
         {
            if (!QueryFGenSmartFGenBroadcastCheckBox->Checked && (QueryFGenSmartFGenRdrIDComboBox->Text.data() == NULL))
            {
               Application->MessageBox("Error: Need Reader ID",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
               QueryFGenBitBtn->Enabled = true;
                return (0);
            }

            if (QueryFGenSmartFGenBroadcastCheckBox->Checked)
            {
               XBuf[2] = 0x03;   //Len
               XBuf[3] = 0x0A;   //00 001 010
               XBuf[4] = atoi(QueryFGenHostIDEdit->Text.c_str());     //host ID
               index = 5;
            }
            else
            {
               XBuf[3] = 0x0A;   //00 001 010
               XBuf[4] = atoi(QueryFGenHostIDEdit->Text.c_str());          //host ID
               XBuf[5] = atoi(QueryFGenSmartFGenRdrIDComboBox->Text.c_str());   //reader ID
               if (QueryFGenIDEdit->Text.data() == NULL)
               {
                  XBuf[2] = 0x04;   //Len
                  index = 6;
               }
               else
               {
                  XBuf[6] = atoi(QueryFGenIDEdit->Text.c_str());  //FGen ID
                  XBuf[2] = 0x05;   //Len
                  index = 7;
               }
            }
         }
         else    //reader field Gen
         {
            if (!QueryFGenSmartFGenBroadcastRdrCheckBox->Checked && (QueryFGenSmartFGenRdrIDComboBox->Text.data() == NULL))
            {
               Application->MessageBox("Error: Need Reader ID",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
               QueryFGenBitBtn->Enabled = true;
               return (0);
            }

            if (QueryFGenSmartFGenBroadcastCheckBox->Checked) //field gen
            {
               XBuf[2] = 0x04;   //Len
               XBuf[3] = 0x0A;   //00 001 010
               XBuf[4] = atoi(QueryFGenHostIDEdit->Text.c_str());     //host ID
               XBuf[5] = 0x00;  //fgen ID
               index = 6;
            }
            else
            {
               XBuf[2] = 0x05;   //Len
               XBuf[3] = 0x0A;   //00 001 010
               XBuf[4] = atoi(QueryFGenHostIDEdit->Text.c_str());   //host ID
               XBuf[5] = atoi(QueryFGenSmartFGenRdrIDComboBox->Text.c_str());   //reader ID
               XBuf[6] = atoi(QueryFGenIDEdit->Text.c_str());       //FGen ID
               index = 7;
            }

         }//reader field Gen

         XBuf[index++] = 0xFC;   //pkt ID

         FieldGenIDLabel01->Visible = true;
         FieldGenIDLabel->Visible = true;
         if (QueryFGenIDEdit->Text.data() == NULL)
            FieldGenIDLabel->Caption = "0";
         else
            FieldGenIDLabel->Caption = QueryFGenIDEdit->Text;
         TxCommandLabel->Caption = "Query Field Generator";
      }//if Smart Field Gen GrpopBox
   }
   else if (Command == POWER_UP)   //0x30   ACK
   {
      //bool uninitReader;
      bool extendedReader;
      programming = false;

      //if (!MultiTagType)  //this line is for temp fix 06/14/02 $$$
      RxCommandLabel->Caption = "Power up";

      if (buf != NULL)
      {
         if (buf[0] == 'F')  //power up field generator
         {
         XBuf[0] = 0x7E;
         XBuf[1] = 0xB0;   //powerup ACK
         XBuf[2] = 0x04;   //len
         XBuf[3] = 0x08;   //host -> reader
         XBuf[4] = recvBuf[5];   //host id
         XBuf[5] = recvBuf[4];   //fg ID
         XBuf[6] = 0x29;   //pkt ID
         index = 7;        //next index
         lastFieldGenID = (unsigned int)(unsigned char)recvBuf[4];
         if (QueryFGenGroupBox->Visible)  //Query STD FGen
         {
            QueryFGenIDEdit->Text = (unsigned int)(unsigned char)recvBuf[4];
         }
         else if (ConfigFGenGroupBox->Visible)  //Config STD FGen
         {
            FGenConfigFieldGenIDEdit->Text = (unsigned int)(unsigned char)recvBuf[4];
         }
         else if (SmartFGenGroupBox->Visible)
            SmartFGenReaderIDComboBox->Text = (unsigned int)(unsigned char)recvBuf[4];

         PlaySound("Ding.wav", NULL, SND_ASYNC );
         PlaySound("Ding.wav", NULL, SND_ASYNC );
         }
      }
      else            //power up reader
      {

      if (msgDisplayed && uninitReader)
          return (0);
      else
      {
      //check if extended reader or not
      if ((recvBuf[3] & 0x38) == 0x30)  //exteded reader
      {
         extendedReader = true;
         RxReaderIDLabel->Caption = (unsigned int)(unsigned char)recvBuf[4]*pow(2, 8)+(unsigned int)(unsigned char)recvBuf[5];  //reader ID
         *reader = (unsigned int)(unsigned char)recvBuf[4]*pow(2, 8)+(unsigned int)(unsigned char)recvBuf[5];
         //find out if this reader is uninitialized
         //if ((recvBuf[4] == 0x00) && (recvBuf[5] == 0x00) &&
            //(recvBuf[6] == 0x00))
         if ((recvBuf[4] == 0x00) && (recvBuf[5] == 0x00))
            uninitReader = true;
         else
            uninitReader = false;
      }
      else  //reg reader
      {
         extendedReader = false;
         RxReaderIDLabel->Caption = (int)recvBuf[4];
         *reader = (int)recvBuf[4];

         //find out if this reader is uninitialized
         //if ((recvBuf[4] == 0x00) && (recvBuf[5] == 0x00))
         if (recvBuf[4] == 0x00)
            uninitReader = true;
         else
            uninitReader = false;
      }

      }

      //if (msgDisplayed && uninitReader)
          //return (0);

      //reader is not initialized
      if (uninitReader && !msgDisplayed)
      {
         ResetModifyReaderCheckBox->Checked = true;
         ResetRespCheckBox->Checked = true;

         //////////////////////////////////////
         if (!msgDisplayed)
         {
            if (!ResetReaderGroupBox->Visible)
            {
      ResetReaderGroupBox->Visible = true;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      GeneralGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
         }

   ResetReaderStaticText->Visible = false;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //ConfigTxTimeStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   //EnableFGenStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = true;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;

   ResetListView->Items->Clear();
   ResetReaderIDComboBox->Text = "0";
   for (unsigned int i=0; i<numReaderIDList; i++)
   {
      if (ResetReaderIDComboBox->Items->IndexOf(readerIDList[i]) == -1 )
         ResetReaderIDComboBox->Items->Add(readerIDList[i]);
   }

   ResetHostIDEdit->Text = (unsigned int)recvBuf[5];

   TxClearTagCtrls();
   RxClearTagCtrls();
         //////////////////////////////////////

            Application->MessageBox("Reader Power up  - Undefined Reader and Host ID !\n Please Configure the reader?",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST);

            msgDisplayed = true;
            PlaySound("Ding.wav", NULL, SND_ASYNC );
            PlaySound("Ding.wav", NULL, SND_ASYNC );
   }
   return (0);

         /*   XBuf[0] = 0x7E;
            XBuf[1] = 0x30;      //command
            if (AssignedReaderID <= 255)  //reg reader
            {
               XBuf[1] |= 0x80;  //set the bit for ACK command 1000 0000
               XBuf[2] = 4;      //length  3+cmdref
               XBuf[3] = 0x0A;   //00 001 010
               XBuf[4] = atoi(AssignedHostID.c_str());      //Host ID
               XBuf[5] = atoi(AssignedReaderID.c_str());    //reader ID
               if (extendedReader)
                  XBuf[6] = recvBuf[7];   //Command ref#
               else
                  XBuf[6] = recvBuf[6];   //Command ref#
               index = 7;
               if (!programming)
                  StaticText->Caption = "Reader Initialized.";
               PlaySound("Ding.wav", NULL, SND_ASYNC );
            }
            else  //extended  > 255
            {
               XBuf[1] |= 0x80;  //set the bit for ACK command 1000 0000
               XBuf[2] = 5;      //length
               XBuf[3] = 0x0E;   //00 001 110
               XBuf[4] = atoi(AssignedHostID.c_str());   //Host ID
               AnsiString s = AssignedReaderID.SubString(1,2);
               XBuf[5] = HexToInt(s.c_str(), 2);       //Reader ID
               s = AssignedReaderID.SubString(3,4);
               XBuf[6] = HexToInt(s.c_str(), 2);
               if (extendedReader)
                  XBuf[7] = recvBuf[7];   //Command ref#
               else
                  XBuf[7] = recvBuf[6];   //Command ref#

               index = 8;
               if (!programming)
                  StaticText->Caption = "Reader Initialized.";
               PlaySound("Ding.wav", NULL, SND_ASYNC );
            }

            //ReaderIDComboBox->Text = AssignedReaderID;
            TxReaderIDLabel->Caption = AssignedReaderID;
            //HostIDEdit->Text = AssignedHostID;

           //} //IDYES
         //else
            //return (0);  //IDNO
         */
      }// reader is NOT init
      else   //reader is init *************
      {
         PlaySound("Ding.wav", NULL, SND_ASYNC );
         XBuf[0] = recvBuf[0];   //0x7E
         XBuf[1] = recvBuf[1];   //Command
         XBuf[2] = 3;           //Length


         if (!extendedReader)  //reg reader
         {
            XBuf[1] |= 0x80;  //set the bit for ACK command 1000 0000
            //recvBuf[3] &= 0xC0; //1100 0000
            unsigned char c = recvBuf[3];
            c &= 0xC0; //1100 0000
            //XBuf[3] = 0x0A | recvBuf[3];   //00 001 010
            XBuf[3] = 0x0A | c;   //00 001 010
            c = recvBuf[4]; //src
            XBuf[4] = recvBuf[5];   //src <- dest   host

            //if (ResetBroadcastReaderCheckBox->Checked)
            //{
               //XBuf[5] = 0xFF;
               //TxReaderIDLabel->Caption = "Broadcast";
            //}
            //else
            //{
               XBuf[5] = c;            //dest <- src    rdr
               *reader = c;
               TxReaderIDLabel->Caption = c;
            //}
            index = 6;

            if (ResetReaderGroupBox->Visible)
            {
                if (ResetModifyReaderCheckBox->Checked)
                {
                     if ((ResetNewReaderIDEdit->Text.data()== NULL) &&
                         (ResetNewHostIDEdit->Text.data()== NULL) && !msgDisplayed)
                     {
                        int ret = Application->MessageBox ("Do you want to initialize the reader?",
                                                           "Programming Station Information Dialog",
                                                           MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
                        if (ret == IDNO)
                           return (0);
                        else
                        {
                           newRID = 0;
                           newHID = 0;
                        }
                     }
                     else
                     {
                        if (ResetNewReaderIDEdit->Text.data()== NULL)
                        {
                            newRID = XBuf[5];  //old rdr addr
                            newHID = atoi(ResetNewHostIDEdit->Text.c_str());
                        }
                        else if (ResetNewHostIDEdit->Text.data()== NULL)
                        {
                            newRID = atoi(ResetNewReaderIDEdit->Text.c_str());
                            newHID = XBuf[4];  //old host addr
                        }
                        else
                        {
                           newRID = atoi(ResetNewReaderIDEdit->Text.c_str());
                           newHID = atoi(ResetNewHostIDEdit->Text.c_str());
                        }
                     }


                     if (newRID >= 255)
                     {
                         XBuf[index++] = 0x0E;   //00 001 110
                         XBuf[index++] = newHID;
                         AnsiString newIDstr = IntToHex(newRID, 4);
                         XBuf[index++] = HexToInt(newIDstr.c_str(), 2);
                         newIDstr = newIDstr.SubString(3,2);
                         XBuf[index++] = HexToInt(newIDstr.c_str(), 2);
                     }
                     else
                     {
                         XBuf[index++] = 0x0A;   //00 001 010
                         XBuf[index++] = newHID;
                         XBuf[index++] = newRID;
                     }

                     XBuf[index] = ResetReaderTypeComboBox->ItemIndex;  //rdr type
                     if (!ResetRespCheckBox->Checked)
                        XBuf[index] |= 0x10;   //0001 0000   //no broadcast
                     if (ResetEnablePWCheckBox->Checked)
                        XBuf[index] |= 0x20;   //0010 0000   //disable pwr up
                     if (!ReaderNoRSSICheckBox->Checked)
                        XBuf[index] |= 0x40;   //0100 0000   //send RSSI

                     index += 1;
                     XBuf[index] = 0x00;
                     index += 1;
                     XBuf[index] = 0x00;
                     index += 1;
                     XBuf[index] = 0xAF;  //pktID
                     XBuf[2] = index - 2; //len
                     index += 1;

                     ResetReaderIDComboBox->Text = newRID;
                     ResetHostIDEdit->Text = newHID;

                }//ResetModifyReaderCheckBox->Checked
                else
                {
                     XBuf[index] = 0xAF;  //pktID
                     XBuf[2] = index - 2; //len
                     index += 1;
                }
            }//Reset groupbox visible

         }//reg reader
         else   //ext reader
         {
            XBuf[1] |= 0x80;  //set the bit for ACK command 1000 0000

            unsigned char c = recvBuf[3];
            c &= 0xC0; //1100 0000

            XBuf[4] = recvBuf[6];    //src <- dest  host

            if (ResetBroadcastReaderCheckBox->Checked)
            {
               XBuf[3] = 0x0A | c;   //00 001 110
               XBuf[5] = 0xFF;   //rdr
               index = 6;
               TxReaderIDLabel->Caption = "Broadcast";
            }
            else
            {
               XBuf[3] = 0x0E | c;   //00 001 110
               c = recvBuf[4];  //src 1
               unsigned char c1 = recvBuf[5]; //src 2
               XBuf[5] = c;             //dest <- src1 reader
               XBuf[6] = c1;            //dest <- src2
               index = 7;
               TxReaderIDLabel->Caption = ResetReaderIDComboBox->Text;
            }

            if (ResetReaderGroupBox->Visible)
            {
                if (ResetModifyReaderCheckBox->Checked)
                {
                     if ((ResetNewReaderIDEdit->Text.data()== NULL) &&
                         (ResetNewHostIDEdit->Text.data()== NULL) && !msgDisplayed)
                     {
                        int ret = Application->MessageBox ("Do you want to initialize the reader?",
                                                           "Programming Station Information Dialog",
                                                           MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
                        if (ret == IDNO)
                           return (0);
                        else
                        {
                           newRID = 0;
                           newHID = 0;
                        }
                     }
                     else
                     {
                        if (ResetNewReaderIDEdit->Text.data()== NULL)
                        {
                            newRID = atoi(ResetReaderIDComboBox->Text.c_str());  //old rdr addr
                            newHID = atoi(ResetNewHostIDEdit->Text.c_str());
                        }
                        else if (ResetNewHostIDEdit->Text.data()== NULL)
                        {
                            newRID = atoi(ResetNewReaderIDEdit->Text.c_str());
                            newHID = XBuf[4];  //old host addr
                        }
                        else
                        {
                           newRID = atoi(ResetNewReaderIDEdit->Text.c_str());
                           newHID = atoi(ResetNewHostIDEdit->Text.c_str());
                        }
                     }


                     if (newRID >= 255)
                     {
                         XBuf[index++] = 0x0E;   //00 001 110
                         XBuf[index++] = newHID;
                         AnsiString newIDstr = IntToHex(newRID, 4);
                         XBuf[index++] = HexToInt(newIDstr.c_str(), 2);
                         newIDstr = newIDstr.SubString(3,2);
                         XBuf[index++] = HexToInt(newIDstr.c_str(), 2);
                     }
                     else
                     {
                         XBuf[index++] = 0x0A;   //00 001 010
                         XBuf[index++] = newHID;
                         XBuf[index++] = newRID;
                     }

                     XBuf[index] = ResetReaderTypeComboBox->ItemIndex;  //rdr type
                     if (!ResetRespCheckBox->Checked)
                        XBuf[index] |= 0x10;   //0001 0000   //no broadcast
                     if (ResetEnablePWCheckBox->Checked)
                        XBuf[index] |= 0x20;   //0010 0000   //disable pwr up
                     if (!ReaderNoRSSICheckBox->Checked)
                        XBuf[index] |= 0x40;   //0100 0000   //send RSSI

                     index += 1;
                     XBuf[index] = 0x00;
                     index += 1;
                     XBuf[index] = 0x00;
                     index += 1;
                     XBuf[index] = 0xAF;  //pktID
                     XBuf[2] = index - 2; //len
                     index += 1;

                     ResetReaderIDComboBox->Text = newRID;
                     ResetHostIDEdit->Text = newHID;

                }//ResetModifyReaderCheckBox->Checked
                else
                {
                     XBuf[index] = 0xAF;  //pktID
                     XBuf[2] = index - 2; //len
                     index += 1;
                }

            }//Reset groupbox visible

         }//ext reader

      }//reader init

      //if (!readerFgenButtonActivated)
         //StaticText->Caption = "Reader Initialized.";
      TxCommandLabel->Caption = "Power up";

   }//power up command

   }//if buf != "F" <--> power up reader


   /*








                //////////////////////////
                    //if (ReaderTypeComboBox->Text != "No Change")
                    //{
                    if (NewReaderIDCheckBox->Checked || NewHostIDCheckBox->Checked)
                    {
                        int ret = ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Do you want to initialize reader with new Reader ID or Host ID?",
                             ( LPCSTR )"Programming Station Dialog",
                             MB_YESNO | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );

                        if (ret == IDYES)
                            readerInit = true;
                    }

               //if (readerInit)
               {
                  if (NewReaderIDCheckBox->Checked)
                  {
                     unsigned short newRID;
                     if (NewReaderIDEdit->Text.data()== NULL)
                     {
                        ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Need New Reader ID!",
                        ( LPCSTR )"Programming Station Information Dialog",
                        MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
                        return (0);
                     }

                     newRID = atoi(NewReaderIDEdit->Text.c_str());

                     if (newRID < 255) //standard rdr
                     {
                        XBuf[6] = 0x0A;   //00 001 010
                        if (NewHostIDCheckBox->Checked)
                        {
                           if (NewReaderIDEdit->Text.data() == NULL)
                           {
                              ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Need New Host ID!",
                              ( LPCSTR )"Programming Station Information Dialog",
                              MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
                              return (0);
                           }

                           XBuf[7] = atoi(NewHostIDEdit->Text.c_str()); //new host

                        }
                        else
                           XBuf[7] = recvBuf[4];  //old host
                        XBuf[8] = newRID;
                        index = 9;
                        XBuf[2] += 3;  //len
                     }
                     else   //extended
                     {
                        XBuf[6] = 0x0E;   //00 001 110
                        if (NewHostIDCheckBox->Checked)
                        {
                           if (NewHostIDEdit->Text.data() == NULL)
                           {
                              ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Need New Host ID!",
                              ( LPCSTR )"Programming Station Information Dialog",
                              MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
                              return (0);
                           }

                           XBuf[7] = atoi(NewHostIDEdit->Text.c_str()); //new host
                        }
                        else
                           XBuf[7] = recvBuf[4];  //old host

                        AnsiString newIDstr = IntToHex(newRID, 4);
                        XBuf[8] = HexToInt(newIDstr.c_str(), 2);   //new reader ID
                        newIDstr = newIDstr.SubString(3,2);
                        XBuf[9] = HexToInt(newIDstr.c_str(), 2);   //new reader ID

                        index = 10;
                        XBuf[2] += 4;  //len
                     } //extended
                 }//NewReaderIDCheckBox->Checked
                 else
                 {
                    XBuf[index++] = 0x0A;   //00 001 010
                    XBuf[index++] = recvBuf[5];  //src
                    XBuf[index++] = recvBuf[4];   //dest
                 }
              } //readerInit
            //} // no change

            //if (!MultiTagType)  //this line is for temp fix 06/14/02
            StaticText->Caption = "Reader Initialized.";
            PlaySound("Ding.wav", NULL, SND_ASYNC );
            idStr = (unsigned int)recvBuf[4];
            //ReaderIDEdit->Text = (unsigned int)recvBuf[4];
            if (!CheckDuplicatedReader(atoi(idStr.c_str())))
            {
               readerIDList[numReaderIDList++] = atoi(idStr.c_str());
            }

            if (ReaderIDComboBox->Items->IndexOf(idStr) == -1)
            {
               ReaderIDComboBox->Items->Add(idStr);
               //readerIDList[numReaderIDList++] = atoi(idStr.c_str());
            }
            ReaderIDComboBox->Text = idStr;
            //DisplayReadersInViewList("", idStr);
            TxReaderIDLabel->Caption = (unsigned int)recvBuf[4];
            //HostIDEdit->Text = (unsigned int)recvBuf[5];
            HostIDEdit->Text = (unsigned char)recvBuf[5];

            }//if reset group box is active
         }
         else  //ext reader
         {
            XBuf[3] = 0x0E;   //00 001 110
            XBuf[2] = 4;  //len
            //swap the source and destination address  extended reader
            unsigned char c = recvBuf[4];  //src 1
            unsigned char c1 = recvBuf[5]; //src 2
            XBuf[4] = recvBuf[6];    //src <- dest
            XBuf[5] = c;             //dest <- src1
            XBuf[6] = c1;            //dest <- src2
            XBuf[1] |= 0x80;  //set the bit for ACK command 1000 0000
            index = 7;



            if (!MultiTagType)  //this line is for temp fix 06/14/02
              StaticText->Caption = "Reader Initialized.";
            PlaySound("Ding.wav", NULL, SND_ASYNC );
            ReaderIDComboBox->Text = (unsigned int)(unsigned char)recvBuf[4]*pow(2, 8)+(unsigned int)(unsigned char)recvBuf[5];  //reader ID
            TxReaderIDLabel->Caption = (unsigned int)(unsigned char)recvBuf[4]*pow(2, 8)+(unsigned int)(unsigned char)recvBuf[5];  //reader ID
            HostIDEdit->Text = (unsigned int)(unsigned char)recvBuf[6];
         }
      }// reader is init

      if (ReaderTypeComboBox->Text != "No Change")
      {
         if (readerInit)
         {
            XBuf[index] = ReaderTypeComboBox->ItemIndex;
            if (RedaerNoBroadcastCheckBox->Checked)
               XBuf[index] |= 0x10;   //0001 0000
            if (ReaderEnablePowerupCheckBox->Checked)
               XBuf[index] |= 0x20;   //0010 0000
            if (ReaderNoRSSICheckBox->Checked)
               XBuf[index] |= 0x40;   //0100 0000
            if (ReaderDisableCheckBox->Checked)
               XBuf[index] |= 0x80;   //1000 0000
         }
         else
            XBuf[index] = 0x82;

         index += 1;
         XBuf[index] = 0x00;
         index += 1;
         XBuf[index] = 0x00;
         index += 1;
      }

      XBuf[index] = 0xAF;  //pktID
      XBuf[2] = index - 2; //len
      index += 1;

      if (!MultiTagType)  //this line is for temp fix 06/14/02  $$$
         TxCommandLabel->Caption = "Power up";

      StaticText->Caption = "";
   }*/
   else if (Command == TAG_DETECTED)   //0x31  ACK
   {
      /*if (HostIDEdit->Text.data() == NULL)
      {
         if (!alreadyDisplayed)
         {
           ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Need Host ID!",
           ( LPCSTR )"Programming Station Information Dialog",
           MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
           alreadyDisplayed = true;
           return (0);
         }
         else
           return (0);
      }*/
      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0xB1;           //command  1011 0001 0x31
      /*if (ReaderIDEdit->Text.data() == NULL)
      {
         if (!alreadyDisplayed1)
         {
           ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Need Reader ID!",
           ( LPCSTR )"Programming Station Information Dialog",
           MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
           alreadyDisplayed1 = true;
           return (0);
         }
         else
           return (0);
      }*/
      //else
      {
         //alreadyDisplayed = false;
         //alreadyDisplayed1 = false;
         //rdrID = atoi(ReaderIDEdit->Text.c_str());
         if ((recvBuf[3] & 0x38) == 0x10)  //standard reader
            rdrID = recvBuf[4];
         else if ((recvBuf[3] & 0x38) == 0x30) //extended reader
            rdrID = (unsigned int)(unsigned char)recvBuf[4]*pow(2, 8)+(unsigned int)(unsigned char)recvBuf[5];
         else
         {
            PlaySound("Ding.wav", NULL, SND_ASYNC );
            PlaySound("Ding.wav", NULL, SND_ASYNC );
            return (0);
         }
         if (rdrID <= 255)  //reg reader
         {
            XBuf[2] = 0x04;   //Len
            XBuf[3] = 0x0A;   //00 001 010
            XBuf[4] = atoi(HostIDEdit->Text.c_str());   //host ID
            XBuf[5] = rdrID;  //reader ID
            XBuf[6] = pktID;    //pktid
            index = 7;
         }
         else    //extended
         {
            XBuf[2] = 0x05;   //Len
            XBuf[3] = 0x0E;   //00 001 110
            XBuf[4] = atoi(HostIDEdit->Text.c_str());  //host ID
            AnsiString str = IntToHex(rdrID, 4);
            XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
            str = str.SubString(3,2);
            XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
            XBuf[7] = pktID;    //pktid
            index = 8;
         }
      }

      if (ReaderIDComboBox->Text.data() != NULL)
         TxReaderIDLabel->Caption = ReaderIDComboBox->Text;
      else
         TxReaderIDLabel->Caption = "";

      TxCommandLabel->Caption = "Tag Detected Ack";

   } //0x31
   else if (Command == WRITE_TAG_MEMORY)   //0x0B
   {
      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0x0B;           //command

      if (WriteMemoryHostIDEdit->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Host ID",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         WriteMemoryBitBtn->Enabled = true;
         return (0);
      }

      if (WriteMemoryNumByteEdit->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Number Bytes",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         WriteMemoryBitBtn->Enabled = true;
         return (0);
      }

      if (LargeDataCheckBox->Checked)
      {
         if ((atoi(WriteMemoryNumByteEdit->Text.c_str()) % 12) != 0)
         {
            Application->MessageBox("Error: Exceeds Max Num Bytes for write tag memory must be multiple of 12 ( 24, 36, 60, 144, ..)",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST );
            WriteMemoryBitBtn->Enabled = true;
            return (0);
         }
      }
      else
      {
         if (atoi(WriteMemoryNumByteEdit->Text.c_str()) > 12)
         {
            //GeneralTimer->Enabled = false;
            Application->MessageBox("Error: Exceeds Max Num Bytes for write tag memory. (MAX 12)",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST );

            WriteMemoryBitBtn->Enabled = true;
            return (0);
         }
      }

      if (HexToInt(WriteMemoryStartAddrEdit->Text.c_str(), WriteMemoryStartAddrEdit->Text.Length()) < 0x00E0)
      {
         Application->MessageBox("Error: Starting Address should be within 0x00E0 - 0x3F00  range",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         WriteMemoryBitBtn->Enabled = true;
         return (0);
      }

      if ((HexToInt(WriteMemoryStartAddrEdit->Text.c_str(), WriteMemoryStartAddrEdit->Text.Length())) + atoi(WriteMemoryNumByteEdit->Text.c_str()) > 0x3F00)
      {
         Application->MessageBox("Error: Starting Address + Num Bytes exceeds  range 0x00E0 - 0x3F00",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         WriteMemoryBitBtn->Enabled = true;
         return (0);
      }

      int a = HexToInt(WriteMemoryStartAddrEdit->Text.c_str(), WriteMemoryStartAddrEdit->Text.Length()) % 8;   //write mem boundry
      if (a != 0)
      {
         if (( a + atoi(WriteMemoryNumByteEdit->Text.c_str())) > 16)
         {
            Application->MessageBox("Error: Starting Address + Num Bytes exceeds Write Memory 16 byte boundary",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST );
            WriteMemoryBitBtn->Enabled = true;
            return (0);
         }
      }

      if (WriteMemoryBroadcastRdrCheckBox->State == cbChecked)
         rdrID = 0x00;
      else if (WriteMemoryReaderIDComboBox->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Reader ID",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         WriteMemoryBitBtn->Enabled = true;
         return (0);
      }
      else
         rdrID = atoi(WriteMemoryReaderIDComboBox->Text.c_str());

      if (rdrID <= 255)  //reg reader
      {
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(WriteMemoryHostIDEdit->Text.c_str());   //host ID
         XBuf[5] = rdrID;  //reader ID
         index = 6;
      }
      else    //extended
      {
         XBuf[3] = 0x0E;   //00 001 110
         XBuf[4] = atoi(WriteMemoryHostIDEdit->Text.c_str());   //host ID
         AnsiString str = IntToHex(rdrID, 4);
         XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
         str = str.SubString(3,2);
         XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
         index = 7;
      }

      AnsiString s = WriteMemoryStartAddrEdit->Text;
      while (s.Length() < 4)
         s.Insert("0", 0);
      AnsiString msb = s.SubString(1,2);
      AnsiString lsb = s.SubString(3,4);

      unsigned char msbyte;
      //check tag type
      //if (WriteMemoryAnyTagTypeRadioButton->Checked == cbUnchecked)
      if (WriteMemoryTagTypeComboBox->Text != "All Types")
      {
         if (WriteMemoryAnyTagIDRadioButton->Checked)
            msbyte = 0x40;  //0100 0000  particular tag type
         else
            msbyte = 0x80;  //1000 0000  particular tag type
                            //           particular tag id
      }
      else
         msbyte = 0x00;  //00 00 0000


     XBuf[index] = msbyte | HexToInt(msb.c_str(), 2); //atoi(msb.c_str());
     index += 1;
     XBuf[index] = HexToInt(lsb.c_str(), 2);   //atoi(lsb.c_str());
     index += 1;

     int tagTypeVal = 0;

      if (WriteMemoryTagTypeComboBox->Text != "All Types")
      {

          if (WriteMemoryTagTypeComboBox->Text == "Factory")
          {
             tagTypeVal = 6;   //one will be added later
          }
          else if ((tagTypeVal=GetIndexTagType(WriteMemoryTagTypeComboBox->Text)) < 0)
          {
              Application->MessageBox("Error in calculating tag type index",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
              WriteMemoryBitBtn->Enabled = true;
              return (0);
          }

         tagTypeVal += 1;
         XBuf[index] = (tagTypeVal << 5);

         if (WriteMemoryTagIDRangeRadioButton->Checked)
         {
             if (WriteMemoryTagIDRangeComboBox->Text.data() == NULL)
             {
                 Application->MessageBox("Error: Need value for the Range",
                                         "Programming Station Information Dialog",
                                         MB_OK | MB_ICONSTOP | MB_TOPMOST);
                 WriteMemoryBitBtn->Enabled = true;
                 return (0);
             }
             XBuf[index] |= GetRangeIndex(atoi(WriteMemoryTagIDRangeComboBox->Text.c_str()));
             XBuf[index] |= 0x10;  //xxx 1 xxxx
        }
        else
        {
            if (WriteMemoryTagRNLongRadioButton->Checked)
               XBuf[index] |= 0x01; //0000 0001    //long
            else
               XBuf[index] &= 0xFE; //1111 1110    //short
         }

         index += 1;
     }//!= "All Types"

     /*if (WriteMemoryAnyTagTypeRadioButton->Checked == cbUnchecked)
     {
         if (WriteMemoryAccRadioButton->Checked)
           XBuf[index] = 0x20;  //001 0 0000
         else if (WriteMemoryInvRadioButton->Checked)
           XBuf[index] = 0x40;  //010 0 0000
         else if (WriteMemoryAssRadioButton->Checked)
           XBuf[index] = 0x60;  //011 0 0000

         if (WriteMemoryTagIDRangeRadioButton->Checked)
         {
             if (WriteMemoryTagIDRangeComboBox->Text.data() == NULL)
             {
                 Application->MessageBox("Error: Need value for the Range",
                                         "Programming Station Information Dialog",
                                         MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   WriteMemoryBitBtn->Enabled = true;
                   return (0);
             }
             XBuf[index] |= GetRangeIndex(atoi(WriteMemoryTagIDRangeComboBox->Text.c_str()));
             XBuf[index] |= 0x10;  //xxx 1 xxxx
         }
         else
         {
            if (WriteMemoryTagRNLongRadioButton->Checked)
               XBuf[index] |= 0x01;  //long
         }

         index += 1;
      }*/

      if ((WriteMemoryAnyTagIDRadioButton->Checked == cbUnchecked) ||
           WriteMemoryTagIDRangeRadioButton->Checked)
      {
         __int64  n = ((unsigned long)atol(WriteMemoryTagIDEdit->Text.c_str()));
         AnsiString s = IntToHex(n, 8);
         XBuf[index] = HexToInt(s.c_str(), 2);
         index += 1;
         AnsiString s1 = s.SubString(3,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
         s1 = s.SubString(5,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         s1 = s.SubString(7,2);
         index += 1;
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
      }

      //Put data here ---------------
      unsigned char buf[4] = {'\0', '\0', '\0'};
      int j, count, nBytes;
      if (LargeDataCheckBox->Checked)
        nBytes = 12;
      else
         nBytes = atoi(WriteMemoryNumByteEdit->Text.c_str());


      //TESTING FOR LARGE DATA ###############################
      //-------------------------------------------------------
      //if (LargeDataCheckBox->Checked)
      //{
          //if (pktID != 1)
             //writeDigitNum += 1;

          //for (count=0; count<nBytes; count++)    //01/13/04
          //{
            //XBuf[index++] = writeDigitNum;

         //}

      //}
      //else
      //{   //normal write


      for (i=1, j=1, count=0; count<nBytes; i++)    //01/13/04
      {
         if (j%12 == 0)
            j += 1;
         if (writeFormat == "CHAR")
         {
            strcpy(buf, WriteMemoryStringGrid->Cells[i][j].c_str());
            XBuf[index++] = buf[0];
         }
         //else if (writeFormat == "HEX")
            //XBuf[index++] = atoi(WriteMemoryStringGrid->Cells[i][j].c_str());
         else
         {
            //XBuf[index++] = atoi(WriteMemoryStringGrid->Cells[i][j].c_str());
            XBuf[index++] = HexToInt(WriteMemoryStringGrid->Cells[i][j].c_str(), 2);
            largeDataLastSent[count] = XBuf[index-1];
         }
         count += 1;
      }

      //} //normal write

      if (LargeDataCheckBox->Checked)
      {
         if (writePktID <= 200)
             writePktID += 1;
         else
            writePktID = 0;

         XBuf[index] = writePktID;   //pktid
         largeDataLastSent[12] = '\0';

      }
      else
         XBuf[index] = 0x22;   //pktid
      index += 1;
      XBuf[2] = index - 3;   //Len

      TxCommandLabel->Caption = "Write Tag Memory";

   } //0x0B
   else if (Command == READ_TAG_MEMORY)   //0x0C
   {
      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0x0C;           //command

      //Writing large Data
      if (LargeDataCheckBox->Checked &&  writeTagData)
      {
         XBuf[2] = 0x0C;
         XBuf[3] = largeDataLastWriteBuf[3];
         XBuf[4] = largeDataLastWriteBuf[4];  //host
         XBuf[5] = largeDataLastWriteBuf[5];  //rdr
         XBuf[6] = largeDataLastWriteBuf[6];
         XBuf[7] = largeDataLastWriteBuf[7];
         XBuf[8] = largeDataLastWriteBuf[8];  //address
         XBuf[9] = largeDataLastWriteBuf[9];
         XBuf[10] = largeDataLastWriteBuf[10];
         XBuf[11] = largeDataLastWriteBuf[11];
         XBuf[12] = largeDataLastWriteBuf[12];  //tag id
         XBuf[13] = 0x0C;  //num read
         if (wPktID >= 220)
            wPktID = 1;
         XBuf[14] = wPktID++;  //pktID
         index = 15;
      }
      else {  //if not write large data

      if (ReadMemoryHostIDEdit->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Host ID",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         ReadMemoryBitBtn->Enabled = true;
         return (0);
      }

      if (ReadMemoryNumByteEdit->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Number Bytes",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         ReadMemoryBitBtn->Enabled = true;
         return (0);
      }

      if ((atoi(ReadMemoryNumByteEdit->Text.c_str()) > 12) && (!ReadTagLargeDataCheckBox->Checked))
      {
         Application->MessageBox("Error: Exceeds Max Num Bytes for read tag memory. (MAX 12)",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         ReadMemoryBitBtn->Enabled = true;
         return (0);
      }

      if (!DebugDisplayToolButton->Visible &&   //if not debug prog station
          !TextDisplayToolButton->Visible)
      {
         if (HexToInt(ReadMemoryStartAddrEdit->Text.c_str(), ReadMemoryStartAddrEdit->Text.Length()) < 0x00E0)
         {
            Application->MessageBox("Error: Starting Address should be within 0x00E0 - 0x3F00  range",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST );
            ReadMemoryBitBtn->Enabled = true;
            return (0);
         }
      }

      if ((HexToInt(ReadMemoryStartAddrEdit->Text.c_str(), ReadMemoryStartAddrEdit->Text.Length())) + atoi(ReadMemoryNumByteEdit->Text.c_str()) > 0x3F00)
      {
         Application->MessageBox("Error: Starting Address + Num Bytes exceeds the range 0x00E0 - 0x3F00",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         ReadMemoryBitBtn->Enabled = true;
         return (0);
      }

      int a = HexToInt(ReadMemoryStartAddrEdit->Text.c_str(), ReadMemoryStartAddrEdit->Text.Length()) % 16;   //read mem boundry
      if (a != 0)
      {
         if (( a + atoi(ReadMemoryNumByteEdit->Text.c_str())) > 16)
         {
            Application->MessageBox("Error: Starting Address + Num Bytes exceeds Write Memory 16 byte boundary",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST );
            ReadMemoryBitBtn->Enabled = true;
            return (0);
         }
      }

      if (ReadMemoryBroadcastRdrCheckBox->State == cbChecked)
         rdrID = 0x00;
      else if (ReadMemoryReaderIDComboBox->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Reader ID",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         ReadMemoryBitBtn->Enabled = true;
         return (0);
      }
      else
         rdrID = atoi(ReadMemoryReaderIDComboBox->Text.c_str());

      if (rdrID <= 255)  //reg reader
      {
         //XBuf[2] = 0x07;   //Len
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(ReadMemoryHostIDEdit->Text.c_str());   //host ID
         XBuf[5] = rdrID;  //reader ID
         index = 6;
      }
      else    //extended
      {
         //XBuf[2] = 0x08;   //Len
         XBuf[3] = 0x0E;   //00 001 110
         XBuf[4] = atoi(ReadMemoryHostIDEdit->Text.c_str());   //host ID
         AnsiString str = IntToHex(rdrID, 4);
         XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
         str = str.SubString(3,2);
         XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
         index = 7;
      }

      AnsiString s = ReadMemoryStartAddrEdit->Text;
      while (s.Length() < 4)
         s.Insert("0", 0);
      AnsiString msb = s.SubString(1,2);
      AnsiString lsb = s.SubString(3,4);

      unsigned char msbyte;
      //check tag type
      //if (ReadMemoryAnyTagTypeRadioButton->Checked == cbUnchecked)
      if (ReadMemoryTagTypeComboBox->Text != "All Types")
      {
         if (ReadMemoryAnyTagIDRadioButton->Checked)
            msbyte = 0x40;  //0100 0000  particular tag type
         else
            msbyte = 0x80;  //1000 0000  particular tag type
                            //           particular tag id
      }
      else
         msbyte = 0x00;  //00 00 0000


     XBuf[index] = msbyte | HexToInt(msb.c_str(), 2); //msbyte | atoi(msb.c_str());
     index += 1;
     XBuf[index] = HexToInt(lsb.c_str(), 2);  //atoi(lsb.c_str());
     index += 1;

     int tagTypeVal = 0;

      if (ReadMemoryTagTypeComboBox->Text != "All Types")
      {
          if (ReadMemoryTagTypeComboBox->Text == "Factory")
          {
             tagTypeVal = 6;   //one will be added later
          }
          else if ((tagTypeVal=GetIndexTagType(ReadMemoryTagTypeComboBox->Text)) < 0)
          {
              Application->MessageBox("Error in calculating tag type index",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
              ReadMemoryBitBtn->Enabled = true;
              return (0);
          }

          tagTypeVal += 1;
          XBuf[index] = (tagTypeVal << 5);

          if (ReadMemoryTagIDRangeRadioButton->Checked)
          {
             if (ReadMemoryTagIDRangeComboBox->Text.data() == NULL)
             {
                 Application->MessageBox("Error: Need value for the Range",
                                         "Programming Station Information Dialog",
                                         MB_OK | MB_ICONSTOP | MB_TOPMOST);
                 ReadMemoryBitBtn->Enabled = true;
                 return (0);
             }
             XBuf[index] |= GetRangeIndex(atoi(ReadMemoryTagIDRangeComboBox->Text.c_str()));
             XBuf[index] |= 0x10;  //xxx 1 xxxx
         }
         else
         {
            if (ReadMemoryTagRNLongRadioButton->Checked)
               XBuf[index] |= 0x01; //0000 0001    //long
            else
               XBuf[index] &= 0xFE; //1111 1110    //short
         }

         initLen += 1;
         index += 1;
     } //!= "All Types"

    /* if (ReadMemoryAnyTagTypeRadioButton->Checked == cbUnchecked)
     {
         if (ReadMemoryAccRadioButton->Checked)
           XBuf[index] = 0x20;  //001 0 0000
         else if (ReadMemoryInvRadioButton->Checked)
           XBuf[index] = 0x40;  //010 0 0000
         else if (ReadMemoryAssRadioButton->Checked)
           XBuf[index] = 0x60;  //011 0 0000

         if (ReadMemoryTagIDRangeRadioButton->Checked)
         {
             if (ReadMemoryTagIDRangeComboBox->Text.data() == NULL)
             {
                 Application->MessageBox("Error: Need value for the Range",
                                         "Programming Station Information Dialog",
                                         MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   ReadMemoryBitBtn->Enabled = true;
                   return (0);
             }
             XBuf[index] |= GetRangeIndex(atoi(ReadMemoryTagIDRangeComboBox->Text.c_str()));
             XBuf[index] |= 0x10;  //xxx 1 xxxx
         }
         else
         {
            if (ReadMemoryTagRNLongRadioButton->Checked)
            XBuf[index] |= 0x01;  //long
         }

         index += 1;
      }*/

      /*if (ReadMemoryAnyTagIDRadioButton->Checked == cbUnchecked)
      {
         __int64  n = ((unsigned long)atol(ReadMemoryTagIDEdit->Text.c_str()));
         AnsiString s = IntToHex(n, 8);
         XBuf[index] = HexToInt(s.c_str(), 2);
         index += 1;
         AnsiString s1 = s.SubString(3,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
         s1 = s.SubString(5,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         s1 = s.SubString(7,2);
         index += 1;
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
      } */

      if ((ReadMemoryAnyTagIDRadioButton->Checked == cbUnchecked) ||
           ReadMemoryTagIDRangeRadioButton->Checked)
      {
         __int64  n = ((unsigned long)atol(ReadMemoryTagIDEdit->Text.c_str()));
         AnsiString s = IntToHex(n, 8);
         XBuf[index] = HexToInt(s.c_str(), 2);
         index += 1;
         AnsiString s1 = s.SubString(3,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
         s1 = s.SubString(5,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         s1 = s.SubString(7,2);
         index += 1;
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
      }

      int bytesToRead = atoi(ReadMemoryNumByteEdit->Text.c_str());
      //bytesToRead = 12;
      XBuf[index] = bytesToRead;
      index += 1;

      if (rPktID >= 100)
         rPktID = 1;
      else
         rPktID += 1;

      XBuf[index] = rPktID;   //pktid
      index += 1;
      XBuf[2] = index - 3;   //Len

      TxCommandLabel->Caption = "Read Tag Memory";
      } //if not write large data

   } //0x0C
   else if (Command == ENABLE_FIELD_GEN)   //0x6B
   {
      XBuf[0] = 0x7E;
      XBuf[1] = 0x6B;
      //XBuf[2] = 0x07;
      rdrID = atoi(EnableFGenReaderIDComboBox->Text.c_str());    //reader
      if (rdrID >= 255)    //extended rdr 2 bytes
      {
         //XBuf[2] = 0x08;         //len
         XBuf[3] = 0x0E;
         XBuf[4] = atoi(EnableFGenHostIDEdit->Text.c_str());      //host
         //XBuf[5] = HexToInt(EnableFGenReaderIDComboBox->Text.c_str(), 2);   //reader ID
         //str = EnableFGenReaderIDComboBox->Text.SubString(3,2);
         //XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
         str = IntToHex(rdrID, 4);
         XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
         str = str.SubString(3,2);
         XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
         XBuf[7] = 0xD5;
         //XBuf[8] = 0x00;
         index = 8;
      }
      else   //reg reader
      {
         //XBuf[2] = 0x07;          //len
         XBuf[3] = 0x0A;
         XBuf[4] = atoi(EnableFGenHostIDEdit->Text.c_str());      //host
         XBuf[5] = rdrID;    //reader
         XBuf[6] = 0xD5;
         //XBuf[7] = 0x00;
         index = 7;
      }

      XBuf[index] = 0x00;    //fgenID
      index += 1;

      if (EnableFGenACCRadioButton->Checked)
         XBuf[index++] = 0x20;  //00010 0000
      else if (EnableFGenASSRadioButton->Checked)
         XBuf[index++] = 0x60;  //0110 0000
      else if (EnableFGenINVRadioButton->Checked)
         XBuf[index++] = 0x40;  //0100 0000
      else //any type
         ; //XBuf[index++] = 0x00;  //1000 0000

      /*if (TagIDRadioButton->Checked)
      {
         if (TagIDEdit->Text.data() == NULL)
         {
            ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Need Tag ID!",
            ( LPCSTR )"Programming Station Information Dialog",
            MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
            return (0);
         }

          __int64  n = ((unsigned long)atol(TagIDEdit->Text.c_str()));
          AnsiString s = IntToHex(n, 8);
          XBuf[index] = HexToInt(s.c_str(), 2);
          index += 1;
          AnsiString s1 = s.SubString(3,2);
          XBuf[index] = HexToInt(s1.c_str(), 2);
          index += 1;
          s1 = s.SubString(5,2);
          XBuf[index] = HexToInt(s1.c_str(), 2);
          s1 = s.SubString(7,2);
          index += 1;
          XBuf[index] = HexToInt(s1.c_str(), 2);
          index += 1;
          //progStr += n;
          //StaticText->Caption = progStr;
          //TxTagIDLabel->Caption = n;

      }//tagid */

      XBuf[index] = 0x88;   //pktID
      XBuf[2] = index - 2;  //len
      index += 1;
   }
   else if (Command == READ_TAG_TEMP_CONFIG)   //0x90
   {
      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0x0C;           //command

      if (TagTempHostIDEdit->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Host ID",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         TagTempBitBtn->Enabled = true;
         return (0);
      }

      if (TagTempBroadcastRdrCheckBox->State == cbChecked)
         rdrID = 0x00;
      else
         rdrID = atoi(TagTempReaderIDComboBox->Text.c_str());

      if (rdrID == 0)  //broadcast
      {
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(TagTempHostIDEdit->Text.c_str());   //host ID
         index = 5;
      }
      else if (rdrID <= 255)  //reg reader
      {
         //XBuf[2] = 0x07;   //Len
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(TagTempHostIDEdit->Text.c_str());   //host ID
         XBuf[5] = rdrID;  //reader ID
         index = 6;
      }
      else    //extended
      {
         //XBuf[2] = 0x08;   //Len
         XBuf[3] = 0x0E;   //00 001 110
         XBuf[4] = atoi(TagTempHostIDEdit->Text.c_str());   //host ID
         AnsiString str = IntToHex(rdrID, 4);
         XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
         str = str.SubString(3,2);
         XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
         index = 7;
      }

      //AnsiString s = "0090";   //starting address
      //while (s.Length() < 4)
         //s.Insert("0", 0);
      //AnsiString msb = s.SubString(1,2);
      //AnsiString lsb = s.SubString(3,4);

      unsigned char msbyte;
      //check tag type
      if (TagTempTagTypeComboBox->Text != "All Types")
      {
         if (TagTempAnyTagIDRadioButton->Checked)
            msbyte = 0x40;  //0100 0000  particular tag type
         else
            msbyte = 0x80;  //1000 0000  particular tag type
                            //           particular tag id
      }
      else
         msbyte = 0x00;  //00 00 0000


     XBuf[index] = msbyte;  //| atoi(msb.c_str());
     index += 1;
     XBuf[index] = 0x90; //atoi(lsb.c_str());
     index += 1;

     int tagTypeVal = 0;

     if (TagTempTagTypeComboBox->Text != "All Types")
     {

          if (TagTempTagTypeComboBox->Text == "Factory")
          {
             tagTypeVal = 6;   //one will be added later
          }
          else if ((tagTypeVal=GetIndexTagType(TagTempTagTypeComboBox->Text)) < 0)
          {
              Application->MessageBox("Error in calculating tag type index",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
              TagTempBitBtn->Enabled = true;
              return (0);
          }

         tagTypeVal += 1;
         XBuf[index] = (tagTypeVal << 5);

         if (TagTempTagIDRangeRadioButton->Checked)
         {
             if (TagTempTagIDRangeComboBox->Text.data() == NULL)
             {
                 Application->MessageBox("Error: Need value for the Range",
                                         "Programming Station Information Dialog",
                                         MB_OK | MB_ICONSTOP | MB_TOPMOST);
                 TagTempBitBtn->Enabled = true;
                 return (0);
             }
             XBuf[index] |= GetRangeIndex(atoi(TagTempTagIDRangeComboBox->Text.c_str()));
             XBuf[index] |= 0x10;  //xxx 1 xxxx
        }
        else
        {
            if (TagTempTagRNLongRadioButton->Checked)
               XBuf[index] |= 0x01; //0000 0001    //long
            else
               XBuf[index] &= 0xFE; //1111 1110    //short
         }

        initLen += 1;
        index += 1;
     }//!= "All Types"

     /*if (TagTempAnyTagTypeRadioButton->Checked == cbUnchecked)
     {
         if (TagTempAccRadioButton->Checked)
           XBuf[index] = 0x20;  //001 0 0000
         else if (TagTempInvRadioButton->Checked)
           XBuf[index] = 0x40;  //010 0 0000
         else if (TagTempAssRadioButton->Checked)
           XBuf[index] = 0x60;  //011 0 0000

         if (TagTempTagIDRangeRadioButton->Checked)
         {
            if (TagTempTagIDRangeComboBox->Text.data() == NULL)
            {
                   Application->MessageBox("Error: Need value for the Range",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   TagTempBitBtn->Enabled = true;
                   return (0);
            }
            XBuf[index] |= GetRangeIndex(atoi(TagTempTagIDRangeComboBox->Text.c_str()));
            XBuf[index] |= 0x10;  //xxx 1 xxxx
         }
         else
         {
            if (TagTempTagRNLongRadioButton->Checked)
               XBuf[index] |= 0x01;  //long
         }

         index += 1;
      } */

      if ((TagTempAnyTagIDRadioButton->Checked == cbUnchecked) ||
           TagTempTagIDRangeRadioButton->Checked)
      {
         __int64  n = ((unsigned long)atol(TagTempTagIDEdit->Text.c_str()));
         AnsiString s = IntToHex(n, 8);
         XBuf[index] = HexToInt(s.c_str(), 2);
         index += 1;
         AnsiString s1 = s.SubString(3,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
         s1 = s.SubString(5,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         s1 = s.SubString(7,2);
         index += 1;
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
      }

      XBuf[index] = 0x06;  //read 4 bytes
      index += 1;

      XBuf[index] = READ_TAG_TEMP_CONFIG;   //pktid
      index += 1;
      XBuf[2] = index - 3;   //Len

      TxCommandLabel->Caption = "Read Tag Temp Configuration";
   }
   else if (Command == READ_TAG_TEMPERATURE)   //0x91
   {
      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0x0B;           //command

      if (TagTempHostIDEdit->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Host ID",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         TagTempBitBtn->Enabled = true;
         return (0);
      }

      if (TagTempBroadcastRdrCheckBox->State == cbChecked)
         rdrID = 0x00;
      else if (TagTempReaderIDComboBox->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Reader ID",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         TagTempBitBtn->Enabled = true;
         return (0);
      }
      else
         rdrID = atoi(TagTempReaderIDComboBox->Text.c_str());


      if (rdrID <= 255)  //reg reader
      {
         //XBuf[2] = 0x07;   //Len
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(TagTempHostIDEdit->Text.c_str());   //host ID
         XBuf[5] = rdrID;  //reader ID
         index = 6;
      }
      else    //extended
      {
         XBuf[3] = 0x0E;   //00 001 110
         XBuf[4] = atoi(TagTempHostIDEdit->Text.c_str());   //host ID
         AnsiString str = IntToHex(rdrID, 4);
         XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
         str = str.SubString(3,2);
         XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
         index = 7;
      }

      unsigned char msbyte;
      //check tag type
      //if (TagTempAnyTagTypeRadioButton->Checked == cbUnchecked)
      if (TagTempTagTypeComboBox->Text != "All Types")
      {
         if (TagTempAnyTagIDRadioButton->Checked)
            msbyte = 0x40;  //0100 0000  particular tag type
         else
            msbyte = 0x80;  //1000 0000  particular tag type
                            //           particular tag id
      }
      else
         msbyte = 0x00;  //00 00 0000


     XBuf[index] = msbyte;  //| atoi(msb.c_str());
     index += 1;
     XBuf[index] = 0xB0; //atoi(lsb.c_str());
     index += 1;

     int tagTypeVal = 0;

     if (TagTempTagTypeComboBox->Text != "All Types")
     {

          if (TagTempTagTypeComboBox->Text == "Factory")
          {
             tagTypeVal = 6;   //one will be added later
          }
          else if ((tagTypeVal=GetIndexTagType(TagTempTagTypeComboBox->Text)) < 0)
          {
              Application->MessageBox("Error in calculating tag type index",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
              TagTempBitBtn->Enabled = true;
              return (0);
          }

         tagTypeVal += 1;
         XBuf[index] = (tagTypeVal << 5);

         if (TagTempTagIDRangeRadioButton->Checked)
         {
             if (TagTempTagIDRangeComboBox->Text.data() == NULL)
             {
                 Application->MessageBox("Error: Need value for the Range",
                                         "Programming Station Information Dialog",
                                         MB_OK | MB_ICONSTOP | MB_TOPMOST);
                 TagTempBitBtn->Enabled = true;
                 return (0);
             }
             XBuf[index] |= GetRangeIndex(atoi(TagTempTagIDRangeComboBox->Text.c_str()));
             XBuf[index] |= 0x10;  //xxx 1 xxxx
        }
        else
        {
            if (TagTempTagRNLongRadioButton->Checked)
               XBuf[index] |= 0x01; //0000 0001    //long
            else
               XBuf[index] &= 0xFE; //1111 1110    //short
         }

        initLen += 1;
        index += 1;
     }//!= "All Types"

     /*if (TagTempAnyTagTypeRadioButton->Checked == cbUnchecked)
     {
         if (TagTempAccRadioButton->Checked)
           XBuf[index] = 0x20;  //001 0 0000
         else if (TagTempInvRadioButton->Checked)
           XBuf[index] = 0x40;  //010 0 0000
         else if (TagTempAssRadioButton->Checked)
           XBuf[index] = 0x60;  //011 0 0000

         if (TagTempTagIDRangeRadioButton->Checked)
         {
            if (TagTempTagIDRangeComboBox->Text.data() == NULL)
            {
                   Application->MessageBox("Error: Need value for the Range",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   TagTempBitBtn->Enabled = true;
                   return (0);
            }
            XBuf[index] |= GetRangeIndex(atoi(TagTempTagIDRangeComboBox->Text.c_str()));
            XBuf[index] |= 0x10;  //xxx 1 xxxx
         }
         else
         {
            if (TagTempTagRNLongRadioButton->Checked)
               XBuf[index] |= 0x01;  //long
         }

         index += 1;
      }*/

      if ((TagTempAnyTagIDRadioButton->Checked == cbUnchecked) ||
           TagTempTagIDRangeRadioButton->Checked)
      {
         __int64  n = ((unsigned long)atol(TagTempTagIDEdit->Text.c_str()));
         AnsiString s = IntToHex(n, 8);
         XBuf[index] = HexToInt(s.c_str(), 2);
         index += 1;
         AnsiString s1 = s.SubString(3,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
         s1 = s.SubString(5,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         s1 = s.SubString(7,2);
         index += 1;
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
      }

      XBuf[index] = 0x10;  //read temp cmd
      index += 1;

      XBuf[index] = READ_TAG_TEMPERATURE;   //pktid
      index += 1;
      XBuf[2] = index - 3;   //Len

      TxCommandLabel->Caption = "Read Tag Temperature";
   }// 0x91
   else if (Command == WRITE_TAG_LOG_TIME)   //0x94
   {
      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0x0B;           //command

      if (TagTempHostIDEdit->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Host ID",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         //TagTempBitBtn->Enabled = true;
         EnableAllCommands(true);
         return (0);
      }

      if (TagTempBroadcastRdrCheckBox->State == cbChecked)
         rdrID = 0x00;
      else
         rdrID = atoi(TagTempReaderIDComboBox->Text.c_str());

      if (rdrID == 0)  //broadcast
      {
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(TagTempHostIDEdit->Text.c_str());   //host ID
         index = 5;
      }
      else if (rdrID <= 255)  //reg reader
      {
         //XBuf[2] = 0x07;   //Len
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(TagTempHostIDEdit->Text.c_str());   //host ID
         XBuf[5] = rdrID;  //reader ID
         index = 6;
      }
      else    //extended
      {
         XBuf[3] = 0x0E;   //00 001 110
         XBuf[4] = atoi(TagTempHostIDEdit->Text.c_str());   //host ID
         AnsiString str = IntToHex(rdrID, 4);
         XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
         str = str.SubString(3,2);
         XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
         index = 7;
      }

      unsigned char msbyte;
      //check tag type
      if (TagTempTagTypeComboBox->Text != "All Types")
      {
         if (TagTempAnyTagIDRadioButton->Checked)
            msbyte = 0x40;  //0100 0000  particular tag type
         else
            msbyte = 0x80;  //1000 0000  particular tag type
                            //           particular tag id
      }
      else
         msbyte = 0x00;  //00 00 0000


     //XBuf[index] = msbyte;  //| atoi(msb.c_str());
     //index += 1;

     //unsigned char ctrlByte;
     //unsigned char reportTime;
     //float uLimit = 0.0;
     //float lLimit = 0.0;
     AnsiString baseAddr = "0108";
     //unsigned int writeIndex = index;
     ///////////////////////////////////////////
     //XBuf[index] = baseAddr;

     //AnsiString s = WriteMemoryStartAddrEdit->Text;

      AnsiString msb = baseAddr.SubString(1,2);
      AnsiString lsb = baseAddr.SubString(3,4);

      //unsigned char msbyte;
      //check tag type
      //if (WriteMemoryAnyTagTypeRadioButton->Checked == cbUnchecked)
      /*if (WriteMemoryTagTypeComboBox->Text != "All Types")
      {
         if (WriteMemoryAnyTagIDRadioButton->Checked)
            msbyte = 0x40;  //0100 0000  particular tag type
         else
            msbyte = 0x80;  //1000 0000  particular tag type
                            //           particular tag id
      }
      else
         msbyte = 0x00;  //00 00 0000*/


     XBuf[index] = msbyte | HexToInt(msb.c_str(), 2); //atoi(msb.c_str());
     index += 1;
     XBuf[index] = HexToInt(lsb.c_str(), 2);   //atoi(lsb.c_str());
     index += 1;
     ////////////////////////////////////////
     //index += 1;

      int tagTypeVal = 0;

     if (TagTempTagTypeComboBox->Text != "All Types")
     {

          if (TagTempTagTypeComboBox->Text == "Factory")
          {
             tagTypeVal = 6;   //one will be added later
          }
          else if ((tagTypeVal=GetIndexTagType(TagTempTagTypeComboBox->Text)) < 0)
          {
              Application->MessageBox("Error in calculating tag type index",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
              TagTempBitBtn->Enabled = true;
              return (0);
          }

         tagTypeVal += 1;
         XBuf[index] = (tagTypeVal << 5);

         if (TagTempTagIDRangeRadioButton->Checked)
         {
             if (TagTempTagIDRangeComboBox->Text.data() == NULL)
             {
                 Application->MessageBox("Error: Need value for the Range",
                                         "Programming Station Information Dialog",
                                         MB_OK | MB_ICONSTOP | MB_TOPMOST);
                 TagTempBitBtn->Enabled = true;
                 return (0);
             }
             XBuf[index] |= GetRangeIndex(atoi(TagTempTagIDRangeComboBox->Text.c_str()));
             XBuf[index] |= 0x10;  //xxx 1 xxxx
        }
        else
        {
            if (TagTempTagRNLongRadioButton->Checked)
               XBuf[index] |= 0x01; //0000 0001    //long
            else
               XBuf[index] &= 0xFE; //1111 1110    //short
         }

        index += 1;
     }//!= "All Types"

     if ((TagTempAnyTagIDRadioButton->Checked == cbUnchecked) ||
           ConfigTagIDRangeRadioButton->Checked)
      {
         __int64  n = ((unsigned long)atol(TagTempTagIDEdit->Text.c_str()));
         AnsiString s = IntToHex(n, 8);
         XBuf[index] = HexToInt(s.c_str(), 2);
         index += 1;
         AnsiString s1 = s.SubString(3,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
         s1 = s.SubString(5,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         s1 = s.SubString(7,2);
         index += 1;
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
      }

      time = Now();
      unsigned short year=0, mon=0, day=0;
      unsigned short hour=0, min=0, sec=0, msec=0;

      DecodeTime(time, hour, min, sec, msec);
      DecodeDate(time, year, mon, day);
      XBuf[index] = 0x00;
      XBuf[index] = day << 3;              //xxxx x000   day
      XBuf[index] |= (mon & 0x0E) >> 1;    //0000 0xxx x000 0000   mon
      index += 1;
      XBuf[index] = 0x00;
      XBuf[index] = (mon & 0x01) << 7;
      XBuf[index] |= (year - 2000) << 1;            //0xxx xxx0  year
      XBuf[index] |= (hour & 0x10) >> 4;        //0000 000x  hour
      index += 1;
      XBuf[index] = 0x00;
      XBuf[index] = (hour & 0x0F) << 4;    //xxxx 0000 hour
      XBuf[index] |= (min & 0x3C) >> 2;           //0000 xxxx xx00 0000   min
      index += 1;
      XBuf[index] = 0x00;
      XBuf[index] = (min & 0x03) << 6;    //xx00 0000  min
      XBuf[index] |= (sec & 0x3F);        //00xx xxxx sec

      index += 1;
      XBuf[index] = WRITE_TAG_LOG_TIME;   //pktid
      index += 1;
      XBuf[2] = index - 3;   //Len

   }
   else if (Command == WRITE_TAG_TEMP_CONFIG)   //0x92
   {
      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0x0B;           //command

      if (TagTempHostIDEdit->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Host ID",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         //TagTempBitBtn->Enabled = true;
         EnableAllCommands(true);
         return (0);
      }

      if (TagTempBroadcastRdrCheckBox->State == cbChecked)
         rdrID = 0x00;
      else
         rdrID = atoi(TagTempReaderIDComboBox->Text.c_str());

      if (rdrID == 0)  //broadcast
      {
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(TagTempHostIDEdit->Text.c_str());   //host ID
         index = 5;
      }
      else if (rdrID <= 255)  //reg reader
      {
         //XBuf[2] = 0x07;   //Len
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(TagTempHostIDEdit->Text.c_str());   //host ID
         XBuf[5] = rdrID;  //reader ID
         index = 6;
      }
      else    //extended
      {
         XBuf[3] = 0x0E;   //00 001 110
         XBuf[4] = atoi(TagTempHostIDEdit->Text.c_str());   //host ID
         AnsiString str = IntToHex(rdrID, 4);
         XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
         str = str.SubString(3,2);
         XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
         index = 7;
      }

      unsigned char msbyte;
      //check tag type
      if (TagTempTagTypeComboBox->Text != "All Types")
      {
         if (TagTempAnyTagIDRadioButton->Checked)
            msbyte = 0x40;  //0100 0000  particular tag type
         else
            msbyte = 0x80;  //1000 0000  particular tag type
                            //           particular tag id
      }
      else
         msbyte = 0x00;  //00 00 0000


     XBuf[index] = msbyte;  //| atoi(msb.c_str());
     index += 1;

     unsigned char ctrlByte;
     unsigned char reportTime;
     float uLimit = 0.0;
     float lLimit = 0.0;
     int baseAddr = 0x00;
     unsigned int writeIndex = index;
     XBuf[index] = baseAddr;
     index += 1;
     if (TagTempChangeReportCheckBox->Checked)
     {
        //increment to justify index for base addr.
        //the base addr will be added later
        //index += 1;

        if (TagTempNumReadAveComboBox->Text == "4")
           ctrlByte = 0x00;
        else if (TagTempNumReadAveComboBox->Text == "8")
           ctrlByte = 0x01;
        else if (TagTempNumReadAveComboBox->Text == "1")
           ctrlByte = 0x03;
        else if (TagTempNumReadAveComboBox->Text == "2")
           ctrlByte = 0x02;
        else
        {
            Application->MessageBox("Error: Wrong value for  Number Of Reads / Average",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST);
            EnableAllCommands(true);
            return(0);
        }

        if (TagTempRepLowLimitCheckBox->Checked)
          ctrlByte |= 0x04; //0000 0100

        if (TagTempRepUpLimitCheckBox->Checked)
          ctrlByte |= 0x08; //0000 1000

        if (TagTempRepPeriodCheckBox->Checked)
          ctrlByte |= 0x80; //1000 0000

        if (TagTempPeriodRepTimeEdit->Text.data() == NULL)
        {
           Application->MessageBox("Error: No value for  Periodic Report Time",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST);
           EnableAllCommands(true);
           return(0);
        }
        else
        {
           int n = atoi(TagTempPeriodRepTimeEdit->Text.c_str());
           if ((n<=0) && (n>127))
           {
              Application->MessageBox("Error: Periodic Report Time should be between 1 and 127",
                                      "Programming Station Information Dialog",
                                      MB_OK | MB_ICONSTOP | MB_TOPMOST);
              EnableAllCommands(true);
              return(0);
           }

           if (TagTempPeriodRepTimeHourRadioButton->Checked)
           {
              reportTime = 0x80; //1000 0000
              if ((n<=0) &&(n > 12))
              {
                  Application->MessageBox("Error: Periodic Report Time should be between 1 and 12 hours",
                                          "Programming Station Information Dialog",
                                          MB_OK | MB_ICONSTOP | MB_TOPMOST);
                  EnableAllCommands(true);
                  return(0);
              }
           }
           else
           {
              reportTime = 0x00;
              if ((n<=0) && (n>127))
              {
                  Application->MessageBox("Error: Periodic Report Time should be between 1 and 127 minutes",
                                          "Programming Station Information Dialog",
                                          MB_OK | MB_ICONSTOP | MB_TOPMOST);
                  EnableAllCommands(true);
                  return(0);
              }
           }

           reportTime |= n;

           //logging Temperature
           if (TagTempLoggingCheckBox->Checked)  //enable logging
           {
               ctrlByte |= 0x40;   //0 x1 x2 0 0000   x1=1, x2=0  0 10 0 0000
               ctrlByte &= 0xDF;  //1101 1111

               if (TagTempWarpAroundCheckBox->Checked) //warp-around
                   ctrlByte |= 0x10;   //000x 0000   0001 0000
               else
                   ctrlByte &= 0xEF;  //1110 1111
           }
        }
     } //if tag report checked

     //tag temp upper and lower limit
     if (TagTempChangeUpLimitCheckBox->Checked)
     {
        //upper limit
        if (TagTempNewUpLimitEdit->Text.data() == NULL)
        {
            Application->MessageBox("Error: No value for New Temp Upper Limit",
                                    "Programming Station Information Dialog",
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST);
            EnableAllCommands(true);
            return(0);
        }

        uLimit = atof(TagTempNewUpLimitEdit->Text.c_str());

        if (TagTempLimitFdegRadioButton->Checked)
        {
            AnsiString s;

            if (uLimit < -67.0) // -55.0  cent
            {
                Application->MessageBox("Error: Min Value for Upper Temp Limit is -67F",
                                      "Programming Station Information Dialog",
                                      MB_OK | MB_ICONSTOP | MB_TOPMOST);
                EnableAllCommands(true);
                return(0);
            }
            else if (uLimit > 257.0) // 125.0  cent
            {
                Application->MessageBox("Error: Max Value for Upper Temp Limit is 257F",
                                        "Programming Station Information Dialog",
                                        MB_OK | MB_ICONSTOP | MB_TOPMOST);
                EnableAllCommands(true);
                return(0);
            }

            uLimit -= 32.0;
            uLimit = (uLimit*5.0)/9.0;
            s = s.FormatFloat("##0.###", uLimit);
            uLimit = atof(s.c_str());
        }
        else   //C
        {
           if (uLimit < -55.0) // -55.0  cent
            {
                Application->MessageBox("Error: Min Value for Upper Temp Limit is -55C",
                                        "Programming Station Information Dialog",
                                        MB_OK | MB_ICONSTOP | MB_TOPMOST);
                EnableAllCommands(true);
                return(0);
            }
            else if (uLimit > 125.0) // 125.0  cent
            {
                Application->MessageBox("Error: Max Value for Upper Temp Limit is 125C",
                                        "Programming Station Information Dialog",
                                        MB_OK | MB_ICONSTOP | MB_TOPMOST);
                EnableAllCommands(true);
                return(0);
            }
        }
        uLimit += tagTempCalibC;
        uLimit *= 16;

        if (TagTempNewLowLimitEdit->Text.data() == NULL)
         {
              Application->MessageBox("Error: No value for New Temp Lower Limit",
                                      "Programming Station Information Dialog",
                                      MB_OK | MB_ICONSTOP | MB_TOPMOST);
              EnableAllCommands(true);
              return(0);
         }

         lLimit = atof(TagTempNewLowLimitEdit->Text.c_str());

         if (TagTempLimitFdegRadioButton->Checked)
         {
            if (lLimit < -67.0) // -55.0  cent
            {
                Application->MessageBox("Error: Min Value for Lower Temp Limit is -67.0F",
                                      "Programming Station Information Dialog",
                                      MB_OK | MB_ICONSTOP | MB_TOPMOST);
                EnableAllCommands(true);
                return(0);
            }
            else if (lLimit > 257.0) // 125.0  cent
            {
                Application->MessageBox("Error: Max Value for Lower Temp Limit is 257.0F",
                                        "Programming Station Information Dialog",
                                        MB_OK | MB_ICONSTOP | MB_TOPMOST);
                EnableAllCommands(true);
                return(0);
            }

            AnsiString s;
            lLimit -= 32.0;
            lLimit = (lLimit*5.0)/9.0;
            s = s.FormatFloat("##0.###", lLimit);
            lLimit = atof(s.c_str());
         }
         else   //C
         {
            if (lLimit < -55.0)
            {
                Application->MessageBox("Error: Min Value for Lower Temp Limit is -55.0F",
                                        "Programming Station Information Dialog",
                                        MB_OK | MB_ICONSTOP | MB_TOPMOST);
                EnableAllCommands(true);
                return(0);
            }
            else if (lLimit > 125.0)
            {
                Application->MessageBox("Error: Max Value for Lower Temp Limit is 125.0F",
                                        "Programming Station Information Dialog",
                                        MB_OK | MB_ICONSTOP | MB_TOPMOST);
                EnableAllCommands(true);
                return(0);
            }
        }

        lLimit += tagTempCalibC;
        lLimit *= 16;
     }

     /*if (TagTempChangeLowLimitCheckBox->Checked)
     {
         if (TagTempNewLowLimitEdit->Text.data() == NULL)
         {
              Application->MessageBox("Error: No value for New Temp Lower Limit",
                                      "Programming Station Information Dialog",
                                      MB_OK | MB_ICONSTOP | MB_TOPMOST);
              EnableAllCommands(true);
              return(0);
         }

         lLimit = atof(TagTempNewLowLimitEdit->Text.c_str());

         if (TagTempLimitFdegRadioButton->Checked)
         {
            if (lLimit < 32.0)
            {
                Application->MessageBox("Error: Min Value for Lower Temp Limit is 32.0F",
                                      "Programming Station Information Dialog",
                                      MB_OK | MB_ICONSTOP | MB_TOPMOST);
                EnableAllCommands(true);
                return(0);
            }
            AnsiString s;
            lLimit -= 32.0;
            lLimit = (lLimit*5.0)/9.0;
            s = s.FormatFloat("##0.###", lLimit);
            lLimit = atof(s.c_str());
         }
         else   //C
        {
           if (lLimit < 0)
           {
              Application->MessageBox("Error: Min Value for Lower Temp Limit is 0.0C",
                                      "Programming Station Information Dialog",
                                      MB_OK | MB_ICONSTOP | MB_TOPMOST);
              EnableAllCommands(true);
              return(0);
           }
        }
         lLimit += tagTempCalibC;
         lLimit *= 16;
     }*/

     if (TagTempChangeUpLimitCheckBox->Checked)
     {
        if  (uLimit <= lLimit)
        {
                Application->MessageBox("Error: Lower Limit value should be smaller than Upper Limit value.",
                                        "Programming Station Information Dialog",
                                        MB_OK | MB_ICONSTOP | MB_TOPMOST);
                EnableAllCommands(true);
                    return(0);
        }
     }

     int tagTypeVal = 0;

     if (TagTempTagTypeComboBox->Text != "All Types")
     {

          if (TagTempTagTypeComboBox->Text == "Factory")
          {
             tagTypeVal = 6;   //one will be added later
          }
          else if ((tagTypeVal=GetIndexTagType(TagTempTagTypeComboBox->Text)) < 0)
          {
              Application->MessageBox("Error in calculating tag type index",
                                       "Programming Station Information Dialog",
                                       MB_OK | MB_ICONSTOP | MB_TOPMOST);
              TagTempBitBtn->Enabled = true;
              return (0);
          }

         tagTypeVal += 1;
         XBuf[index] = (tagTypeVal << 5);

         if (TagTempTagIDRangeRadioButton->Checked)
         {
             if (TagTempTagIDRangeComboBox->Text.data() == NULL)
             {
                 Application->MessageBox("Error: Need value for the Range",
                                         "Programming Station Information Dialog",
                                         MB_OK | MB_ICONSTOP | MB_TOPMOST);
                 TagTempBitBtn->Enabled = true;
                 return (0);
             }
             XBuf[index] |= GetRangeIndex(atoi(TagTempTagIDRangeComboBox->Text.c_str()));
             XBuf[index] |= 0x10;  //xxx 1 xxxx
        }
        else
        {
            if (TagTempTagRNLongRadioButton->Checked)
               XBuf[index] |= 0x01; //0000 0001    //long
            else
               XBuf[index] &= 0xFE; //1111 1110    //short
         }

        initLen += 1;
        index += 1;
     }//!= "All Types"

     /*if (TagTempAnyTagTypeRadioButton->Checked == cbUnchecked)
     {
         if (TagTempAccRadioButton->Checked)
           XBuf[index] = 0x20;  //001 0 0000
         else if (TagTempInvRadioButton->Checked)
           XBuf[index] = 0x40;  //010 0 0000
         else if (TagTempAssRadioButton->Checked)
           XBuf[index] = 0x60;  //011 0 0000

         if (TagTempTagIDRangeRadioButton->Checked)
         {
            if (TagTempTagIDRangeComboBox->Text.data() == NULL)
            {
                   Application->MessageBox("Error: Need value for the Range",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   TagTempBitBtn->Enabled = true;
                   return (0);
            }
            XBuf[index] |= GetRangeIndex(atoi(TagTempTagIDRangeComboBox->Text.c_str()));
            XBuf[index] |= 0x10;  //xxx 1 xxxx
         }
         else
         {
            if (TagTempTagRNLongRadioButton->Checked)
               XBuf[index] |= 0x01;  //long
         }

         index += 1;
      }*/

      if ((TagTempAnyTagIDRadioButton->Checked == cbUnchecked) ||
           ConfigTagIDRangeRadioButton->Checked)
      {
         __int64  n = ((unsigned long)atol(TagTempTagIDEdit->Text.c_str()));
         AnsiString s = IntToHex(n, 8);
         XBuf[index] = HexToInt(s.c_str(), 2);
         index += 1;
         AnsiString s1 = s.SubString(3,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
         s1 = s.SubString(5,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         s1 = s.SubString(7,2);
         index += 1;
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
      }

      if (TagTempChangeReportCheckBox->Checked)
      {
         baseAddr = 0x90;
         XBuf[writeIndex] = baseAddr;
         XBuf[index] = ctrlByte;
         index += 1;
         XBuf[index] = reportTime;
         index += 1;
      }

      if (TagTempChangeUpLimitCheckBox->Checked || (Len == 99))
      {
         if (baseAddr == 0x00)
            baseAddr = 0x92;
         XBuf[writeIndex] = baseAddr;
         //int h;
         //if (uLimit < 0)
         //{
            //h = ~((int)uLimit);//= (int)uLimit;
         //}
         str = IntToHex((int)uLimit, 4);  //Upper Limit Temp
         if (uLimit < 0 )
            str = str.SubString(str.Length() - 3, str.Length()-1);   //4-1
         XBuf[index] = HexToInt(str.c_str(), 2);   //first byte
         index += 1;
         str = str.SubString(3,2);
         XBuf[index] = HexToInt(str.c_str(), 2);   //second byte
         index += 1;

         if (baseAddr == 0x00)
            baseAddr = 0x94;
         XBuf[writeIndex] = baseAddr;
         str = IntToHex((int)lLimit, 4);  //Lower Limit Temp
         if (lLimit < 0)
            str = str.SubString(str.Length() - 3, str.Length()-1);   //4-1
         XBuf[index] = HexToInt(str.c_str(), 2);   //first byte
         index += 1;
         str = str.SubString(3,2);
         XBuf[index] = HexToInt(str.c_str(), 2);   //second byte
         index += 1;
      }

      /*if (TagTempChangeLowLimitCheckBox->Checked || (Len == 99))
      {
         if (baseAddr == 0x00)
            baseAddr = 0x94;
         XBuf[writeIndex] = baseAddr;
         str = IntToHex((int)lLimit, 4);  //Lower Limit Temp
         XBuf[index] = HexToInt(str.c_str(), 2);   //first byte
         index += 1;
         str = str.SubString(3,2);
         XBuf[index] = HexToInt(str.c_str(), 2);   //second byte
         index += 1;
      }*/

      XBuf[index] = WRITE_TAG_TEMP_CONFIG;   //pktid
      index += 1;
      XBuf[2] = index - 3;   //Len

      TagTempChangeUpLimitCheckBox->Checked = false;
      TagTempChangeLowLimitCheckBox->Checked = false;
      TagTempChangeReportCheckBox->Checked = false;

      TxCommandLabel->Caption = "Write Tag Temperature Data";
   }// 0x92
   else if (Command == RESTART_TAG_TEMP_PERIODIC)   //0x93
   {
      XBuf[0] = 0x7E;           // start of Packet
      XBuf[1] = 0x0B;           //command

      if (TagTempHostIDEdit->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Host ID",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
         TagTempBitBtn->Enabled = true;
         return (0);
      }

      if (TagTempBroadcastRdrCheckBox->State == cbChecked)
         rdrID = 0x00;
      else
         rdrID = atoi(TagTempReaderIDComboBox->Text.c_str());

      if (rdrID == 0)  //broadcast
      {
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(TagTempHostIDEdit->Text.c_str());   //host ID
         index = 5;
      }
      else if (rdrID <= 255)  //reg reader
      {
         //XBuf[2] = 0x07;   //Len
         XBuf[3] = 0x0A;   //00 001 010
         XBuf[4] = atoi(TagTempHostIDEdit->Text.c_str());   //host ID
         XBuf[5] = rdrID;  //reader ID
         index = 6;
      }
      else    //extended
      {
         XBuf[3] = 0x0E;   //00 001 110
         XBuf[4] = atoi(TagTempHostIDEdit->Text.c_str());   //host ID
         AnsiString str = IntToHex(rdrID, 4);
         XBuf[5] = HexToInt(str.c_str(), 2);   //reader ID
         str = str.SubString(3,2);
         XBuf[6] = HexToInt(str.c_str(), 2);   //reader ID
         index = 7;
      }

      unsigned char msbyte;
      //check tag type
      //if (TagTempAnyTagTypeRadioButton->Checked == cbUnchecked)
      if (TagTempTagTypeComboBox->Text != "All Types")
      {
         if (TagTempAnyTagIDRadioButton->Checked)
            msbyte = 0x40;  //0100 0000  particular tag type
         else
            msbyte = 0x80;  //1000 0000  particular tag type
                            //           particular tag id
      }
      else
         msbyte = 0x00;  //00 00 0000


     XBuf[index] = msbyte;  //| atoi(msb.c_str());
     index += 1;
     XBuf[index] = 0xB0; //atoi(lsb.c_str());
     index += 1;

     int tagTypeVal = 0;

      if (TagTempTagTypeComboBox->Text == "All Types")
      {
         tagTypeVal = -1;   //one will be added later
      }
      else if (TagTempTagTypeComboBox->Text == "Factory")
      {
         tagTypeVal = 6;   //one will be added later
      }
      else if ((tagTypeVal=GetIndexTagType(TagTempTagTypeComboBox->Text)) < 0)
      {
          Application->MessageBox("Error in calculating tag type index",
                                   "Programming Station Information Dialog",
                                   MB_OK | MB_ICONSTOP | MB_TOPMOST);
          TagTempBitBtn->Enabled = true;
          return (0);
      }

     tagTypeVal += 1;
     XBuf[index] = (tagTypeVal << 5);

     if (TagTempTagIDRangeRadioButton->Checked)
     {
         if (TagTempTagIDRangeComboBox->Text.data() == NULL)
         {
             Application->MessageBox("Error: Need value for the Range",
                                     "Programming Station Information Dialog",
                                     MB_OK | MB_ICONSTOP | MB_TOPMOST);
             TagTempBitBtn->Enabled = true;
             return (0);
         }
         XBuf[index] |= GetRangeIndex(atoi(TagTempTagIDRangeComboBox->Text.c_str()));
         XBuf[index] |= 0x10;  //xxx 1 xxxx
    }
    else
    {
        if (TagTempTagRNLongRadioButton->Checked)
           XBuf[index] |= 0x01; //0000 0001    //long
        else
           XBuf[index] &= 0xFE; //1111 1110    //short
     }

     initLen += 1;
     index += 1;

    /* if (TagTempAnyTagTypeRadioButton->Checked == cbUnchecked)
     {
         if (TagTempAccRadioButton->Checked)
           XBuf[index] = 0x20;  //001 0 0000
         else if (TagTempInvRadioButton->Checked)
           XBuf[index] = 0x40;  //010 0 0000
         else if (TagTempAssRadioButton->Checked)
           XBuf[index] = 0x60;  //011 0 0000

         if (TagTempTagIDRangeRadioButton->Checked)
         {
            if (TagTempTagIDRangeComboBox->Text.data() == NULL)
            {
                   Application->MessageBox("Error: Need value for the Range",
                                           "Programming Station Information Dialog",
                                           MB_OK | MB_ICONSTOP | MB_TOPMOST);
                   TagTempBitBtn->Enabled = true;
                   return (0);
            }
            XBuf[index] |= GetRangeIndex(atoi(TagTempTagIDRangeComboBox->Text.c_str()));
            XBuf[index] |= 0x10;  //xxx 1 xxxx
         }
         else
         {
            if (TagTempTagRNLongRadioButton->Checked)
               XBuf[index] |= 0x01;  //long
         }

         index += 1;
      }*/

      if ((TagTempAnyTagIDRadioButton->Checked == cbUnchecked) ||
           TagTempTagIDRangeRadioButton->Checked)
      {
         __int64  n = ((unsigned long)atol(TagTempTagIDEdit->Text.c_str()));
         AnsiString s = IntToHex(n, 8);
         XBuf[index] = HexToInt(s.c_str(), 2);
         index += 1;
         AnsiString s1 = s.SubString(3,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
         s1 = s.SubString(5,2);
         XBuf[index] = HexToInt(s1.c_str(), 2);
         s1 = s.SubString(7,2);
         index += 1;
         XBuf[index] = HexToInt(s1.c_str(), 2);
         index += 1;
      }

      XBuf[index] = 0x11;  //restart periodic timer
      index += 1;

      XBuf[index] = RESTART_TAG_TEMP_PERIODIC;   //pktid
      index += 1;
      XBuf[2] = index - 3;   //Len

      TxCommandLabel->Caption = "Restart Tag Temp Periodic";
     } //0x93


   //Generating CRC
   crc = 0xFFFF;
   for (i=0; i<index; i++)    //index = len whole packet
       Generate_CRC(XBuf[i]);


   XBuf[index++] = (char)(crc & 0x00FF) ^ 0xFF;       //LSB first
   XBuf[index] = (char)((crc >> 8) & 0x00FF) ^ 0xFF;   //MSB

   for (i=0; i<=index; i++)   //make a copy of packet to be sent
       XBufLast[i] = XBuf[i];

   if (Command == WRITE_TAG_MEMORY) //&& LargeDataCheckBox->Checked)
   {
      //for (i=0; i<=index; i++)   //make a copy of packet to be sent
       //WXBufLast[i] = XBuf[i];

       if (LargeDataCheckBox->Checked)
       {
          for (i=0; i<=index; i++)   //make a copy of packet to be sent
             largeDataLastWriteBuf[i] = XBuf[i];
       }
   }
   else if (Command == READ_TAG_MEMORY)
   {
       if (LargeDataCheckBox->Checked)
       {
          for (i=0; i<=index; i++)   //make a copy of packet to be sent
             largeDataLastReadBuf[i] = XBuf[i];
       }
   }

   /*if (Command != RESET_DEVICE)
   {
   if (AccessCtrlRadioButton->Checked)
      TxTagTypeLabel->Caption = "Access";
   else if (AssetCtrlRadioButton->Checked)
      TxTagTypeLabel->Caption = "Asset";
   else if (InvetRadioButton->Checked)
      TxTagTypeLabel->Caption = "Inventory";
   else if (SameTagTypeRadioButton->Checked)
      TxTagTypeLabel->Caption = "Same Tag Type";
   else
      TxTagTypeLabel->Caption = "";

   if (SingleDirectionRadioButton->Checked)
      TxTagDirection->Caption = "Single Direction";
   else if (BiDirectionRadioButton->Checked)
      TxTagDirection->Caption = "Bi Direction";
   else
      TxTagDirection->Caption = "";


   if (FactoryIDRadioButton->Checked)
      TxTagIDLabel->Caption = "Factory Tag ID";
   } // if command != ...   */

   return (index+1);   //total Num Bytes
}
//---------------------------------------------------------------------------
int __fastcall TProgStationForm::AsciiToInteger(char *c, int n)
{
     int num, intNum=0;
     char chr[1];
     for (int i=0, j=n-1; i<n; i++, j--)
     {
         chr[0] = *c++;
         switch (chr[0])
         {
            case 'A':
            case 'a':
               num = 10;
            break;

            case 'B':
            case 'b':
               num = 11;
            break;

            case 'C':
            case 'c':
               num = 12;
            break;

            case 'D':
            case 'd':
               num =13;
            break;

            case 'E':
            case 'e':
               num = 14;
            break;

            case 'F':
            case 'f':
               num = 15;
            break;

            default:
               num = (atoi(&chr[0]));
            break;
         }
         intNum += num*pow(16, j);
     }
     return (intNum);
}
//------------------------------------------------------------------------------
bool __fastcall TProgStationForm::LoadProgramByteAndTagID()
{
     AnsiString TimePeriodStr;
     AnsiString str;
     int TimePeriodInt;

     ProgramByte = 0;

     if (ConfigTagEnableTimeCheckBox->Checked)
     {
         if ((TimePeriodInt = GetTimePeriod()) == -1)
         {
            return (false);
         }
         else
         {
            char buf[3];
            TimePeriodStr =  IntToHex(TimePeriodInt, 4);
            str = TimePeriodStr.SubString(3, 2);
            strcpy(buf, (char*)str.data());
            TimePeriod[1] = HexToInt(buf, 2); //atoi(buf);    //AsciiToInteger((char*)str.data(), 2);
            str = TimePeriodStr.SubString(1, 2);
            strcpy(buf, (char*)str.data());
            TimePeriod[0] = HexToInt(buf, 2); //atoi(buf);  //AsciiToInteger((char*)str.data(), 2);
            //ProgramByte |= 0x04;  //0000 0100  Enable Time(1) bit(2)
         }
     }
     else
     {
        TimePeriod[0] = 0x0;
        TimePeriod[1] = 0x0;
        //ProgramByte &= 0xFB;  //1111 1011  ignor time(0) bit(2)
     }


     //ProgramByte |= 0x80;  //1000 0000  Set Tag Mode tag(1) bit(7)   $$$
                           //allways set this bit for now
     //if (AccessCtrlRadioButton->Checked)
        //ProgramByte &= 0xBF;  //1011 1111  access tag(0) bit(6)
     //else
        //ProgramByte |= 0x40;  //0100 0000  inventory tag(1) bit(6)


     //if (NewIDRadioButton->Checked)  //New Tag ID
     //{
        //AnsiString NewIDStr;
        //int NewID;

        //NewIDStr = NewIDEdit->Text;
        //char buf[4] = {'\0', '\0', '\0', '\0'};
        //strncpy(&buf[1], NewIDStr.c_str(), 3);

        /*NewID = atoi(NewIDStr.c_str());
        if (NewID > 0xFFFFFF)
        {
           ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Enter smaller Number",
           ( LPCSTR )"Programming Station Information Dialog",
           MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
           return (false);
        }
        ProgramByte |= 0x08;  //0000 1000   //set(1) new tag id bit(3)

        char buf[3];
        NewIDStr =  IntToHex(NewID, 8);
        //strcpy(NewTagID, (char*)NewIDStr.c_str());

        str = NewIDStr.SubString(7, 2);
        strcpy(buf, (char*)str.data());
        NewTagID[3] = HexToInt(buf, 2);

        str = NewIDStr.SubString(5, 2);
        strcpy(buf, (char*)str.data());
        NewTagID[2] = HexToInt(buf, 2);  //AsciiToInteger((char*)str.data(), 2);

        str = NewIDStr.SubString(3, 2);
        strcpy(buf, (char*)str.data());
        NewTagID[1] = HexToInt(buf, 2);  //AsciiToInteger((char*)str.data(), 2);

        str = NewIDStr.SubString(1, 2);
        strcpy(buf, (char*)str.data());
        NewTagID[0] = HexToInt(buf, 2);  //AsciiToInteger((char*)str.data(), 2);
        */

        //NewTagID[2] = buf[2];
        //NewTagID[3] = buf[3];

        //NewTagID[0] &= 0x3F; //clear two bits
        //if (AccessCtrlRadioButton->Checked)
            //NewTagID[0] &= 0x3F;   //0011 1111  last byte  Access Control Tag
        //else if (AssetCtrlRadioButton->Checked)
            //NewTagID[0] |= 0x80;   //1000 0000  last byte  Asset Control Tag
        //else
            //NewTagID[0] |= 0x40;   //0100 0000  last byte  Inventory
     //}
     //else  //factory Tag ID
     //{
        //ProgramByte |= 0x08;  //0000 1000   //set(1) new tag id bit(3)
        //NewTagID[0] = 0x00;
        //NewTagID[1] = 0x00;
        //NewTagID[2] = 0x00;
        //NewTagID[3] = 0x00;
        /*if (AccessCtrlRadioButton->Check)
            NewTagID[0] &= 0x3F;   //0011 1111  last byte  Access Control Tag
        else if (AssetCtrlRadioButton)
            NewTagID[0] &= 0xBF;   //1011 1111  last byte  Asset Control Tag
        else
            NewTagID[0] &= 0x7F;   //0111 1111  last byte  Inventory*/

     //}

     //TagIDSend[0] = NewTagID[0];
     //TagIDSend[1] = NewTagID[1];
     //TagIDSend[2] = NewTagID[2];
     //TagIDSend[3] = NewTagID[3];
     //TagIDSend[4] = '\0';
     return (true);
}
//------------------------------------------------------------------------------
int __fastcall TProgStationForm::GetTimePeriodUnit()
{
    if(ConfigTagSecRadioButton->Checked)
    {
         return 1;
    }
    else if(ConfigTagMinRadioButton->Checked)
    {
         return 2;
    }
    else
    {
         return 3;
    }
    return 0;
}

int __fastcall TProgStationForm::GetTimePeriod()
{
    int Time;

    AnsiString timeStr = ConfigTagDurationComboBox->Text;
    if (timeStr.data() == NULL)
    {
       Application->MessageBox("ERROR: NO value for Resend Time is selected .",
                               "Programming Station Information Dialog", MB_OK );

       Time = -1;
       return (-1);
    }
    //int pos = timeStr.Pos(" ");
    //AnsiString Str = timeStr.SubString(1, pos-1);
    if (timeStr == "Stop")
        return(0);

    int timeDuration = atoi(timeStr.c_str());

    if (ConfigTagMSRadioButton->Checked)        //msec
    {
       if (IsMSecDataValid(ConfigTagDurationComboBox->Text))
          Time = timeDuration;
       else
       {
          Application->MessageBox("ERROR Resend Time: MS value - Should match one of the values in the list.",
                                  "Programming Station Information Dialog", MB_OK );
          return (-1);
       }
    }
    else if (ConfigTagSecRadioButton->Checked)        //sec
    {
       //if (IsSecDataValid(ConfigTagDurationComboBox->Text))
       //do not check for sec 1-60 because reading config tag gives
       //the value in sec.
       //{
          //Time = timeDuration/0.018;
          Time = timeDuration/.33;
       //}
       //else
       //{
          //Application->MessageBox("ERROR Resend Time: Sec value - Should match one of the values in the list.",
                                  //"Programming Station Information Dialog", MB_OK );
          //return (-1);
       //}
    }
    else if (ConfigTagMinRadioButton->Checked)   //min
    {
       if (IsMinDataValid(ConfigTagDurationComboBox->Text))
       {
          //Time = (timeDuration*60)/0.018;
          Time = (timeDuration*60/.33);
       }
       else
       {
          Application->MessageBox("ERROR Resend Time: Min value - Should match one of the values in the list.",
                                  "Programming Station Information Dialog", MB_OK );
          return (-1);
       }
    }
    else //if (HourRadioButton->Checked)  //hour
    {
       if (IsHourDataValid(ConfigTagDurationComboBox->Text))
       {
          //Time = (timeDuration*60*60)/0.018;
          Time = (timeDuration*60*60/.33);
       }
       else
       {
          Application->MessageBox("ERROR Resend Time: Hour value - Should match one of the values in the list.",
                                  "Programming Station Information Dialog", MB_OK );
          return (-1);
       }
    }
    /*else                                //day
       //Time = (timeDuration*60*60*24)/0.018;
       Time = (timeDuration*60*60*24)/0.33;
    */
    return (Time);

    /////////////////////////////////////////////////
    /*switch (DurationComboBox->ItemIndex)
    {
         case 0:
            Time = 5/0.018;
         break;

         case 1:
            Time = 10/0.018;
         break;

         case 2:
            Time = 15/0.018;
         break;

         case 3:
            Time = 20/0.018;
         break;

         case 4:
            Time = 25/0.018;
         break;

         case 5:
            Time = 30/0.018;
         break;

         case 6:
            Time = 40/0.018;
         break;

         case 7:
            Time = 50/0.018;
         break;

         case 8:
            Time = 60/0.018;
         break;

         default:
              Application->MessageBox("ERROR: NO value for Duration Time is selected .",
                       "Programming Station Information Dialog", MB_OK );

            Time = 0;
         break;
     }*
     return (Time); */
}
//------------------------------------------------------------------------------
/*void __fastcall TProgStationForm::EnableTagBitBtnClick(TObject *Sender)
{
    //LoadEnableDisableByteCommand(true);
    TxClearTagCtrls();
    RxClearTagCtrls();
    Sleep(500);
    ProgammingMode = true;
    StaticText->Caption = "";
    WriteComm(ENABLE_TAG, 0, NULL);
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::DisableTagBitBtnClick(TObject *Sender)
{
    //LoadEnableDisableByteCommand(false);
    TxClearTagCtrls();
    RxClearTagCtrls();
    Sleep(500);
    ProgammingMode = true;
    StaticText->Caption = "";
    WriteComm(DISABLE_TAG, 0, NULL);
}*/
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::DecRadioButtonClick(TObject *Sender)
{
   if (DecButtonClicked)
   {
      DecButtonClicked = false;
      HexFormat = false;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::HexRadioButtonClick(TObject *Sender)
{
   if (HexButtonClicked)
   {
      HexButtonClicked = false;
      HexFormat = true;
   }
}
//---------------------------------------------------------------------------
/*void __fastcall TProgStationForm::EnableTimeCheckBoxClick(TObject *Sender)
{
   if (EnableTimeCheckBox->Checked)
   {
      DurationComboBox->Enabled = true;
      //DayRadioButton->Enabled = true;
      HourRadioButton->Enabled = true;
      MinRadioButton->Enabled = true;
      SecRadioButton->Enabled = true;
      MSRadioButton->Enabled = true;
   }
   else
   {
     DurationComboBox->Enabled = false;
     //DayRadioButton->Enabled = false;
     HourRadioButton->Enabled = false;
     MinRadioButton->Enabled = false;
     SecRadioButton->Enabled = false;
     MSRadioButton->Enabled = false;
   }
} */
//---------------------------------------------------------------------------


void __fastcall TProgStationForm::ClearMsgBitBtnClick(TObject *Sender)
{
   StaticText->Caption = "";
   DetectedMsg->Caption = "";
   TamperSWMsg->Caption = "";

   if (DebugDisplayToolButton->Visible)
   {
      RxClearTagCtrls();
      TxClearTagCtrls();
   }
   else
   {
      RecListBox->Clear();
      index = 0;
      //RecCounter = 0;
      pktCounter = 0;

      TxListBox->Clear();
      //TxCounter = 0;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::CommToolButtonClick(
      TObject *Sender)
{
   modifyComm = true;
   TCommConfigDlg* commCfgDlg = new TCommConfigDlg (this);
   commCfgDlg->ShowModal();
   delete commCfgDlg;
   modifyComm = false;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::DiagnosticsBitBtnClick(TObject *Sender)
{
   TDiagnosticForm *DiagnosticDlg = new TDiagnosticForm (this);
   DiagnosticDlg->ShowModal();
   delete DiagnosticDlg;
}
//---------------------------------------------------------------------------

int __fastcall TProgStationForm::HexToInt(char * buf, int size)
{
   double IntNum = 0;
   int num = 0;
   int y = 0;

   AnsiString s;
   s = buf;
   //strcpy(s.c_str(), buf);
   while (s.Length() < size)
     s = "0" + s;
   strcpy(buf, s.c_str());
   buf = buf + size - 1;
   for (int i=size; i>0; i--)
   {
      if ((*buf == 'a') || (*buf == 'A'))
        num = 10;
      else if ((*buf == 'b') || (*buf == 'B'))
        num = 11;
      else if ((*buf == 'c') || (*buf == 'C'))
        num = 12;
      else if ((*buf == 'd') || (*buf == 'D'))
        num = 13;
      else if ((*buf == 'e') || (*buf == 'E'))
        num = 14;
      else if ((*buf == 'f') || (*buf == 'F'))
        num = 15;
      else if (*buf == '0')
        num = 0;
      else if (*buf == '1')
        num = 1;
      else if (*buf == '2')
        num = 2;
      else if (*buf == '3')
        num = 3;
      else if (*buf == '4')
        num = 4;
      else if (*buf == '5')
        num = 5;
      else if (*buf == '6')
        num = 6;
      else if (*buf == '7')
        num = 7;
      else if (*buf == '8')
        num = 8;
      else if (*buf == '9')
        num = 9;
      else
        num = 0;

      IntNum += num * pow(16, y++);

      buf--;
   }

   return ((int)IntNum);
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::TextDisplayBitBtnClick(TObject *Sender)
{
   /*TxListBox->Visible = false;
   RecListBox->Visible = false;
   DebugDisplayBitBtn->Visible = true;
   TextDisplayBitBtn->Visible = false;
   StopGoTXBitBtn->Visible = false;
   StopGoRXBitBtn->Visible = false;
   RecClear->Visible = false;
   TxClear->Visible = false;
   TXNormalDisplayGroup->Visible = true;
   RXNormalDisplayGroup->Visible = true;
   DecRadioButton->Checked = true;
   DecRadioButton->Enabled = false;
   HexRadioButton->Enabled = false;*/
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::DebugDisplayBitBtnClick(TObject *Sender)
{
   /*if (DebugDisplayBitBtn->Visible)
   {
      TXNormalDisplayGroup->Visible = false;
      RXNormalDisplayGroup->Visible = false;

      TextDisplayBitBtn->Visible = true;
      DebugDisplayBitBtn->Visible = false;

      TxListBox->Visible = true;
      RecListBox->Visible = true;

      StopGoTXBitBtn->Visible = true;
      StopGoRXBitBtn->Visible = true;
      RecClear->Visible = true;
      TxClear->Visible = true;
      HexRadioButton->Checked = true;
      DecRadioButton->Enabled = true;
      HexRadioButton->Enabled = true;
   }
   else
   {
      //ModeDisplayBitBtn->Caption = "Debug Display";
      TxListBox->Visible = false;
      RecListBox->Visible = false;
      StopGoTXBitBtn->Visible = false;
      StopGoRXBitBtn->Visible = false;
      RecClear->Visible = false;
      TxClear->Visible = false;
      TXNormalDisplayGroup->Visible = true;
      RXNormalDisplayGroup->Visible = true;
      DecRadioButton->Checked = true;
      DecRadioButton->Enabled = false;
      HexRadioButton->Enabled = false;
   }*/
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::TxClearTagCtrls()
{
    TxTagTypeLabel->Caption = "";
    TxTagIDLabel->Caption = "";
    TxTagTimeLabel->Caption = "";
    TxTagDirection->Caption = "";
    TxCommandLabel->Caption = "";
    NewTagIDLabel->Caption = "";
    TxReaderIDLabel->Caption = "";
    TxTIFLabel->Caption = "";
    TxGCLabel->Caption = "";
    TxTamperLabel->Caption = "";
}
//------------------------------------------------------------------------------

void __fastcall TProgStationForm::RxClearTagCtrls()
{
   RxTagTypeLabel->Caption = "";
   RxTagIDLabel->Caption = "";
   RxTagTimeLabel->Caption = "";
   RxTagDirection->Caption = "";
   RxCommandLabel->Caption = "";
   GroupID->Caption = "";
   RxReaderIDLabel->Caption = "";
   RxTIFLabel->Caption = "";
   RxGCLabel->Caption = "";
   RxTamperLabel->Caption = "";
   RxBatteryLabel->Caption = "";
   RxRSSILabel->Caption = "";
   ContinuousLabel->Caption = "";
   RxTagStatusLabel->Caption = "";
   RxTagVersionLabel->Caption = "";
   FGenIDLabel->Caption = "";
}
//------------------------------------------------------------------------------
/*void __fastcall TProgStationForm::ReadBitBtnClick(TObject *Sender)
{
    TxClearTagCtrls();
    RxClearTagCtrls();

    StaticText->Caption = "";
    WriteComm(READ_TAG, 0x00, NULL);
}*/
//------------------------------------------------------------------------------

void __fastcall TProgStationForm::RxClearBitBtnClick(TObject *Sender)
{
   RxClearTagCtrls();
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::TxClearBitBtnClick(TObject *Sender)
{
   TxClearTagCtrls();
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::FactoryIDCtrlEnabled(bool b)
{

}
//------------------------------------------------------------------------------
/*void __fastcall TProgStationForm::DayRadioButtonClick(TObject *Sender)
{
   DurationComboBox->Clear();
   DurationComboBox->Items->Add("1 Day");
   DurationComboBox->Items->Add("2 Days");
   DurationComboBox->Items->Add("3 Days");
   DurationComboBox->Items->Add("4 Days");
   DurationComboBox->Items->Add("5 Days");
   DurationComboBox->Items->Add("6 Days");
   DurationComboBox->Items->Add("7 Days");
   DurationComboBox->Items->Add("8 Days");
   DurationComboBox->Items->Add("9 Days");
   DurationComboBox->Items->Add("10 Days");
   DurationComboBox->Items->Add("11 Days");
   DurationComboBox->Items->Add("12 Days");
   DurationComboBox->Items->Add("13 Days");
   DurationComboBox->Items->Add("14 Days");
   DurationComboBox->Items->Add("15 Days");
   DurationComboBox->Items->Add("16 Days");
   DurationComboBox->Items->Add("17 Days");
   DurationComboBox->Items->Add("18 Days");
   DurationComboBox->Items->Add("19 Days");
   DurationComboBox->Items->Add("20 Days");
   DurationComboBox->Items->Add("21 Days");
   DurationComboBox->Items->Add("22 Days");
   DurationComboBox->Items->Add("23 Days");
   DurationComboBox->Items->Add("24 Days");
   DurationComboBox->Items->Add("25 Days");
   DurationComboBox->Items->Add("26 Days");
   DurationComboBox->Items->Add("27 Days");
   DurationComboBox->Items->Add("28 Days");
   DurationComboBox->Items->Add("29 Days");
   DurationComboBox->Items->Add("30 Days");
} */
//------------------------------------------------------------------------------
/*void __fastcall TProgStationForm::SendCommandBitBtnClick(TObject *Sender)
{
   if (CommandComboBox->Text.data() == NULL)
   {
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: No command selected!",
      ( LPCSTR )"Programming Station Information Dialog",
      MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
      return;
   }

   switch (CommandComboBox->ItemIndex)
   {
      case 0:    //Reset Device  0x01
         TxClearTagCtrls();
         RxClearTagCtrls();
         ProgammingMode = true;
         StaticText->Caption = "";
         WriteComm(RESET_DEVICE, 0, NULL);
      break;

      case 1:    //Enable Reader  0x04
         TxClearTagCtrls();
         RxClearTagCtrls();
         ProgammingMode = true;
         StaticText->Caption = "";
         WriteComm(ENABLE_READER, 0, NULL);
      break;

      case 2:    //Disable Reader  0x05
         TxClearTagCtrls();
         RxClearTagCtrls();
         ProgammingMode = true;
         StaticText->Caption = "";
         WriteComm(DISABLE_READER, 0, NULL);
      break;

      case 3:   //CONFIG_TAG  0x06
         if (LoadProgramByteAndTagID())
         {
            if (TIFCheckBox->Checked)
            {
               if (TIFComboBox->Text.data() == NULL)
               {
                  ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: No value for Time in the Field(TIF) is Selected!",
                  ( LPCSTR )"Programming Station Information Dialog",
                  MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
                  return;
               }
            }
            if (GCCheckBox->Checked)
            {
               if (GCComboBox->Text.data() == NULL)
               {
                  ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: No value for Group Count(GC) is Selected!",
                  ( LPCSTR )"Programming Station Information Dialog",
                  MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
                  return;
               }
            }
            TxClearTagCtrls();
            RxClearTagCtrls();
            ProgammingMode = true;
            StaticText->Caption = "";
            TagIDStr = NewIDEdit->Text;
            WriteComm(CONFIG_TAG, 0x0B, NULL);
         }
      break;

      case 4:   //ENABLE_TAG   0x07
         TxClearTagCtrls();
         RxClearTagCtrls();
         ProgammingMode = true;
         StaticText->Caption = "";
         WriteComm(ENABLE_TAG, 0, NULL);
      break;

      case 5:   //DISABLE_TAG  0x08
         TxClearTagCtrls();
         RxClearTagCtrls();
         ProgammingMode = true;
         StaticText->Caption = "";
         WriteComm(DISABLE_TAG, 0, NULL);
      break;

      case 6:   //Query_TAG  0x09
         TxClearTagCtrls();
         RxClearTagCtrls();
         ProgammingMode = true;
         StaticText->Caption = "";
         WriteComm(QUERY_TAG, 0, NULL);
      break;
   }
}*/
//------------------------------------------------------------------------------
int __fastcall TProgStationForm::GetTimeTIF()
{
    int n = 0;
    //switch (ConfigTagTIFComboBox->ItemIndex)
    int m = atoi(ConfigTagTIFComboBox->Text.c_str());
    switch (m)
    {
       case 1:   //1
          n = 0;
       break;

       case 2:  //2
          n = 1;
       break;

       case 4:  //4
          n = 2;
       break;

       case 6:  //6
          n = 3;
       break;

       case 8:  //8
          n = 4;
       break;

       case 10:  //10
          n = 5;
       break;

       case 12:  //12
          n = 6;
       break;

       case 14:  //14
          n = 7;
       break;

       case 16:  //16
          n = 8;
       break;

       case 18:  //18
          n = 9;
       break;

       case 20:  //20
          n = 10;
       break;

       case 22:  //22
          n = 11;
       break;

       case 24:  //24
          n = 12;
       break;

       case 26:  //26
          n = 13;
       break;

       case 28:  //28
          n = 14;
       break;

       case 30:  //30
          n = 15;
       break;

       default:
          n = -1;
       break;
    }

    return (n);
}
//------------------------------------------------------------------------------
int __fastcall TProgStationForm::GetTimeTIFComboBox()
{
    int n = 0;
    switch (ConfigTagTIFComboBox->ItemIndex)
    {
       case 0:       //1
          n = 1;
       break;

       case 1:      //2
          n = 2;
       break;

       case 2:     //4
          n = 2;
       break;

       case 3:     //6
          n = 3;
       break;

       case 4:    //8
          n = 4;
       break;

       case 5:    //10
          n = 5;
       break;

       case 6:    //12
          n = 6;
       break;

       case 7:
          n = 7;
       break;

       case 8:
          n = 8;
       break;

       case 9:
          n = 9;
       break;

       case 10:
          n = 10;
       break;

       case 11:
          n = 11;
       break;

       case 12:
          n = 12;
       break;

       case 13:
          n = 13;
       break;

       case 14:
          n = 14;
       break;

       case 15:
          n = 15;
       break;

       case 16:
          n = 16;
       break;
    }

    return (n);
}
//------------------------------------------------------------------------------
int __fastcall TProgStationForm::GetGC()
{
   int n = 0;
   int m = atoi(ConfigTagGCComboBox->Text.c_str());
   // switch (ConfigTagGCComboBox->ItemIndex)
    switch (m)
    {
       case 1:   //1
          n = 0;
       break;

       case 2:  //2
          n = 1;
       break;

       case 4:  //4
          n = 2;
       break;

       case 6:  //6
          n = 3;
       break;

       case 8:  //8
          n = 4;
       break;

       case 10:  //10
          n = 5;
       break;

       case 12:  //12
          n = 6;
       break;

       case 14:  //14
          n = 7;
       break;

       case 16:  //16
          n = 8;
       break;

       case 18:  //18
          n = 9;
       break;

       case 20:  //20
          n = 10;
       break;

       case 22:  //22
          n = 11;
       break;

       case 24:  //24
          n = 12;
       break;

       case 26:  //26
          n = 13;
       break;

       case 28:  //28
          n = 14;
       break;

       case 30:  //30
          n = 15;
       break;

       default:
          n = -1;
       break;
    }

    return n;
}
//------------------------------------------------------------------------------
int __fastcall TProgStationForm::GetGCComboBox()
{
   int n = 0;
    switch (ConfigTagGCComboBox->ItemIndex)
    {
       case 0:   //1
          n = 1;
       break;

       case 1: //2
          n = 2;
       break;

       case 2:  //4
          n = 4;
       break;

       case 3:  //6
          n = 6;
       break;

       case 4:   //8
          n = 8;
       break;

       case 5: //10
          n = 10;
       break;

       case 6:  //12
          n = 12;
       break;

       case 7:  //14
          n = 14;
       break;

       case 8:  //16
          n = 16;
       break;

       case 9:   //18
          n = 18;
       break;

       case 10: //20
          n = 20;
       break;

       case 11:  //22
          n = 22;
       break;

       case 12:  //24
          n = 24;
       break;

       case 13:   //26
          n = 26;
       break;

       case 14: //28
          n = 28;
       break;

       case 15:  //30
          n = 30;
       break;
    }
    return (n);
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::DisplayStatusByte(int index, unsigned int cmd)
{
    if ((cmd == TAG_DETECTED) || (cmd == TAG_DETECTED_RSSI) || (cmd == QUERY_TAG))
    {
       if ((cmd == TAG_DETECTED) || (cmd == TAG_DETECTED_RSSI))
       {
           //Group ID
           if ((recvBuf[index] & 0x01) == 0x01)
           {
              //group id - toggled
              GroupID->Caption = "2"; //"Low";     //03/25/03 v1.18 temp work around
              //tagDetectedArray[tagDetectCount].gID = true; //true;
           }
           else
           {
              //group id
              GroupID->Caption = "1";
              //tagDetectedArray[tagDetectCount].gID = false;
           }
       }
       else
          GroupID->Caption = "";


       //Tamper switch
       if ((recvBuf[index] & 0x02) == 0x02)
       {
          //Tamper switch enabled
          RxTamperLabel->Caption = "Yes";
          //tagDetectedArray[tagDetectCount].tamperEnabled = true;
       }
       else
       {
          //Tamper switch disabled
          RxTamperLabel->Caption = "No";
          //tagDetectedArray[tagDetectCount].tamperEnabled = false;
       }

       //Continouse 13.56 MHZ
       if ((recvBuf[index] & 0x04) == 0x04)
       {
          //YES
          ContinuousLabel->Caption = "Yes";
          //tagDetectedArray[tagDetectCount].field = true;
       }
       else
       {
          //NO
          ContinuousLabel->Caption = "No";
          //tagDetectedArray[tagDetectCount].field = false;
       }

       //Direction
       if ((recvBuf[index] & 0x08) == 0x08)
       {
          //Bi Direction
          RxTagDirection->Caption = "Bi";
       }
       else
       {
          //Single Direction
          RxTagDirection->Caption = "Single";
       }

       //tag enable
       if ((recvBuf[index] & 0x10) == 0x10)
       {
          //enabled
          RxTagStatusLabel->Caption = "Enabled";
          //tagDetectedArray[tagDetectCount].tagEnabled = true;
       }
       else
       {
          //disabled
          RxTagStatusLabel->Caption = "Disabled";
          //tagDetectedArray[tagDetectCount].tagEnabled = false;
       }
    }

    int p = 0;
    if ((p=GetTagTypesIndex(recvBuf[index])) >= 0)
    {
       tgType = p+1;
       if (p == 7)
          RxTagTypeLabel->Caption = "Factory";
       else
          RxTagTypeLabel->Caption = tagTypes[p];
    }
    else
       RxTagTypeLabel->Caption = "";

    //Tag Type
    /*if ((recvBuf[index] & 0xE0) == 0x20)
    {
       //Access
       RxTagTypeLabel->Caption = "Access";
       //tagDetectedArray[tagDetectCount].tagType = 1;
       tgType = 1;
    }
    else if ((recvBuf[index] & 0xE0) == 0x40)
    {
       RxTagTypeLabel->Caption = "Inventory";
       //tagDetectedArray[tagDetectCount].tagType = 2;
        tgType = 2;
    }
    else if ((recvBuf[index] & 0xE0) == 0x60)
    {
       RxTagTypeLabel->Caption = "Asset";
       //tagDetectedArray[tagDetectCount].tagType = 3;
        tgType = 3;
    }
    else if ((recvBuf[index] & 0xE0) == 0x80)
    {
       //asset
       RxTagTypeLabel->Caption = "Car";
       //tagDetectedArray[tagDetectCount].tagType = 4;
        tgType = 4;
    }
    else if ((recvBuf[index] & 0xE0) == 0xE0)
    {
       //asset
       RxTagTypeLabel->Caption = "Factory";
       //tagDetectedArray[tagDetectCount].tagType = 4;
        tgType = 7;
    }
    else
    {
       //unknown
       RxTagTypeLabel->Caption = " ";
       //tagDetectedArray[tagDetectCount].tagType = 6;
       //tagDetectedArray[tagDetectCount].captionType = 0;
        tgType = 6;
    }*/

    if (cmd == TAG_DETECTED_RSSI)
    {
       RxRSSILabel->Caption = (unsigned char)recvBuf[index+1];
    }

    if (cmd == QUERY_TAG)
    {
       unsigned int n;

       //tag version
       RxTagVersionLabel->Caption = (int)recvBuf[index+1];
       //tagDetectedArray[tagDetectCount].tagVersion = (unsigned short)recvBuf[index+1];

       //TIF Time In Field
       n = (unsigned int)((recvBuf[index+2] & 0xF0) >> 4);
       if (n == 0)
         n = 1;
       else
         n *= 2;
       RxTIFLabel->Caption = n;
       //tagDetectedArray[tagDetectCount].tagTIF = n;

       //GC Group count
       n = (unsigned int)(recvBuf[index+2] & 0x0F);
       if (n == 0)
         n = 1;
       else
         n *= 2;
       RxGCLabel->Caption = n;
       //tagDetectedArray[tagDetectCount].tagGC = n;

       //Resend Time
       n = (unsigned int)((unsigned char)recvBuf[index+3])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[index+4]);
       //double n1 = ceil(n/3.333);
       double n1 = ceil(n/3.00);
       RxTagTimeLabel->Caption = n1;
       //tagDetectedArray[tagDetectCount].tagResendTime = n1;

       //battey
       if ((recvBuf[index] & 0x01) == 0x01)
       {
           RxBatteryLabel->Caption = "Low";
       }
       else
       {
          RxBatteryLabel->Caption = "OK";
       }
    }//QUERY_TAG

}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::DisplayTagInfo(unsigned int id, int index)
{
    TListItem* ListItem;
    unsigned int n;

    ListItem = QueryTagListView->Items->Add();
    ListItem->ImageIndex = -1;
    ListItem->SubItems->Add(id);

    //Tag Type
    int p = 0;
    if ((p=GetTagTypesIndex(recvBuf[index])) >= 0)
    {
       if (p == 7)
          ListItem->SubItems->Add("Factory");
       else
       {
          if (tagTypes[p].data() == NULL)
          {
             AnsiString s;
             if (p == 0)
                s = "T00";
             else
             {
                s = "T0";
                s += p+1;
             }
             ListItem->SubItems->Add(s);
          }
          else
             ListItem->SubItems->Add(tagTypes[p]);
       }
    }
    else
       ListItem->SubItems->Add(" ");

    /*if ((recvBuf[index] & 0xE0) == 0x20)
       ListItem->SubItems->Add("Access");
    else if ((recvBuf[index] & 0xE0) == 0x40)
       ListItem->SubItems->Add("Inventory");
    else if ((recvBuf[index] & 0xE0) == 0x60)
       ListItem->SubItems->Add("Asset");
    else if ((recvBuf[index] & 0xE0) == 0xE0)
       ListItem->SubItems->Add("Factory");
    else
       ListItem->SubItems->Add(" "); */

    //tag enable
    if ((recvBuf[index] & 0x10) == 0x10)
       ListItem->SubItems->Add("Enabled");
    else
       ListItem->SubItems->Add("Disabled");

    //Battery
    if ((recvBuf[index] & 0x01) == 0x01)
       ListItem->SubItems->Add("Low");
    else
       ListItem->SubItems->Add("OK");

    //Resend Time
    n = (unsigned int)((unsigned char)recvBuf[index+3])*pow(2, 8)+(unsigned int)((unsigned char)recvBuf[index+4]);
    double n1 = ceil(n/3.00);
    ListItem->SubItems->Add(n1);

    //TIF Time In Field
    n = (unsigned int)((recvBuf[index+2] & 0xF0) >> 4);
    if (n == 0)
       n = 1;
    else
       n *= 2;
    ListItem->SubItems->Add(n);

    //GC Group count
    n = (unsigned int)(recvBuf[index+2] & 0x0F);
    if (n == 0)
       n = 1;
    else
       n *= 2;
    ListItem->SubItems->Add(n);

    //Tamper switch
    if ((recvBuf[index] & 0x02) == 0x02)
    {
       //Tamper switch enabled
       ListItem->SubItems->Add("Yes");
    }
    else
    {
       //Tamper switch disabled
       ListItem->SubItems->Add("No");

    }

    //tag version
    ListItem->SubItems->Add((int)recvBuf[index+1]);
    ListItem->MakeVisible(false);
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::ResetDeviceBitBtnClick(TObject *Sender)
{
   /*if (!GeneralGroupBox->Visible)   //temp
   {
      GeneralGroupBox->Visible = true;
      ReaderCodeVerGroupBox->Visible = false;
      return;
   }

   GeneralGroupBox->Visible = true;
   ReaderCodeVerGroupBox->Visible = false; */

   //Reset Device  0x01

   /*if (!ResetReaderRadioButton->Checked)
   {
       //Application->MessageBox("Reset Reader Radio Button is NOT checked",
                               //"Programming Station Information Dialog",
                               //MB_OK | MB_ICONSTOP | MB_TOPMOST);

       ResetReaderRadioButton->Checked = true;
       return;
   }*/


   if (ResetModifyReaderCheckBox->Checked)
   {
      if (ResetReaderTypeComboBox->Text.data() == NULL)
      {
         Application->MessageBox ("Error: No Reader Type",
                                  "Programming Station Information Dialog",
                                  MB_OK | MB_ICONSTOP | MB_TOPMOST);
         ResetDeviceBitBtn->Enabled = true;
         return;
      }
   }

   EnableAllCommands(true);

   ResetReaderStaticText->Enabled = true;
   EnableReaderStaticText->Enabled = true;
   DisableReaderStaticText->Enabled = true;
   QueryReaderStaticText->Enabled = true;
   AssignReaderStaticText->Enabled = true;
   ReaderVersionStaticText->Enabled = true;
   //EnableRdrFGenStaticText->Enabled = true;
   //DownloadRdrStaticText->Enabled = true;
   //ConfigTxTimeStaticText->Enabled = true;
   RelayStaticText->Enabled = true;
   InputsStaticText->Enabled = true;
   ConfigFGenStaticText->Enabled = true;
   QueryFGenStaticText->Enabled = true;
   FGenResetStaticText->Enabled = true;
   SmartFGenStaticText->Enabled = true;
   //EnableFGenStaticText->Enabled = true;
   ConfigTagStaticText->Enabled = true;
   EnableTagStaticText->Enabled = true;
   DisableTagStaticText->Enabled = true;
   QueryTagStaticText->Enabled = true;
   CallTagStaticText->Enabled = true;
   AssignTagRdrStaticText->Enabled = true;
   ConfigTagRNDStaticText->Enabled = true;
   ReadMemoryStaticText->Enabled = true;
   WriteMemoryStaticText->Enabled = true;
   EnableTagStaticText->Enabled = true;
   TagTempReadTempValueBitBtn->Enabled = true;
   TagTempRefreshBitBtn->Enabled = true;
   TagTempBitBtn->Enabled = true;
   TagTempStaticText->Enabled = true;

   GetProcRevDateBitBtn->Enabled = true;

   ResetDeviceBitBtn->Font->Color = clRed;
   ResetListView->Items->Clear();
   for (int i=0; i<128; i++)
      readerIDList[i] = 0;
   numReaderIDList = 0;
   TxClearTagCtrls();
   RxClearTagCtrls();
   ProgammingMode = true;
   StaticText->Caption = "";
   DetectedMsg->Caption = "";
   TamperSWMsg->Caption = "";
   TagDetectedGroupBox->Caption = "Detected Tags";
   resetPowerup = true;
   programming = false;
   readerOffLine = true;
   readerOnLine = false;
   fieldGenOffLine = true;
   fieldGenOnLine = false;

   /*if (NewListItemCheckBox->Checked == false)
   {
      tagDetectCount = 0;
      accTagCount = 0;
      assTagCount = 0;
      invTagCount = 0;
      carTagCount = 0;
      nDuplicates = 0;
      ReportACCLabel->Caption = "";
      ReportASSLabel->Caption = "";
      ReportINVLabel->Caption = "";
      ReportCARLabel->Caption = "";
      ReportTotalLabel->Caption = "";
      ReportNDupLabel->Caption = "";
      DetectedTagListView->Items->Clear();
      for (int i=0; i<MAX_TAG_DETECTED; i++)
      {
          tagDetectedArray[i].tagID = 0;
          tagDetectedArray[i].tagType = 6;
          tagDetectedArray[i].fGenID = 0xFF;
          tagDetectedArray[i].gID = false;
          tagDetectedArray[i].lastDetectTime = Now();
      }
   }*/

   uninitReader = false;
   receivedResponse = false;

   /*if (readerFgenButtonActivated)
   {
      ReaderFgenToolButton->Hint = "Set Programming Station To Field Generator Mode";
      readerFgenButtonActivated = false;
      if(networkOn)
         CloseNetworkConnection();
      else if (RS232On)
         ClosePort();
      EnableAllCommands(false);
      if (OpenSerial(comPort, lastBaudrate))
      {
         ProgStationForm->PortOpen = true;
         baudRate = curBaudrate = lastBaudrate;
         PlaySound("Ding.wav", NULL, SND_ASYNC );
      }
      EnableAllCommands(true);
      readerOffLine = true;
      readerOnLine = false;
      fieldGenOffLine = true;
      fieldGenOnLine = false;
   }*/

   //WriteRS232Comm(RESET_DEVICE, 0, NULL, 0);

   if(networkOn)
   {
      if (ResetBroadcastReaderCheckBox->State == cbChecked)
         WriteAWSocket(RESET_DEVICE, 0, "G", 0, 'B', NULL, 0, 0);
      else
      {
         int rdr = atoi(ResetReaderIDComboBox->Text.c_str());
         int index = GetSocketIndex(rdr);
         if (index >= 0)
            WriteAWSocket(RESET_DEVICE, 0, NULL, 0, 'S', NULL, 0, index);
         else
            StaticText->Caption = "No matching socket for the reader.";
      }
   }
   else if (RS232On)
   {
      WriteRS232Comm(RESET_DEVICE, 0, NULL, 0);
   }
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::LoadStatusByteToQue(int statusIndex, unsigned int cmd, int queIndex)
{
    if (statusIndex > 11)
       statusIndex = 11;

    if ((cmd == TAG_DETECTED) || (cmd == QUERY_TAG))
    {
       //Group ID
       if ((recvBuf[statusIndex] & 0x01) == 0x01)
       {
          //group id - toggled
          tagDetectedArray[queIndex].gID = true; //true;
       }
       else
       {
          //group id
          tagDetectedArray[queIndex].gID = false;
       }

       //Tamper switch
       if ((recvBuf[statusIndex] & 0x02) == 0x02)
       {
          //Tamper switch enabled
          tagDetectedArray[queIndex].tamperEnabled = true;
       }
       else
       {
          //Tamper switch disabled
          tagDetectedArray[queIndex].tamperEnabled = false;
       }

       //Continouse 13.56 MHZ
       if ((recvBuf[statusIndex] & 0x04) == 0x04)
       {
          //YES
          tagDetectedArray[queIndex].field = true;
       }
       else
       {
          //NO
          tagDetectedArray[queIndex].field = false;
       }

       //Direction
       if ((recvBuf[statusIndex] & 0x08) == 0x08)
       {
          //Bi Direction
          RxTagDirection->Caption = "Bi";
       }
       else
       {
          //Single Direction
          RxTagDirection->Caption = "Single";
       }

       //tag enable
       if ((recvBuf[statusIndex] & 0x10) == 0x10)
       {
          //enabled
          tagDetectedArray[queIndex].tagEnabled = true;
       }
       else
       {
          //disabled
          tagDetectedArray[queIndex].tagEnabled = false;
       }
    }

    //Tag Type
    if ((recvBuf[statusIndex] & 0xE0) == 0x20)
    {
       tagDetectedArray[queIndex].tagType = 1;
    }
    else if ((recvBuf[statusIndex] & 0xE0) == 0x40)
    {
       tagDetectedArray[queIndex].tagType = 2;
    }
    else if ((recvBuf[statusIndex] & 0xE0) == 0x60)
    {
       tagDetectedArray[queIndex].tagType = 3;
    }
    else if ((recvBuf[statusIndex] & 0xE0) == 0x80)
    {
       tagDetectedArray[queIndex].tagType = 4;
    }
    else if ((recvBuf[statusIndex] & 0xE0) == 0xA0)
    {
       tagDetectedArray[queIndex].tagType = 5;
    }
    else if ((recvBuf[statusIndex] & 0xE0) == 0xC0)
    {
       tagDetectedArray[queIndex].tagType = 6;
    }
    else
    {
       //unknown
       tagDetectedArray[queIndex].tagType = 0;
    }

    if (cmd == QUERY_TAG)
    {
       unsigned int n;

       //tag version
       tagDetectedArray[queIndex].tagVersion = (unsigned short)recvBuf[statusIndex+1];

       //TIF Time In Field
       n = (unsigned int)((recvBuf[statusIndex+2] & 0xF0) >> 4);
       if (n == 0)
         n = 1;
       else
         n *= 2;
       tagDetectedArray[queIndex].tagTIF = n;

       //GC Group count
       n = (unsigned int)(recvBuf[statusIndex+2] & 0x0F);
       if (n == 0)
         n = 1;
       else
         n *= 2;
       tagDetectedArray[queIndex].tagGC = n;

       //Resend Time
       n = (unsigned int)(unsigned char)recvBuf[statusIndex+3]*pow(2, 8)+(unsigned int)(unsigned char)recvBuf[statusIndex+4];
       double n1 = ceil(n/3.333);
       tagDetectedArray[queIndex].tagResendTime = n1;
    }
}
/*
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::ResetDeviceBitBtnClick(TObject *Sender)
{
   //Reset Device  0x01
   TxClearTagCtrls();
   RxClearTagCtrls();
   ProgammingMode = true;
   StaticText->Caption = "";
   resetPowerup = true;
   programming = false;
   readerOffLine = true;
   WriteComm(RESET_DEVICE, 0, NULL, 0);
} */
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::EnableReaderBitBtnClick(TObject *Sender)
{
   /*if (!GeneralGroupBox->Visible)   //temp
   {
      GeneralGroupBox->Visible = true;
      ReaderCodeVerGroupBox->Visible = false;
      return;
   }

   GeneralGroupBox->Visible = true;
   ReaderCodeVerGroupBox->Visible = false; */

   //Enable Reader  0x04

   /*if (!EnableReaderRadioButton->Checked)
   {
       //Application->MessageBox("Enable Reader Radio Button is NOT checked",
                               //"Programming Station Information Dialog",
                               //MB_OK | MB_ICONSTOP | MB_TOPMOST);

       EnableReaderRadioButton->Checked = true;
       return;
   }*/

   EnableReaderBitBtn->Font->Color = clRed;

   TxClearTagCtrls();
   RxClearTagCtrls();
   ProgammingMode = true;
   programming = false;
   StaticText->Caption = "";
   //if (ReaderIDComboBox->Text.data() == NULL)
      //ClearListView();

   receivedResponse = false;
   /*if (readerFgenButtonActivated)
   {
      ReaderFgenToolButton->Hint = "Set Programming Station To Field Generator Mode";
      readerFgenButtonActivated = false;
      if(networkOn)
         CloseNetworkConnection();
      else if (RS232On)
         ClosePort();
      EnableAllCommands(false);
      if (OpenSerial(comPort, lastBaudrate))
      {
         ProgStationForm->PortOpen = true;
         baudRate = curBaudrate = lastBaudrate;
         PlaySound("Ding.wav", NULL, SND_ASYNC );
      }
      EnableAllCommands(true);
      readerOffLine = true;
      readerOnLine = false;
      fieldGenOffLine = true;
      fieldGenOnLine = false;
   }*/

   //WriteRS232Comm(ENABLE_READER, 0, NULL, 0);
   if(networkOn)
   {
      if (EnableReaderBroadcastRdrCheckBox->State == cbChecked)
         WriteAWSocket(ENABLE_READER, 0, "G", 0, 'B', NULL, 0, 0);
      else
      {
         int rdr = atoi(EnableReaderIDComboBox->Text.c_str());
         int index = GetSocketIndex(rdr);
         if (index >= 0)
            WriteAWSocket(ENABLE_READER, 0, NULL, 0, 'S', NULL, 0, index);
         else
            StaticText->Caption = "No matching socket for the reader.";
      }
   }
   else if (RS232On)
   {
      WriteRS232Comm(ENABLE_READER, 0, NULL, 0);
   }
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::DisableReaderBitBtnClick(TObject *Sender)
{
   /*if (!DisableReaderRadioButton->Checked)
   {
       //Application->MessageBox("Disable Reader Radio Button is NOT checked",
                               //"Programming Station Information Dialog",
                               //MB_OK | MB_ICONSTOP | MB_TOPMOST);

       DisableReaderRadioButton->Checked = true;
       return;
   }*/

   DisableReaderBitBtn->Font->Color = clRed;

   //Disable Reader  0x05
   TxClearTagCtrls();
   RxClearTagCtrls();
   ProgammingMode = true;
   StaticText->Caption = "";
   //if (ReaderIDComboBox->Text.data() == NULL)
      //ClearListView();

   receivedResponse = false;
   /*if (readerFgenButtonActivated)
   {
      ReaderFgenToolButton->Hint = "Set Programming Station To Field Generator Mode";
      readerFgenButtonActivated = false;
      if(networkOn)
         CloseNetworkConnection();
      else if (RS232On)
         ClosePort();
      EnableAllCommands(false);
      if (OpenSerial(comPort, lastBaudrate))
      {
         ProgStationForm->PortOpen = true;
         baudRate = curBaudrate = lastBaudrate;
         PlaySound("Ding.wav", NULL, SND_ASYNC );
      }
      EnableAllCommands(true);

      readerOffLine = true;
      readerOnLine = false;
      fieldGenOffLine = true;
      fieldGenOnLine = false;
   }*/
   //WriteRS232Comm(DISABLE_READER, 0, NULL, 0);
   if(networkOn)
   {
      /*int rdr = atoi(DisableReaderIDComboBox->Text.c_str());
      int index = GetIpAddressIndex(rdr);
      if (index >= 0)
      {
         //WriteTCPIPComm(DISABLE_READER, 0, NULL, 0, activeSock[index][0], peerSock[index]);
         WriteTCPIPComm(DISABLE_READER, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
      }*/


         if (DisableReaderBroadcastRdrCheckBox->State == cbChecked)
            WriteAWSocket(DISABLE_READER, 0, "G", 0, 'B', NULL, 0, 0);
         else
         {
            int rdr = atoi(DisableReaderIDComboBox->Text.c_str());
            int index = GetSocketIndex(rdr);
            if (index >= 0)
               WriteAWSocket(DISABLE_READER, 0, NULL, 0, 'S', NULL, 0, index);
            else
               StaticText->Caption = "No matching socket for the reader.";
         }

   }
   else if (RS232On)
   {
      WriteRS232Comm(DISABLE_READER, 0, NULL, 0);
   }
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::DisableTagStaticCommands()
{
   EnableTagStaticText->Enabled = false;         //Enable
   DisableTagStaticText->Enabled = false;        //Disable
   ConfigTagStaticText->Enabled = false;         //Config
   QueryTagStaticText->Enabled = false;          //Query
   CallTagStaticText->Enabled = false;           //Cal
   AssignTagRdrStaticText->Enabled = false;      //Assign reader
   ConfigTagRNDStaticText->Enabled = false;      //Config RND
   ReadMemoryStaticText->Enabled = false;        //Read Memory
   WriteMemoryStaticText->Enabled = false;       //Write Memory
   TagTempStaticText->Enabled = false;           //Config Temp
   TagTempReadTempValueBitBtn->Enabled = false;  //get Config Temp button
   TagTempRefreshBitBtn->Enabled = false;        //Refresh temp button
   TagTempBitBtn->Enabled = false;               //Get temp button
   ConfigTagLEDStaticText->Enabled = false;      //Tag LED
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::DisableReaderStaticCommands()
{
   ResetReaderStaticText->Enabled = false;        //Reset Reader
   EnableReaderStaticText->Enabled = false;       //Enable Reader
   DisableReaderStaticText->Enabled = false;      //Disable Reader
   QueryReaderStaticText->Enabled = false;        //Query Reader
   AssignReaderStaticText->Enabled = false;       //Config Reader
   ReaderVersionStaticText->Enabled = false;      //Get Version Reader
   //EnableRdrFGenStaticText->Enabled = false;      //Enable Transmitter
   RelayStaticText->Enabled = false;              //Output Realay
   InputsStaticText->Enabled = false;             //Input Status
   SetFStrengthStaticText->Enabled = false;       //Set Field Strength
   DownloadRdrStaticText->Enabled = false;        //Download
   DownloadRdrBitBtn->Enabled = false;
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::DisableStdFGenStaticCommands()
{
   QueryFGenStaticText->Enabled = false;          //Query
   ConfigFGenStaticText->Enabled = false;         //Configure
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::DisableSmartFGenStaticCommands()
{
   FGenResetStaticText->Enabled = false;          //Reset
   QuerySFGenStaticText->Enabled = false;         //Query
   ConfigSFGenStaticText->Enabled = false;        //Configure
   SmartFGenStaticText->Enabled = false;          //Call
   DownloadSmartFGenStaticText->Enabled = false;  //Download
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::EnableTagStaticCommands()
{
   EnableTagStaticText->Enabled = true;         //Enable
   DisableTagStaticText->Enabled = true;        //Disable
   ConfigTagStaticText->Enabled = true;         //Config
   QueryTagStaticText->Enabled = true;          //Query
   CallTagStaticText->Enabled = true;           //Cal
   AssignTagRdrStaticText->Enabled = true;      //Assign reader
   ConfigTagRNDStaticText->Enabled = true;      //Config RND
   ReadMemoryStaticText->Enabled = true;        //Read Memory
   WriteMemoryStaticText->Enabled = true;       //Write Memory
   TagTempStaticText->Enabled = true;           //Config Temp
   TagTempReadTempValueBitBtn->Enabled = true;  //get Config Temp button
   TagTempRefreshBitBtn->Enabled = true;        //Refresh temp button
   TagTempBitBtn->Enabled = true;               //Get temp button
   ConfigTagLEDStaticText->Enabled = true;      //Config Tag LED
   FGenResetStaticText->Enabled = true;         //Smart FGen Reset
   QuerySFGenStaticText->Enabled = true;        //Smart FGen Query
   ConfigSFGenStaticText->Enabled = true;       //Smart FGen Config
   SmartFGenStaticText->Enabled = true;         //Smart FGen Call Tag

}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::EnableReaderStaticCommands()
{
   ResetReaderStaticText->Enabled = true;        //Reset Reader
   EnableReaderStaticText->Enabled = true;       //Enable Reader
   DisableReaderStaticText->Enabled = true;      //Disable Reader
   QueryReaderStaticText->Enabled = true;        //Query Reader
   AssignReaderStaticText->Enabled = true;       //Config Reader
   ReaderVersionStaticText->Enabled = true;      //Get Version Reader
   //EnableRdrFGenStaticText->Enabled = true;      //Enable Transmitter
   RelayStaticText->Enabled = true;              //Output Realay
   InputsStaticText->Enabled = true;             //Input Status
   SetFStrengthStaticText->Enabled = true;       //Set Field Strength
   //DownloadRdrStaticText->Enabled = true;        //Download
   DownloadRdrBitBtn->Enabled = true;
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::EnableStdFGenStaticCommands()
{
   QueryFGenStaticText->Enabled = true;          //Query
   ConfigFGenStaticText->Enabled = true;         //Configure
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::EnableSmartFGenStaticCommands()
{
   FGenResetStaticText->Enabled = true;          //Reset
   QuerySFGenStaticText->Enabled = true;         //Query
   ConfigSFGenStaticText->Enabled = true;        //Configure
   SmartFGenStaticText->Enabled = true;          //Call
   ////DownloadSmartFGenStaticText->Enabled = true;  //Download
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::ShowTagStaticCommands()
{
   EnableTagStaticText->Visible = true;         //Enable
   DisableTagStaticText->Visible = true;        //Disable
   ConfigTagStaticText->Visible = true;         //Config
   QueryTagStaticText->Visible = true;          //Query
   CallTagStaticText->Visible = true;           //Cal
   AssignTagRdrStaticText->Visible = true;      //Assign reader
   ConfigTagRNDStaticText->Visible = true;      //Config RND
   ReadMemoryStaticText->Visible = true;        //Read Memory
   WriteMemoryStaticText->Visible = true;       //Write Memory
   TagTempStaticText->Visible = true;           //Config Temp
   TagTempReadTempValueBitBtn->Visible = true;  //get Config Temp button
   TagTempRefreshBitBtn->Visible = true;        //Refresh temp button
   TagTempBitBtn->Visible = true;               //Get temp button
   ConfigTagLEDStaticText->Visible = true;      //Tag LED
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::ShowReaderStaticCommands()
{
   ResetReaderStaticText->Visible = true;        //Reset Reader
   EnableReaderStaticText->Visible = true;       //Enable Reader
   DisableReaderStaticText->Visible = true;      //Disable Reader
   QueryReaderStaticText->Visible = true;        //Query Reader
   AssignReaderStaticText->Visible = true;       //Config Reader
   ReaderVersionStaticText->Visible = true;      //Get Version Reader
   //EnableRdrFGenStaticText->Visible = true;      //Enable Transmitter
   RelayStaticText->Visible = true;              //Output Realay
   InputsStaticText->Visible = true;             //Input Status
   SetFStrengthStaticText->Visible = true;       //Set Field Strength
   DownloadRdrStaticText->Visible = true;        //Download
   DownloadRdrBitBtn->Visible = true;
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::ShowStdFGenStaticCommands()
{
   QueryFGenStaticText->Visible = true;          //Query
   ConfigFGenStaticText->Visible = true;         //Configure
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::ShowSmartFGenStaticCommands()
{
   FGenResetStaticText->Visible = true;          //Reset
   QuerySFGenStaticText->Visible = true;         //Query
   ConfigSFGenStaticText->Visible = true;        //Configure
   SmartFGenStaticText->Visible = true;          //Call
   DownloadSmartFGenStaticText->Visible = true;  //Download
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::ConfigTagBitBtnClick(TObject *Sender)
{
   ConfigTagBitBtn->Font->Color = clRed;

    TxClearTagCtrls();
    RxClearTagCtrls();
    TagDetectedGroupBox->Caption = "Detected Tags";
    ProgammingMode = true;

    if (NewListItemCheckBox->Checked == false)
    {
       //Clear List and all its params ------------
       DetectedTagListView->Items->Clear();

       for (int i=0; i<MAX_TAG_DETECTED; i++)
       {
          tagDetectedArray[i].tagID = 0;
          tagDetectedArray[i].tagType = 6;
          tagDetectedArray[i].fGenID = 0xFF;
          tagDetectedArray[i].gID = false;
          tagDetectedArray[i].lastDetectTime = Now();
       }

       tagDetectCount = 0;

       /*accTagCount = 0;
       assTagCount = 0;
       invTagCount = 0;
       factTagCount = 0;
       nDuplicates = 0;
       ReportACCLabel->Caption = "";
       ReportASSLabel->Caption = "";
       ReportINVLabel->Caption = "";*/

       type1Count = 0;
       type2Count = 0;
       type3Count = 0;
       type4Count = 0;
       type5Count = 0;
       type6Count = 0;
       typeFacCount = 0;

       ReportType1Label->Caption = "";
       ReportType2Label->Caption = "";
       ReportType3Label->Caption = "";
       ReportType4Label->Caption = "";
       ReportType5Label->Caption = "";
       ReportType6Label->Caption = "";
       ReportFACTLabel->Caption = "";

       ReportTotalLabel->Caption = "";
       ReportNDupLabel->Caption = "";

    }

    TagIDStr = NewIDEdit->Text;
    programming = true;
    progStr = "Please wait. ";

    if (ConfigTagTypeComboBox->Text.data() != NULL)
    {
       tagTypeStr = ConfigTagTypeComboBox->Text;
       progStr += "Configuring ";
       progStr += ConfigTagTypeComboBox->Text;
       progStr += " Tag ";
    }
    else
    {
        Application->MessageBox("Error: Need Tag Type",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST );
        ConfigTagBitBtn->Enabled = true;
        return;
    }

    /*if (ConfigTagAccessCtrlRadioButton->Checked)
    {
         tagTypeStr = "Access";
         progStr += "Configuring Access Tag ";
    }
    else if (ConfigTagAssetCtrlRadioButton->Checked)
    {
        tagTypeStr = "Asset";
         progStr += "Configuring Asset Tag ";
    }
    else if (ConfigTagInvetRadioButton->Checked)
    {
         tagTypeStr = "Inventory ";
         progStr += "Configuring Inventory Tag ";
    }
    else if (CarRadioButton->Checked)
    {
         tagTypeStr = "Car";
         progStr += "Configuring Car Tag ";
    }*/

    if ((ConfigTagIDRangeRadioButton->Checked) && (ConfigTagTagIDEdit->Text.data() == NULL))
    {
       Application->MessageBox("Error: Need Tag ID",
                               "Programming Station Information Dialog",
                               MB_OK | MB_ICONSTOP | MB_TOPMOST);
       ConfigTagBitBtn->Enabled = true;
       return;
    }

    //if ((ConfigTagAnyTagRadioButton->Checked) && (ConfigTagAnyTagIDRadioButton->Checked))
    if ((ConfigTagTypeComboBox->Text == "All Types") && (ConfigTagAnyTagIDRadioButton->Checked))
    {
        int ret = Application->MessageBox ("Do you want to Config ALL tags?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "All Types";
        progStr = "Please wait. Configuring All Tags";
    }
    //else if (ConfigTagAnyTagRadioButton->Checked)
    else if (ConfigTagTypeComboBox->Text == "All Types")
    {
       int ret = Application->MessageBox ("Do you want to Config Any Tag Type?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "All Types";
        progStr = "Please wait. Configuring All Tag Types";
    }
    else if (ConfigTagAnyTagIDRadioButton->Checked)
    {
       int ret = Application->MessageBox ("Do you want to Config Any Tag ID?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        progStr = "Please wait. Configuring Any Tag ID";
    }

    StaticText->Caption = progStr;
    receivedResponse = false;

    DisableTagStaticCommands();
    CMDEnableTimer->Enabled = true;

   if(networkOn)
   {
      /*int rdr = atoi(ConfigTagReaderIDComboBox->Text.c_str());
      int index = GetIpAddressIndex(rdr);
      if (index >= 0)
      {
            //WriteTCPIPComm(CONFIG_TAG, 0, NULL, 0, activeSock[index][0], peerSock[index]);
      }     WriteTCPIPComm(CONFIG_TAG, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
      */

      int rdr = atoi(ConfigTagReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(CONFIG_TAG, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(CONFIG_TAG, 0, NULL, 0);
   }
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::EnableTagBitBtnClick(TObject *Sender)
{
   /*if (!GeneralGroupBox->Visible)   //temp
   {
      GeneralGroupBox->Visible = true;
      ReaderCodeVerGroupBox->Visible = false;
      return;
   }

   GeneralGroupBox->Visible = true;
   ReaderCodeVerGroupBox->Visible = false; */

   /*if (!EnableTagRadioButton->Checked)
   {
       //Application->MessageBox("Enable Tag Radio Button is NOT checked",
                               //"Programming Station Information Dialog",
                               //MB_OK | MB_ICONSTOP | MB_TOPMOST);

       EnableTagRadioButton->Checked = true;
       return;
   }*/

   EnableTagBitBtn->Font->Color = clRed;

   //ENABLE_TAG   0x07
   TxClearTagCtrls();
   RxClearTagCtrls();
   StaticText->Caption = "";
   //DetectedMsg->Caption = "";
   //TamperSWMsg->Caption = "";
   //GroupBox16->Caption = "Detected Tags";


   //Clear List and all its params ------------
   if (!EnableTagKeepListCheckBox->Checked)
   {
      EnableTagListView->Items->Clear();
      eTagType01Count = 0;
      eTagType02Count = 0;
      eTagType03Count = 0;
      eTagType04Count = 0;
      eTagType05Count = 0;
      eTagType06Count = 0;
      eTagFactCount = 0;
      eTagTotalCount = 0;
      arrayIndexEnabled = 0;
      EnableTagType01Label->Caption = "0";
      EnableTagType02Label->Caption = "0";
      EnableTagType03Label->Caption = "0";
      EnableTagType04Label->Caption = "0";
      EnableTagType05Label->Caption = "0";
      EnableTagType06Label->Caption = "0";
      EnableTagFactoryLabel->Caption = "0";
      EnableTagTotalLabel->Caption = "0";

      /*EnableTagAccLabel->Caption = "";
      EnableTagAssLabel->Caption = "";
      EnableTagInvLabel->Caption = "";
      EnableTagTotalLabel->Caption = "";*/
   }
   //------------------------------------------
   ProgammingMode = true;

   programming = true;
   progStr = "Please wait. ";

   tagTypeStr = EnableTagTypeComboBox->Text;
   progStr += "Enabling ";
   progStr += EnableTagTypeComboBox->Text;
   progStr += " Tag";

   /*if (EnableTagAccRadioButton->Checked)
   {
      tagTypeStr = "Access";
      progStr += "Enabling Access Tag ";
   }
   else if (EnableTagAssRadioButton->Checked)
   {
      tagTypeStr = "Asset";
      progStr += "Enabling Asset Tag ";
   }
   else if (EnableTagInvRadioButton->Checked)
   {
      tagTypeStr = "Inventory";
      progStr += "Enabling Inventory Tag ";
   }*/

   if ((EnableTagIDRangeRadioButton->Checked) && (EnableTagIDEdit->Text.data() == NULL))
   {
       Application->MessageBox("Error: Need Tag ID",
                               "Programming Station Information Dialog",
                               MB_OK | MB_ICONSTOP | MB_TOPMOST);
       EnableTagBitBtn->Enabled = true;
       return;
   }


   if ((EnableTagTypeComboBox->Text == "All Tags") && (EnableAnyTagIDRadioButton->Checked))
    {
        int ret = Application->MessageBox ("Do you want to Enable ALL tags?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "All Tags";
        progStr = "Please wait. Enabling All Tags";
    }
    else if (EnableTagTypeComboBox->Text == "All Tags")
    {
       int ret = Application->MessageBox ("Do you want to Enable Any Tag Type?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "All Types";
        progStr = "Please wait. Enabling Any Taa Types";
    }
    else if (EnableAnyTagIDRadioButton->Checked)
    {
       int ret = Application->MessageBox ("Do you want to Enable Any Tag ID?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        progStr = "Please wait. Enabling Any Tag ID";
    }


   //if (EnableTagIDRadioButton->Checked || EnableTagAnyRadioButton->Checked)
      //global = true;

   receivedResponse = false;
   StaticText->Caption = progStr;
   receivedResponse = false;
   /*if (readerFgenButtonActivated)
   {
      ReaderFgenToolButton->Hint = "Set Programming Station To Field Generator Mode";
      readerFgenButtonActivated = false;
      if(networkOn)
         CloseNetworkConnection();
      else if (RS232On)
         ClosePort();
      EnableAllCommands(false);
      if (OpenSerial(comPort, lastBaudrate))
      {
         ProgStationForm->PortOpen = true;
         baudRate = curBaudrate = lastBaudrate;
         PlaySound("Ding.wav", NULL, SND_ASYNC );
      }
      EnableAllCommands(true);

      readerOffLine = true;
      readerOnLine = false;
      fieldGenOffLine = true;
      fieldGenOnLine = false;
   }*/

   //WriteRS232Comm(ENABLE_TAG, 0, NULL, 0);

   DisableTagStaticCommands();
   CMDEnableTimer->Enabled = true;
   EnableTagBitBtn->Enabled = false;

   //ResetCMDEnableTimer->Enabled = true;
   //ResetCMDTagBitBtn->Enabled = false;
   if(networkOn)
   {
      /*int rdr = atoi(EnableTagIDComboBox->Text.c_str());
      int index = GetIpAddressIndex(rdr);
      if (index >= 0)
      {
         WriteTCPIPComm(ENABLE_TAG, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
      }*/

      int rdr = atoi(EnableTagIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(ENABLE_TAG, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(ENABLE_TAG, 0, NULL, 0);
   }

   //for trying different tag type if no ACK
   //Temp work around - should be remove later.
   //timerCount = 0;
   //Timer3->Enabled = true;
   //ClearTimer3Que();
   //UpdateTimer3Que();
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::DisableTagBitBtnClick(TObject *Sender)
{
   /*if (!GeneralGroupBox->Visible)   //temp
   {
      GeneralGroupBox->Visible = true;
      ReaderCodeVerGroupBox->Visible = false;
      return;
   }

   GeneralGroupBox->Visible = true;
   ReaderCodeVerGroupBox->Visible = false;*/

   //DISABLE_TAG  0x08

   /*if (!DisableTagRadioButton->Checked)
   {
       //Application->MessageBox("Disable Tag Radio Button is NOT checked",
                               //"Programming Station Information Dialog",
                               //MB_OK | MB_ICONSTOP | MB_TOPMOST);

       DisableTagRadioButton->Checked = true;
       return;
   }*/

   if ((DisableTagIDRangeRadioButton->Checked) && (DisableTagIDEdit->Text.data() == NULL))
   {
       Application->MessageBox("Error: Need Tag ID",
                               "Programming Station Information Dialog",
                               MB_OK | MB_ICONSTOP | MB_TOPMOST);
       DisableTagBitBtn->Enabled = true;
       return;
   }

   DisableTagBitBtn->Font->Color = clRed;

   if (!DisableTagKeepListCheckBox->Checked)
   {
      DisableTagListView->Items->Clear();
      dTagType01Count = 0;
      dTagType02Count = 0;
      dTagType03Count = 0;
      dTagType04Count = 0;
      dTagType05Count = 0;
      dTagType06Count = 0;
      dTagFactCount = 0;
      dTagTotalCount = 0;
      arrayIndexDisabled = 0;

      arrayIndexEnabled = 0;
      DisableTagType01Label->Caption = "0";
      DisableTagType02Label->Caption = "0";
      DisableTagType03Label->Caption = "0";
      DisableTagType04Label->Caption = "0";
      DisableTagType05Label->Caption = "0";
      DisableTagType06Label->Caption = "0";
      EnableTagFactoryLabel->Caption = "0";
      EnableTagTotalLabel->Caption = "0";

      /*DisableTagAccLabel->Caption = "";
      DisableTagAssLabel->Caption = "";
      DisableTagInvLabel->Caption = "";
      DisableTagFactLabel->Caption = "";
      DisableTagTotalLabel->Caption = ""; */
   }   //------------------------------------------

   programming = true;
   progStr = "Please wait. ";

   tagTypeStr = DisableTagTypeComboBox->Text;
   progStr += "Disabling ";
   progStr += DisableTagTypeComboBox->Text;
   progStr += " Tag";

   receivedResponse = false;
   StaticText->Caption = progStr;
   receivedResponse = false;

   if ((DisableTagTypeComboBox->Text == "All Tags") && (DisableAnyTagIDRadioButton->Checked))
    {
        int ret = Application->MessageBox ("Do you want to Disable ALL tags?",
                                           "Programming Station Information Dialog",
                                           MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "All Types";
        progStr = "Please wait. Disabling All Tags";
    }
    else if (DisableTagTypeComboBox->Text == "All Tags")
    {
       int ret = Application->MessageBox ("Do you want to Disable All Tag Types?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "All Types";
        progStr = "Please wait. Disabling All Tag Types";
    }
    else if (DisableAnyTagIDRadioButton->Checked)
    {
       int ret = Application->MessageBox ("Do you want to Disable Any Tag ID?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        progStr = "Please wait. Disabling Any Tag ID";
    }

   DisableTagStaticCommands();
   CMDEnableTimer->Enabled = true;
   DisableTagBitBtn->Enabled = false;

   if(networkOn)
   {
      /*int rdr = atoi(DisableTagIDComboBox->Text.c_str());
      int index = GetIpAddressIndex(rdr);
      if (index >= 0)
      {
            WriteTCPIPComm(DISABLE_TAG, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
      }*/

      int rdr = atoi(DisableTagIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(DISABLE_TAG, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(DISABLE_TAG, 0, NULL, 0);
   }

   //for trying different tag type if no ACK
   //Temp work around - should be remove later.
   //timerCount = 0;
   //Timer3->Enabled = true;
   //ClearTimer3Que();
   //UpdateTimer3Que();
}
//----------------------------------------------------------------
/*void __fastcall TProgStationForm::ClearForGlobalChina()
{
   TxClearTagCtrls();
   RxClearTagCtrls();
   ProgammingMode = true;

   if (NewListItemCheckBox->Checked == false)
   {
      tagDetectCount = 0;
      accTagCount = 0;
      assTagCount = 0;
      invTagCount = 0;
      carTagCount = 0;
      nDuplicates = 0;
      ReportACCLabel->Caption = "";
      ReportASSLabel->Caption = "";
      ReportINVLabel->Caption = "";
      ReportCARLabel->Caption = "";
      ReportTotalLabel->Caption = "";
      ReportNDupLabel->Caption = "";
      DetectedTagListView->Items->Clear();
      for (int i=0; i<MAX_TAG_DETECTED; i++)
      {
          tagDetectedArray[i].tagID = 0;
          tagDetectedArray[i].tagType = 6;
          tagDetectedArray[i].fGenID = 0xFF;
          tagDetectedArray[i].gID = false;
          tagDetectedArray[i].lastDetectTime = Now();
      }
   }
}*/
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::QueryTagBitBtnClick(TObject *Sender)
{
   /*if (!GeneralGroupBox->Visible)   //temp
   {
      GeneralGroupBox->Visible = true;
      ReaderCodeVerGroupBox->Visible = false;
      return;
   }

   GeneralGroupBox->Visible = true;
   ReaderCodeVerGroupBox->Visible = false;*/

   //Query_TAG  0x09

   /*if (!QueryTagRadioButton->Checked)
   {
       //Application->MessageBox("Query Tag Radio Button is NOT checked",
                               //"Programming Station Information Dialog",
                               //MB_OK | MB_ICONSTOP | MB_TOPMOST);

       QueryTagRadioButton->Checked = true;
       return;
   }*/

   QueryTagBitBtn->Font->Color = clRed;

   if (!NewListItemCheckBox->Checked)
   {
      TxClearTagCtrls();
      RxClearTagCtrls();
      ProgammingMode = true;
      StaticText->Caption = "";
      DetectedMsg->Caption = "";
      TamperSWMsg->Caption = "";
      TagDetectedGroupBox->Caption = "Detected Tags";
      tagDetectCount = 0;
      type1Count = 0;
      type2Count = 0;
      type3Count = 0;
      type4Count = 0;
      type5Count = 0;
      type6Count = 0;
      typeFacCount = 0;
      ReportType1Label->Caption = "";
      ReportType2Label->Caption = "";
      ReportType3Label->Caption = "";
      ReportType4Label->Caption = "";
      ReportType5Label->Caption = "";
      ReportType6Label->Caption = "";
      ReportFACTLabel->Caption = "";
      ReportTotalLabel->Caption = "";
      ReportNDupLabel->Caption = "";
      DetectedTagListView->Items->Clear();
      for (int i=0; i<MAX_TAG_DETECTED; i++)
      {
         tagDetectedArray[i].tagID = 0;
         tagDetectedArray[i].tagType = 6;
         tagDetectedArray[i].cmd = 0;
         tagDetectedArray[i].fGenID = 0xFF;
         tagDetectedArray[i].gID = false;
         tagDetectedArray[i].lastDetectTime = Now();
      }
   }

   //StaticText->Caption = "";
   programming = true;
   progStr = "Please wait. ";

   tagTypeStr = QueryTagTypeComboBox->Text;
   progStr += "Querying ";
   progStr += QueryTagTypeComboBox->Text;
   progStr += " Tag";

   /*if (QueryTagAccRadioButton->Checked)
   {
      tagTypeStr = "Access";
      progStr += "Searching Access Tag";
   }
   else if (QueryTagAssRadioButton->Checked)
   {
      tagTypeStr = "Asset";
      progStr += "Searching Asset Tag";
   }
   else if (QueryTagInvRadioButton->Checked)
   {
      tagTypeStr = "Inventory";
      progStr += "Searching Inventory Tag";
   }
   else if (QueryTagFactoryRadioButton->Checked)
   {
      tagTypeStr = "Factory";
      progStr += "Searching Factory Tag";
   }*/

   if ((QueryTagIDRangeRadioButton->Checked) && (QueryTagIDEdit->Text.data() == NULL))
   {
       Application->MessageBox("Error: Need Tag ID",
                               "Programming Station Information Dialog",
                               MB_OK | MB_ICONSTOP | MB_TOPMOST);
       QueryTagBitBtn->Enabled = true;
       return;
   }

   //if ((QueryTagAnyRadioButton->Checked) && (QueryAnyTagIDRadioButton->Checked))
    if ((QueryTagTypeComboBox->Text == "All Types") && (QueryAnyTagIDRadioButton->Checked))
    {
        int ret = Application->MessageBox ("Do you want to Query ALL tags?",
                                           "Programming Station Information Dialog",
                                           MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "All Tags";
        progStr = "Please wait. Querying All Tags";
    }
    //else if (QueryTagAnyRadioButton->Checked)
    else if (QueryTagTypeComboBox->Text == "All Types")
    {
       int ret = Application->MessageBox ("Do you want to Query Any Tag Type?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "All Types";
        progStr = "Please wait. Querying Any Tag Type";
    }
    else if (QueryAnyTagIDRadioButton->Checked)
    {
       int ret = Application->MessageBox ("Do you want to Query Any Tag ID?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        progStr = "Please wait. Querying Any Tag ID";
    }


   DisableTagStaticCommands();
   CMDEnableTimer->Enabled = true;

   StaticText->Caption = progStr;

   if (!QueryTagKeepItemsCheckBox->Checked)
   {
      QueryTagListView->Items->Clear();
   }
   else
   {
      listCount = QueryTagListView->Items->Count;
      QueryTagListView->Invalidate();
   }

   if(networkOn)
   {
      /*int rdr = atoi(QueryTagReaderIDComboBox->Text.c_str());
      int index = GetIpAddressIndex(rdr);
      if (index >= 0)
      {
         WriteTCPIPComm(QUERY_TAG, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
      }*/

      int rdr = atoi(QueryTagReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(QUERY_TAG, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(QUERY_TAG, 0, NULL, 0);
   }
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::Timer3Timer(TObject *Sender)
{
   //this timer is temp work around for the command Enable, Disable, and Query Tag
   //when the particular tag Type is not in the field and there is no reponse from
   //the reader.
   if (timerCount <= 2)
   {
      MultiTagType = true;
      timerCount++;
      resetPowerup = true;
      WriteRS232Comm(RESET_DEVICE, 0, NULL, 0);

      //Sleep(500);
      //SendMultiTagTypePkt();
      //timerCount++;
   }
   else
   {
     MultiTagType = false;
     Timer3->Enabled = false;
     timerCount = 0;
     programming = false;
     StaticText->Caption = "";
     resetPowerup = true;
     WriteRS232Comm(RESET_DEVICE, 0, NULL, 0);
   }
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::ClearTimer3Que()
{
    for (int i=0; i<=3; i++)
       TagTypeAckQue[i] = false;
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::BuildCRC(int index)
{
   //Generating CRC
   crc = 0xFFFF;
   for (int i=0; i<index; i++)    //index = len whole packet
       Generate_CRC(XBuf[i]);

   XBuf[index++] = (char)(crc & 0x00FF) ^ 0xFF;       //LSB first
   XBuf[index] = (char)((crc >> 8) & 0x00FF) ^ 0xFF;   //MSB
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::SendMultiTagTypePkt()
{
    for (int p=0; p<(int)Timer3XBuf[0]; p++)
        XBuf[p] = Timer3XBuf[p+1];

    if (TagTypeAckQue[0] == false)   //Access
    {
       TagTypeAckQue[0] = true;
       tagTypeStr = "Access";

       //if (XBuf[1] == 0x09)  //Query Tag
       {
          if (XBuf[2] == 0x05)  //Reg Reader
          {
             XBuf[6] = 0x00;
             BuildCRC(8);
             TransmiLastPacket(10);
          }
          else //=5 ext reader
          {
             XBuf[7] = 0x00;
             BuildCRC(9);
             TransmiLastPacket(11);
          }
       }
    }
    else if (TagTypeAckQue[1] == false)   //Asset
    {
       TagTypeAckQue[1] = true;
       tagTypeStr = "Asset";

       //if (XBuf[1] == 0x09)  //Query Tag
       {
          if (XBuf[2] == 0x05)  //Reg Reader
          {
             XBuf[6] = 0x80;
             BuildCRC(8);
             TransmiLastPacket(10);
          }
          else //=9 ext reader
          {
             XBuf[7] = 0x80;
             BuildCRC(9);
             TransmiLastPacket(11);
          }
       }
    }
    else if (TagTypeAckQue[2] == false)   //Inventory
    {
       TagTypeAckQue[2] = true;
       tagTypeStr = "inventory";

       //if (XBuf[2] == 0x09)  //Query Tag
       {
          if (XBuf[2] == 0x05)  //Reg Reader
          {
             XBuf[6] = 0x40;
             BuildCRC(8);
             TransmiLastPacket(10);
          }
          else //=9 ext reader
          {
             XBuf[7] = 0x40;
             BuildCRC(9);
             TransmiLastPacket(11);
          }
       }
    }
    else if (TagTypeAckQue[3] == false)   //Car
    {
       TagTypeAckQue[3] = true;
       tagTypeStr = "Car";

       //if (XBuf[2] == 0x09)  //Query Tag
       {
          if (XBuf[2] == 0x05)  //Reg Reader
          {
             XBuf[6] = 0x40;
             BuildCRC(8);
             TransmiLastPacket(10);
          }
          else //=9 ext reader
          {
             XBuf[7] = 0x40;
             BuildCRC(9);
             TransmiLastPacket(11);
          }
       }
    }
       /*else  //disable, enable tag
       {
          if (XBuf[2] == 0x04)  //Reg Reader + tag id
          {
             XBuf[10] = 0x00;
             BuildCRC(11);
             TransmiLastPacket(13);
          }
          else //0x09)  //ext Reader + tag id
          {
             XBuf[11] = 0x00;
             BuildCRC(12);
             TransmiLastPacket(14);
          }
       }
    }
    else if (TagTypeAckQue[1] == false)   //Asset
    {
       TagTypeAckQue[1] = true;

       if (XBuf[1] == 0x09)  //Query Tag
       {
          if (XBuf[2] == 0x08)  //Reg Reader
          {
             XBuf[10] = 0x80;
             BuildCRC(11);
             TransmiLastPacket(13);
          }
          else //=9 ext reader
          {
             XBuf[11] = 0x80;
             BuildCRC(12);
             TransmiLastPacket(14);
          }
       }
       else  //disable, enable tag
       {
          if (XBuf[2] == 0x08)  //Reg Reader + tag id
          {
             XBuf[10] = 0x80;
             BuildCRC(11);
             TransmiLastPacket(13);
          }
          else //0x09)  //ext Reader + tag id
          {
             XBuf[11] = 0x80;
             BuildCRC(12);
             TransmiLastPacket(14);
          }
       }
    }
    else if (TagTypeAckQue[2] == false)   //Inventory
    {
       TagTypeAckQue[2] = true;

       if (XBuf[2] == 0x09)  //Query Tag
       {
          if (XBuf[2] == 0x08)  //Reg Reader
          {
             XBuf[10] = 0x40;
             BuildCRC(11);
             TransmiLastPacket(13);
          }
          else //=9 ext reader
          {
             XBuf[11] = 0x40;
             BuildCRC(12);
             TransmiLastPacket(14);
          }
       }
       else  //disable, enable tag
       {
          if (XBuf[2] == 0x08)  //Reg Reader + tag id
          {
             XBuf[10] = 0x40;
             BuildCRC(11);
             TransmiLastPacket(13);
          }
          else //0x09)  //ext Reader + tag id
          {
             XBuf[11] = 0x40;
             BuildCRC(12);
             TransmiLastPacket(14);
          }
       }
    }*/
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::TransmiLastPacket(int Len)
{
   DWORD BytesSend;
   DWORD dwRes;

   for (int i=0; i<Len; i++)
   {
   SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);
   //if (!WriteFile(comPortID, &XBuf[0], Len, &BytesSend, &overlapWrite))
   if (!WriteFile(comPortID, &XBuf[i], 1, &BytesSend, &overlapWrite))
   {
       if (GetLastError() != ERROR_IO_PENDING)
       {
           SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
           //WriteComm(LAST_COMMAND, XBufLast[0], NULL);
           return;
       }
       else
       {
           dwRes = WaitForSingleObject(overlapWrite.hEvent, WRITE_TIMEOUT);
           switch (dwRes)
           {
               case WAIT_OBJECT_0:
                   if(!GetOverlappedResult(comPortID, &overlapWrite, &BytesSend, TRUE))
                   {
                      SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
                      //WriteComm(LAST_COMMAND, XBufLast[0], NULL);
                      return;
                   }
               break;

               default:
               break;

           }//switch
       }
   }
   }//for loop

   SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);

   sysStr = "Transmit OK";
   MainStatusBar->Panels->Items[0]->Text =  "Transmit OK";
   if (displayTx)
      DisplayTransmitPackets(XBuf, Len, NULL);
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::UpdateTimer3Que()
{
   if (AccessCtrlRadioButton->Checked)
     TagTypeAckQue[0] = true;
   else if (AssetCtrlRadioButton->Checked)
     TagTypeAckQue[1] = true;
   else if (InvetRadioButton->Checked)
     TagTypeAckQue[2] = true;
   else if (CarRadioButton->Checked)
     TagTypeAckQue[3] = true;
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::EnableAllConfigCtrls(bool b)
{
    AccessCtrlRadioButton->Enabled = b;
    AssetCtrlRadioButton->Enabled = b;
    InvetRadioButton->Enabled = b;
    //SameTagTypeRadioButton->Enabled = b;
    //SingleDirectionRadioButton->Enabled = b;
    //BiDirectionRadioButton->Enabled = b;
    ConfigTagEnableTimeCheckBox->Enabled = b;
    CarRadioButton->Enabled = b;
    AnyTagRadioButton->Enabled = b;

    if (b)
    {
       if (ConfigTagEnableTimeCheckBox->Checked)
       {
          //DurationComboBox->Enabled = true;
          //HourRadioButton->Enabled = true;
          //MinRadioButton->Enabled = true;
          //SecRadioButton->Enabled = true;
          //MSRadioButton->Enabled = true;
       }
       else
       {
          //DurationComboBox->Enabled = false;
          //HourRadioButton->Enabled = false;
          //MinRadioButton->Enabled = false;
          //SecRadioButton->Enabled = false;
          //MSRadioButton->Enabled = false;
       }
    }
    else
    {
       ConfigTagEnableTimeCheckBox->Checked = false;
    }

    ConfigTagTIFCheckBox->Enabled = b;
    if (b)
    {
       if (ConfigTagTIFCheckBox->Checked)
       {
          ConfigTagTIFCheckBox->Enabled = true;
          ConfigTagGCComboBox->Enabled = true;
       }
       else
       {
          ConfigTagTIFCheckBox->Enabled = false;
          ConfigTagGCComboBox->Enabled = false;
       }
    }
    else
    {
       ConfigTagTIFCheckBox->Checked = false;
    }

    /*ConfigTagGCComboBox->Enabled = b;
    if (b)
    {
        if (ConfigTagGCCheckBox->Checked)
          ConfigTagGCComboBox->Enabled = true;
        else
          ConfigTagGCComboBox->Enabled = false;
    }
    else
    {
       ConfigTagGCCheckBox->Checked = false;
    }*/

}
//------------------------------------------------------------------------------
bool __fastcall TProgStationForm::IsMSecDataValid(AnsiString str)
{
    bool ret = false;

    str = str.Trim();
    if (str == "330")
      ret = true;
    else if (str == "660")
      ret = true;
    else if (str == "990")
      ret = true;
    else if (str == "1320")
      ret = true;
    else if (str == "1650")
      ret = true;

    return (ret);
}
//---------------------------------------------------------------------------
bool __fastcall TProgStationForm::IsSecDataValid(AnsiString str)
{
    str = str.Trim();
    if (str.data() == NULL)
       return (false);

    int sec = atoi(str.c_str());
    if ((sec < 0) || (sec >= 60))
       return (false);
    else
       return (true);
}
//---------------------------------------------------------------------------
bool __fastcall TProgStationForm::IsMinDataValid(AnsiString str)
{
    str = str.Trim();
    if (str.data() == NULL)
       return (false);

    int sec = atoi(str.c_str());
    if ((sec < 0) || (sec >= 60))
       return (false);
    else
       return (true);
}
//---------------------------------------------------------------------------
bool __fastcall TProgStationForm::IsHourDataValid(AnsiString str)
{
    str = str.Trim();
    if (str.data() == NULL)
       return (false);

    int sec = atoi(str.c_str());
    if ((sec < 0) || (sec >= 7))
       return (false);
    else
       return (true);
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::StopGoRXBitBtnClick(TObject *Sender)
{
   if (StopGoRXBitBtn->Caption == "Stop")
   {
      StopGoRXBitBtn->Caption = "Go";
      displayRx = false;
   }
   else
   {
      StopGoRXBitBtn->Caption = "Stop";
      displayRx = true;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::StopGoTXBitBtnClick(TObject *Sender)
{
  if (StopGoTXBitBtn->Caption == "Stop")
   {
      StopGoTXBitBtn->Caption = "Go";
      displayTx = false;
   }
   else
   {
      StopGoTXBitBtn->Caption = "Stop";
      displayTx = true;
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::AccessCtrlRadioButtonClick(
      TObject *Sender)
{
  /*tagTypeStr = "Access";

  if (!FactoryIDRadioButton->Checked)
  {
     NewIDRadioButton->Enabled = true;
     TagIDRadioButton->Enabled = true;
     FactoryIDRadioButton->Enabled = true;
  }*/

  //if ()
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::AssetCtrlRadioButtonClick(
      TObject *Sender)
{
   /*tagTypeStr = "Asset";

   if (!FactoryIDRadioButton->Checked)
   {
      NewIDRadioButton->Enabled = true;
      TagIDRadioButton->Enabled = true;
      FactoryIDRadioButton->Enabled = true;
   }*/
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::InvetRadioButtonClick(TObject *Sender)
{
   /*tagTypeStr = "Inventory";
   //if (!FactoryIDRadioButton->Checked && !PrevIDRadioButton->Checked)
   if (!FactoryIDRadioButton->Checked)
   {
      NewIDRadioButton->Enabled = true;
      TagIDRadioButton->Enabled = true;
      //PrevIDRadioButton->Enabled = true;
      FactoryIDRadioButton->Enabled = true;
   }*/
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::CarRadioButtonClick(TObject *Sender)
{
   //tagTypeStr = "Car";

   /*if (!FactoryIDRadioButton->Checked)
   {
      NewIDRadioButton->Enabled = true;
      TagIDRadioButton->Enabled = true;
      //FactoryIDRadioButton->Enabled = true;
   }*/
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::RecordToolButtonClick(TObject *Sender)
{
   AnsiString ReportFileName;
   SaveDialog->Filter = "Text (*.txt)|*.txt|All files (*.*)|*.*";
   SaveDialog->FilterIndex = 1; // start the dialog

   if (SaveDialog->Execute())
   {
      if (!FileExists(SaveDialog->FileName))
      {
         fileHandle = fopen(SaveDialog->FileName.c_str(), "w");
         lineCounter = 0;
         txRxCounter = 0;
         if (fileHandle == NULL)
         {
            ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error Opening File.",
            ( LPCSTR )"Programming Station Information Dialog",
            MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
            return;
         }
      }
      else   //file alreay exists
      {

        TFileSysMsgForm* FileSysMsgDlg = new TFileSysMsgForm(this);
        FileSysMsgDlg->ShowModal();
        if (dlgRet == 0x01)  //overwrite
        {
           fileHandle = fopen(SaveDialog->FileName.c_str(), "w");
           lineCounter = 0;
           txRxCounter = 0;
           if (fileHandle == NULL)
           {
              delete (FileSysMsgDlg);
              ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error Opening File.",
              ( LPCSTR )"Programming Station Information Dialog",
              MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
              return;
           }
        }
        else if (dlgRet == 0x02)   //append
        {
           fileHandle = fopen(SaveDialog->FileName.c_str(), "a");
           lineCounter = 0;
           if (fileHandle == NULL)
           {
              delete (FileSysMsgDlg);
              ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error Opening File.",
              ( LPCSTR )"Programming Station Information Dialog",
              MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
              return;
           }
        }
        else
        {
           delete (FileSysMsgDlg);
           //fclose(hfile);
           return;
        }

        delete (FileSysMsgDlg);
        //fclose(hfile);
        //fileHandle = FileCreate(SaveDialog->FileName);
        //StartStopRecBitBtn->Caption = "Start Recording";
        //StartStopRecBitBtn->Enabled = true;
        StartRecToolButton->Visible = true;

      }
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::DecRadioButtonMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{
   HexButtonClicked = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::HexRadioButtonMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{
   DecButtonClicked = true;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::AnyTagRadioButtonClick(TObject *Sender)
{
   /*tagTypeStr = " ";

   NewIDRadioButton->Enabled = false;

   if (FactoryIDRadioButton->State == cbUnchecked)
   {
      NewIDRadioButton->Checked = false;
   }*/
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::TagIDRadioButtonClick(TObject *Sender)
{
   if (tagIDMouseDown)
   {
      tagIDMouseDown = false;
      EnableAllConfigCtrls(true);

      //NewIDRadioButton->Enabled = true;
      //SameTagTypeRadioButton->Enabled = false;
      //AnyTagRadioButton->Enabled = false;
      if (TagIDRadioButton->State == cbUnchecked)
      {
         TagIDEdit->Enabled = false;
         TagIDEdit->Color = clMenu;
      }
      else
      {
         TagIDEdit->Enabled = true;
         TagIDEdit->Color = clWhite;
      }

      /*if (NewIDRadioButton->Checked)
      {
         AnyTagRadioButton->Enabled = false;
         //SameTagTypeRadioButton->Enabled = false;
         AnyTagRadioButton->Checked = false;
         //SameTagTypeRadioButton->Checked = false;
      }*/

      TagIDEdit->Text = "";

      //if (FactoryIDRadioButton->State == cbUnchecked)
      {
         EnableTagBitBtn->Enabled = true;
         DisableTagBitBtn->Enabled = true;
         QueryTagBitBtn->Enabled = true;
      }
      //else
        //SameTagTypeRadioButton->Enabled = false;

      //FactoryIDRadioButton->Checked = false;
      //PrevIDRadioButton->Checked = false;
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::TagIDRadioButtonMouseDown(
      TObject *Sender, TMouseButton Button, TShiftState Shift, int X,
      int Y)
{
   tagIDMouseDown = true;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::FactoryIDRadioButtonMouseDown(
      TObject *Sender, TMouseButton Button, TShiftState Shift, int X,
      int Y)
{
    factoryIDMouseDown = true;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::CallTagBitBtnClick(TObject *Sender)
{
   /*if (!GeneralGroupBox->Visible)   //temp
   {
      GeneralGroupBox->Visible = true;
      ReaderCodeVerGroupBox->Visible = false;
      return;
   }

   GeneralGroupBox->Visible = true;
   ReaderCodeVerGroupBox->Visible = false;*/

   /*if (!CallTagRadioButton->Checked)
   {
       //Application->MessageBox("Call Tag Radio Button is NOT checked",
                               //"Programming Station Information Dialog",
                               //MB_OK | MB_ICONSTOP | MB_TOPMOST);

       CallTagRadioButton->Checked = true;
       return;
   }*/

   CallTagBitBtn->Font->Color = clRed;

   if (!NewListItemCheckBox->Checked)
   {
      TxClearTagCtrls();
      RxClearTagCtrls();
      ProgammingMode = true;
      StaticText->Caption = "";
      DetectedMsg->Caption = "";
      TamperSWMsg->Caption = "";
      TagDetectedGroupBox->Caption = "Detected Tags";
      tagDetectCount = 0;
      type1Count = 0;
      type2Count = 0;
      type3Count = 0;
      type4Count = 0;
      type5Count = 0;
      type6Count = 0;
      typeFacCount = 0;
      ReportType1Label->Caption = "";
      ReportType2Label->Caption = "";
      ReportType3Label->Caption = "";
      ReportType4Label->Caption = "";
      ReportType5Label->Caption = "";
      ReportType6Label->Caption = "";
      ReportFACTLabel->Caption = "";
      ReportTotalLabel->Caption = "";
      ReportNDupLabel->Caption = "";
      DetectedTagListView->Items->Clear();
      for (int i=0; i<MAX_TAG_DETECTED; i++)
      {
          tagDetectedArray[i].tagID = 0;
          tagDetectedArray[i].tagType = 6;
          tagDetectedArray[i].cmd = 0;
          tagDetectedArray[i].fGenID = 0xFF;
          tagDetectedArray[i].gID = false;
          tagDetectedArray[i].lastDetectTime = Now();
      }
   }
   //StaticText->Caption = "";
   programming = true;
   progStr = "Please wait. ";

   tagTypeStr = CallTagTypeComboBox->Text;
   progStr += "Calling ";
   progStr += CallTagTypeComboBox->Text;
   progStr += " Tag";

   /*if (CallTagAccRadioButton->Checked)
   {
      tagTypeStr = "Access";
      progStr += "Calling Access Tag";
   }
   else if (CallTagAssRadioButton->Checked)
   {
      tagTypeStr = "Asset";
      progStr += "Calling Asset Tag";
   }
   else if (CallTagInvRadioButton->Checked)
   {
      tagTypeStr = "Inventory";
      progStr += "Calling Inventory Tag";
   }
   else if (CallTagFactoryRadioButton->Checked)
   {
      tagTypeStr = "Factory";
      progStr += "Calling Factory Tag";
   } */

   if ((CallTagIDRangeRadioButton->Checked) && (CallTagIDEdit->Text.data() == NULL))
   {
       Application->MessageBox("Error: Need Tag ID",
                               "Programming Station Information Dialog",
                               MB_OK | MB_ICONSTOP | MB_TOPMOST);
       CallTagBitBtn->Enabled = true;
       return;
   }

   if ((CallTagTypeComboBox->Text == "All Types") && (CallTagAnyTagIDRadioButton->Checked))
    {
        int ret = Application->MessageBox ("Do you want to Call All Tags?",
                                           "Programming Station Information Dialog",
                                           MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "All Tags";
        progStr = "Please wait. Calling All Tags";
    }
    else if (CallTagTypeComboBox->Text == "All Types")
    {
       int ret = Application->MessageBox ("Do you want to Call All Tag Types?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "All Types";
        progStr = "Please wait. Calling Any Tag Type";
    }
    else if (CallTagAnyTagIDRadioButton->Checked)
    {
       int ret = Application->MessageBox ("Do you want to Call Any Tag ID?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        progStr = "Please wait. Calling Any Tag ID";
    }

   DisableTagStaticCommands();
   CMDEnableTimer->Enabled = true;
   CallTagBitBtn->Enabled = false;

   if(networkOn)
   {
      /*int rdr = atoi(CallTagReaderIDComboBox->Text.c_str());
      int index = GetIpAddressIndex(rdr);
      if (index >= 0)
      {
         WriteTCPIPComm(CALL_TAG, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
      }*/

      int rdr = atoi(CallTagReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(CALL_TAG, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(CALL_TAG, 0, NULL, 0);
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::DebugDisplayToolButtonClick(
      TObject *Sender)
{
   TXNormalDisplayGroup->Visible = false;
   RXNormalDisplayGroup->Visible = false;

   TextDisplayToolButton->Visible = true;
   DebugDisplayToolButton->Visible = false;

   TxListBox->Visible = true;
   RecListBox->Visible = true;

   StopGoTXBitBtn->Visible = true;
   StopGoRXBitBtn->Visible = true;
   RecClear->Visible = true;
   TxClear->Visible = true;
   HexRadioButton->Checked = true;
   DecRadioButton->Enabled = true;
   HexRadioButton->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::TextDisplayToolButtonClick(
      TObject *Sender)
{
   TextDisplayToolButton->Visible = false;
   DebugDisplayToolButton->Visible = true;
   TxListBox->Visible = false;
   RecListBox->Visible = false;
   StopGoTXBitBtn->Visible = false;
   StopGoRXBitBtn->Visible = false;
   RecClear->Visible = false;
   TxClear->Visible = false;
   TXNormalDisplayGroup->Visible = true;
   RXNormalDisplayGroup->Visible = true;
   DecRadioButton->Checked = true;
   DecRadioButton->Enabled = false;
   HexRadioButton->Enabled = false;

}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::HelpToolButtonClick(TObject *Sender)
{
   TAboutForm *AboutDlg = new TAboutForm (this);
   AboutDlg->ShowModal();
   delete AboutDlg;

   /*char test[2];
   test[0] = 0xF0;
   test[1] = 0x10;

   int temp;
   int  tagTemperature;

          temp = ((char)test[0] << 8) + (char)test[1];
          //int nbits = 12;
          if ( test[0] & 0x80 )   //negative num
          {
             temp = nBitTwosComplement(temp, (int)12);
          }
          tagTemperature = temp * -1;
          AnsiString s = s.FormatFloat("##0.###", tagTemperature); // - tagTempCalibC);
          StaticText->Caption = s;

          //tagTemperature =  temp * 0.0625;
   */

   //TAboutFormNoLogo *AboutDlg = new TAboutFormNoLogo (this);
   //AboutDlg->ShowModal();
   //delete AboutDlg;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::StopRecToolButtonClick(TObject *Sender)
{
   if (recording)
   {
      recording = false;
      if (fileHandle != NULL)
        fclose(fileHandle);
      fileHandle = NULL;
   }

   StopRecToolButton->Visible = false;
   StartRecToolButton->Visible = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::StartRecToolButtonClick(TObject *Sender)
{
   if (!recording)
   {
      fileHandle = fopen(SaveDialog->FileName.c_str(), "a");
      if (fileHandle == NULL)
      {
         ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error Opening File.",
         ( LPCSTR )"Programming Station Information Dialog",
         MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
         return;
      }

      recording = true;
   }

   StartRecToolButton->Visible = false;
   StopRecToolButton->Visible = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::CloseToolButtonClick(TObject *Sender)
{
    ClosePort();
    if (fileHandle != NULL)
    {
       fclose(fileHandle);
       fileHandle = NULL;
    }
    Close();
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ClearTagListBitBtnClick(TObject *Sender)
{
   ClearListView();
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::DisplayTagInListView(unsigned int id, unsigned short type)
{
   TListItem* ListItem;

   if (AssignTagReaderGroupBox->Visible)
      ListItem = AssignTagRdrListView->Items->Add();
   else if (ConfigTagRandGroupBox->Visible)
      ListItem = ConfigTagRNDListView->Items->Add();
   else if (EnableTagGroupBox->Visible)
   {
      if (EnableTagKeepListCheckBox->Checked)
         EnableTagListView->Font->Color = clBlue;
      else
         EnableTagListView->Font->Color = clGreen;
      ListItem = EnableTagListView->Items->Add();
   }
   else if (DisableTagGroupBox->Visible)
   {
      if (DisableTagKeepListCheckBox->Checked)
         DisableTagListView->Font->Color = clBlue;
      else
         DisableTagListView->Font->Color = clGreen;
      ListItem = DisableTagListView->Items->Add();
   }
   else
      return;
   ListItem->ImageIndex = -1;
   if (type == 1)
   {
      if (tagTypesAbr[0].data() != NULL)
         ListItem->SubItems->Add(tagTypesAbr[0]);
      else
         ListItem->SubItems->Add("T01");

   }
   else if (type == 2)
   {
      if (tagTypesAbr[1].data() != NULL)
         ListItem->SubItems->Add(tagTypesAbr[1]);
      else
         ListItem->SubItems->Add("T02");

   }
   else if (type == 3)
   {
      if (tagTypesAbr[2].data() != NULL)
         ListItem->SubItems->Add(tagTypesAbr[2]);
      else
         ListItem->SubItems->Add("T03");

   }
   else if (type == 4)
   {
      if (tagTypesAbr[3].data() != NULL)
         ListItem->SubItems->Add(tagTypesAbr[3]);
      else
         ListItem->SubItems->Add("T04");

   }
   else if (type == 5)
   {
      if (tagTypesAbr[4].data() != NULL)
         ListItem->SubItems->Add(tagTypesAbr[4]);
      else
         ListItem->SubItems->Add("T05");

   }
   else if (type == 6)
   {
      if (tagTypesAbr[5].data() != NULL)
         ListItem->SubItems->Add(tagTypesAbr[5]);
      else
         ListItem->SubItems->Add("T06");

   }
   else if (type == 7)
      ListItem->SubItems->Add("FACT");
   else
      ListItem->SubItems->Add("");
   ListItem->SubItems->Add(id);

   /*if (type == 1)
      ListItem->SubItems->Add("ACC");
   else if (type == 2)
      ListItem->SubItems->Add("INV");
   else if (type == 3)
      ListItem->SubItems->Add("AST");
   else if (type == 7)
      ListItem->SubItems->Add("FACT");
   else
      ListItem->SubItems->Add(""); */

}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::DisplayTagInListView(unsigned int index, unsigned char fGenID, bool gID, bool* fGenFlag, bool* gIDFlag, unsigned short rssi, AnsiString stat)
{
   //bool sameTag;
   int* tIndex = 0;

   //if (CheckSameTag(tagDetectedArray[index].tagID, tagDetectedArray[index].tagType, fGenID, gID, fGenFlag, gIDFlag))
      //sameTag = true;
   //else
      //sameTag = false;

   //if (multiDisplayTagDetect || !sameTag)
   {
      //TListItem* ListItem = DetectedTagListView->Items->Add();
      //ListItem->ImageIndex = 0; // = tagDetectCount+1;

      TListItem* ListItem;
      if (DetectedTagListView->Items->Count >= MAX_ENTRY_DETECT_LISTVIEW)
      {
         //int ret = Application->MessageBox("Max entry for the Detected Tags ListView, Do you want to empty the list(RECOMMANDED)", "Programming Station", MB_YESNO);
         //if (ret == IDYES)
           //ClearListView();
         ListItem = DetectedTagListView->Items->Item[0];
         ListItem->Delete();
      }



      if (tagDetectedArray[index].tagType == 0x01)
      {
         ListItem = DetectedTagListView->Items->Add();
         //ListItem->ImageIndex = 0; // = tagDetectCount+1;
         ListItem->ImageIndex = -1;
         //if (duplicateTagFGenDetect)
         ListItem->SubItems->Add(tagDetectedArray[index].fGenID);

         ListItem->SubItems->Add(tagDetectedArray[index].readerID);
         //else
            //ListItem->SubItems->Add(" ");

         if (NewListItemCheckBox->Checked)
            DetectedTagListView->Font->Color = clBlue;
         else
            DetectedTagListView->Font->Color = clGreen;

         /////ListItem->SubItems->Add("ACC");
         if (tagTypesAbr[0].data() != NULL)
            ListItem->SubItems->Add(tagTypesAbr[0]);
         else
            ListItem->SubItems->Add("T01");

         //if (*gIDFlag == true)
            //accTagCount += 1;
      }
      else if (tagDetectedArray[index].tagType == 0x02)
      {
         ListItem = DetectedTagListView->Items->Add();
         //ListItem->ImageIndex = 0; // = tagDetectCount+1;
         ListItem->ImageIndex = -1;

         //if (duplicateTagFGenDetect)
         ListItem->SubItems->Add(tagDetectedArray[index].fGenID);

         ListItem->SubItems->Add(tagDetectedArray[index].readerID);
         //else
            //ListItem->SubItems->Add(" ");

         if (NewListItemCheckBox->Checked)
            DetectedTagListView->Font->Color = clBlue;
         else
            DetectedTagListView->Font->Color = clGreen;


         //ListItem->SubItems->Add("INV");
         if (tagTypesAbr[1].data() != NULL)
            ListItem->SubItems->Add(tagTypesAbr[1]);
         else
            ListItem->SubItems->Add("T02");

         //if (*gIDFlag == true)
            //invTagCount += 1;
      }
      else if (tagDetectedArray[index].tagType == 0x03)  //AST
      {
         ListItem = DetectedTagListView->Items->Add();
         //ListItem->ImageIndex = 0; // = tagDetectCount+1;
         ListItem->ImageIndex = -1;

         //if (duplicateTagFGenDetect)
         ListItem->SubItems->Add(tagDetectedArray[index].fGenID);

         ListItem->SubItems->Add(tagDetectedArray[index].readerID);
         //else
            //ListItem->SubItems->Add(" ");

         if (NewListItemCheckBox->Checked)
            DetectedTagListView->Font->Color = clBlue;
         else
            DetectedTagListView->Font->Color = clGreen;


         //ListItem->SubItems->Add("AST");
         if (tagTypesAbr[2].data() != NULL)
            ListItem->SubItems->Add(tagTypesAbr[2]);
         else
            ListItem->SubItems->Add("T03");

         //if (*gIDFlag == true)
            //assTagCount += 1;
      }
      else if (tagDetectedArray[index].tagType == 0x04)
      {
         ListItem = DetectedTagListView->Items->Add();
         //ListItem->ImageIndex = 0; // = tagDetectCount+1;
         ListItem->ImageIndex = -1;

         //if (duplicateTagFGenDetect)
         ListItem->SubItems->Add(tagDetectedArray[index].fGenID);

         ListItem->SubItems->Add(tagDetectedArray[index].readerID);
         //else
            //ListItem->SubItems->Add(" ");

         if (NewListItemCheckBox->Checked)
            DetectedTagListView->Font->Color = clBlue;
         else
            DetectedTagListView->Font->Color = clGreen;


         //ListItem->SubItems->Add("AST");
         if (tagTypesAbr[3].data() != NULL)
            ListItem->SubItems->Add(tagTypesAbr[3]);
         else
            ListItem->SubItems->Add("T04");

         //if (*gIDFlag == true)
            //assTagCount += 1;
      }
      else if (tagDetectedArray[index].tagType == 0x05)
      {
         ListItem = DetectedTagListView->Items->Add();
         //ListItem->ImageIndex = 0; // = tagDetectCount+1;
         ListItem->ImageIndex = -1;

         //if (duplicateTagFGenDetect)
         ListItem->SubItems->Add(tagDetectedArray[index].fGenID);

         ListItem->SubItems->Add(tagDetectedArray[index].readerID);
         //else
            //ListItem->SubItems->Add(" ");

         if (NewListItemCheckBox->Checked)
            DetectedTagListView->Font->Color = clBlue;
         else
            DetectedTagListView->Font->Color = clGreen;


         //ListItem->SubItems->Add("AST");
         if (tagTypesAbr[4].data() != NULL)
            ListItem->SubItems->Add(tagTypesAbr[4]);
         else
            ListItem->SubItems->Add("T05");

         //if (*gIDFlag == true)
            //assTagCount += 1;
      }
      else if (tagDetectedArray[index].tagType == 0x05)
      {
         ListItem = DetectedTagListView->Items->Add();
         //ListItem->ImageIndex = 0; // = tagDetectCount+1;
         ListItem->ImageIndex = -1;

         //if (duplicateTagFGenDetect)
         ListItem->SubItems->Add(tagDetectedArray[index].fGenID);

         ListItem->SubItems->Add(tagDetectedArray[index].readerID);
         //else
            //ListItem->SubItems->Add(" ");

         if (NewListItemCheckBox->Checked)
            DetectedTagListView->Font->Color = clBlue;
         else
            DetectedTagListView->Font->Color = clGreen;


         //ListItem->SubItems->Add("AST");
         if (tagTypesAbr[5].data() != NULL)
            ListItem->SubItems->Add(tagTypesAbr[5]);
         else
            ListItem->SubItems->Add("T06");

         //if (*gIDFlag == true)
            //assTagCount += 1;
      }
      else if (tagDetectedArray[index].tagType == 0x07)
      {
         ListItem = DetectedTagListView->Items->Add();
         //ListItem->ImageIndex = 0; // = tagDetectCount+1;
         ListItem->ImageIndex = -1;
         //if (duplicateTagFGenDetect)
         ListItem->SubItems->Add(tagDetectedArray[index].fGenID);

         ListItem->SubItems->Add(tagDetectedArray[index].readerID);
         //else
            //ListItem->SubItems->Add(" ");

         if (NewListItemCheckBox->Checked)
            DetectedTagListView->Font->Color = clBlue;
         else
            DetectedTagListView->Font->Color = clGreen;


         ListItem->SubItems->Add("FACT");
         //if (*gIDFlag == true)
            //carTagCount += 1;
      }
      else
         //ListItem->SubItems->Add("??");
         return;

      AnsiString ID = tagDetectedArray[index].tagID;
      if (ID.data() != NULL)
         ListItem->SubItems->Add(ID);
      else
         ListItem->SubItems->Add(" ");

      if (stat == "DET_RSSI")
      {
         ListItem->SubItems->Add(rssi);
         stat = "DET";
      }
      else
         ListItem->SubItems->Add(" ");

      ListItem->SubItems->Add(stat);  //status - DET, QUE, CFG, WMM, RMM

      //if (tagDetectedArray[index].captionType == 0x02)
      if (multiDisplayTagDetect)
      {
         if (!*gIDFlag || !*fGenFlag)
            ListItem->SubItems->Add("MT");
         else
            ListItem->SubItems->Add(" ");
      }
      else if (duplicateTagGIDDetect)
      {
         if (*gIDFlag)
         {
            if (tagDetectedArray[index].gID)
               ListItem->SubItems->Add("G2");
           else
               ListItem->SubItems->Add("G1");
         }
      }
      else if (duplicateTagFGenDetect)
      {
         ListItem->SubItems->Add("FG");
      }
      else
         ListItem->SubItems->Add(" ");

      if (multiDisplayTagDetect)
      {
         /*if (tagDetectedArray[index].tagType == 0x01) //access
            accTagCount += 1;
         else if (tagDetectedArray[index].tagType == 0x02) //inventory
            invTagCount += 1;
         else if (tagDetectedArray[index].tagType == 0x03) //asset
            assTagCount += 1;
         else if (tagDetectedArray[index].tagType == 0x07) //factory
            factTagCount += 1;*/

         if (tagDetectedArray[index].tagType == 0x01)
            type1Count += 1;
         else if (tagDetectedArray[index].tagType == 0x02)
            type2Count += 1;
         else if (tagDetectedArray[index].tagType == 0x03)
            type3Count += 1;
         else if (tagDetectedArray[index].tagType == 0x04)
            type4Count += 1;
         else if (tagDetectedArray[index].tagType == 0x05)
            type5Count += 1;
         else if (tagDetectedArray[index].tagType == 0x06)
            type6Count += 1;
         else if (tagDetectedArray[index].tagType == 0x07)
            typeFacCount += 1;
      }
      else if (duplicateTagFGenDetect || duplicateTagGIDDetect)
      {
         if (*gIDFlag || *fGenFlag)
            nDuplicates++;
         else
         {
            if (tagDetectedArray[index].tagType == 0x01)
              type1Count += 1;
           else if (tagDetectedArray[index].tagType == 0x02)
              type2Count += 1;
           else if (tagDetectedArray[index].tagType == 0x03)
              type3Count += 1;
           else if (tagDetectedArray[index].tagType == 0x04)
              type4Count += 1;
           else if (tagDetectedArray[index].tagType == 0x05)
              type5Count += 1;
           else if (tagDetectedArray[index].tagType == 0x06)
              type6Count += 1;
           else if (tagDetectedArray[index].tagType == 0x07)
              typeFacCount += 1;
         }
      }
      else
      {
         if (tagDetectedArray[index].tagType == 0x01)
            type1Count += 1;
         else if (tagDetectedArray[index].tagType == 0x02)
            type2Count += 1;
         else if (tagDetectedArray[index].tagType == 0x03)
            type3Count += 1;
         else if (tagDetectedArray[index].tagType == 0x04)
            type4Count += 1;
         else if (tagDetectedArray[index].tagType == 0x05)
            type5Count += 1;
         else if (tagDetectedArray[index].tagType == 0x06)
            type6Count += 1;
         else if (tagDetectedArray[index].tagType == 0x07)
            typeFacCount += 1;
      }

      /*ReportACCLabel->Caption = accTagCount;
      ReportASSLabel->Caption = assTagCount;
      ReportINVLabel->Caption = invTagCount;
      ReportFACTLabel->Caption = factTagCount;*/

      ReportType1Label->Caption = type1Count;
      ReportType2Label->Caption = type2Count;
      ReportType3Label->Caption = type3Count;
      ReportType4Label->Caption = type4Count;
      ReportType5Label->Caption = type5Count;
      ReportType6Label->Caption = type6Count;
      ReportFACTLabel->Caption =  typeFacCount;

      ReportNDupLabel->Caption = nDuplicates;
      ReportTotalLabel->Caption = type1Count+type2Count+type3Count+type4Count+type5Count+type6Count+typeFacCount;

      ListItem->Selected = true;
      ListItem->Focused = true;
      ListItem->MakeVisible(false);
   }
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::ConfigToolButtonClick(TObject *Sender)
{
   TConfigProgStationForm* configPSDlg = new TConfigProgStationForm (this);
   configPSDlg->ShowModal();
   delete configPSDlg;

   if (tagTypesUpdated)
      UpdateTagTypesComboBox();
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::UpdateTagTypesComboBox()
{
    EnableTagTypeComboBox->Clear();
    DisableTagTypeComboBox->Clear();
    CallTagTypeComboBox->Clear();
    ConfigTagTypeComboBox->Clear();
    ConfigTagNewTagTypeComboBox->Clear();
    TagTempTagTypeComboBox->Clear();
    WriteMemoryTagTypeComboBox->Clear();
    ReadMemoryTagTypeComboBox->Clear();
    FGenConfigTagTypeComboBox->Clear();
    ConfigTagRNDTagTypeComboBox->Clear();
    AssignTagRdrTagTypeComboBox->Clear();
    ConfigTagLEDTagTypeComboBox->Clear();
    SmartFGenTagTypeComboBox->Clear();
    QueryTagTypeComboBox->Clear();
    EnableFGenTagTypeComboBox->Clear();
    SFGenConfigTagTypeComboBox->Clear();

    for (int i=0; i<6; i++)  //numTagTypes
    {
          if (tagTypes[i].data() == NULL)
             continue;
          EnableTagTypeComboBox->AddItem(tagTypes[i], NULL);
          DisableTagTypeComboBox->AddItem(tagTypes[i], NULL);
          CallTagTypeComboBox->AddItem(tagTypes[i], NULL);
          ConfigTagTypeComboBox->AddItem(tagTypes[i], NULL);
          ConfigTagNewTagTypeComboBox->AddItem(tagTypes[i], NULL);
          TagTempTagTypeComboBox->AddItem(tagTypes[i], NULL);
          WriteMemoryTagTypeComboBox->AddItem(tagTypes[i], NULL);
          ReadMemoryTagTypeComboBox->AddItem(tagTypes[i], NULL);
          FGenConfigTagTypeComboBox->AddItem(tagTypes[i], NULL);
          ConfigTagRNDTagTypeComboBox->AddItem(tagTypes[i], NULL);
          AssignTagRdrTagTypeComboBox->AddItem(tagTypes[i], NULL);
          ConfigTagLEDTagTypeComboBox->AddItem(tagTypes[i], NULL);
          SmartFGenTagTypeComboBox->AddItem(tagTypes[i], NULL);
          QueryTagTypeComboBox->AddItem(tagTypes[i], NULL);
          EnableFGenTagTypeComboBox->AddItem(tagTypes[i], NULL);
          SFGenConfigTagTypeComboBox->AddItem(tagTypes[i], NULL);
    }

    EnableTagTypeComboBox->AddItem("Factory", NULL);
    EnableTagTypeComboBox->AddItem("All Types", NULL);

    DisableTagTypeComboBox->AddItem("Factory", NULL);
    DisableTagTypeComboBox->AddItem("All Types", NULL);

    CallTagTypeComboBox->AddItem("Factory", NULL);
    CallTagTypeComboBox->AddItem("All Types", NULL);

    ConfigTagTypeComboBox->AddItem("Factory", NULL);
    ConfigTagTypeComboBox->AddItem("All Types", NULL);

    ConfigTagNewTagTypeComboBox->AddItem("Factory", NULL);
    ConfigTagNewTagTypeComboBox->AddItem("All Types", NULL);

    TagTempTagTypeComboBox->AddItem("Factory", NULL);
    TagTempTagTypeComboBox->AddItem("All Types", NULL);

    WriteMemoryTagTypeComboBox->AddItem("Factory", NULL);
    WriteMemoryTagTypeComboBox->AddItem("All Types", NULL);

    ReadMemoryTagTypeComboBox->AddItem("Factory", NULL);
    ReadMemoryTagTypeComboBox->AddItem("All Types", NULL);

    FGenConfigTagTypeComboBox->AddItem("Factory", NULL);
    FGenConfigTagTypeComboBox->AddItem("All Types", NULL);

    ConfigTagRNDTagTypeComboBox->AddItem("Factory", NULL);
    ConfigTagRNDTagTypeComboBox->AddItem("All Types", NULL);

    AssignTagRdrTagTypeComboBox->AddItem("Factory", NULL);
    AssignTagRdrTagTypeComboBox->AddItem("All Types", NULL);

    ConfigTagLEDTagTypeComboBox->AddItem("Factory", NULL);
    ConfigTagLEDTagTypeComboBox->AddItem("All Types", NULL);

    SmartFGenTagTypeComboBox->AddItem("Factory", NULL);
    SmartFGenTagTypeComboBox->AddItem("All Types", NULL);

    QueryTagTypeComboBox->AddItem("Factory", NULL);
    QueryTagTypeComboBox->AddItem("All Types", NULL);

    EnableFGenTagTypeComboBox->AddItem("Factory", NULL);
    EnableFGenTagTypeComboBox->AddItem("All Types", NULL);

    SFGenConfigTagTypeComboBox->AddItem("Factory", NULL);
    SFGenConfigTagTypeComboBox->AddItem("All Types", NULL);


    EnableTagTypeComboBox->Text = "All Types";
    DisableTagTypeComboBox->Text = "All Types";
    CallTagTypeComboBox->Text = "All Types";
    ConfigTagTypeComboBox->Text = "All Types";
    ConfigTagNewTagTypeComboBox->Text = "All Types";
    TagTempTagTypeComboBox->Text = "All Types";
    WriteMemoryTagTypeComboBox->Text = "All Types";
    ReadMemoryTagTypeComboBox->Text = "All Types";
    FGenConfigTagTypeComboBox->Text = "All Types";
    ConfigTagRNDTagTypeComboBox->Text = "All Types";
    AssignTagRdrTagTypeComboBox->Text = "All Types";
    ConfigTagLEDTagTypeComboBox->Text = "All Types";
    SmartFGenTagTypeComboBox->Text = "All Types";
    QueryTagTypeComboBox->Text = "All Types";
    EnableFGenTagTypeComboBox->Text = "All Types";
    SFGenConfigTagTypeComboBox->Text = "All Types";


    //Enable Tag Groupbox
    if (tagTypes[0].data() != NULL)
    {
        EnableTagType01Name->Caption = tagTypes[0] + ": ";
        EnableTagType01Name->Font->Color = clBlack;
        EnableTagType01Label->Font->Color = clMaroon;
    }
    else
    {
       EnableTagType01Name->Caption = "Type 1: ";
        EnableTagType01Name->Font->Color = clGray;
        EnableTagType01Label->Font->Color = clGray;
    }

    if (tagTypes[1].data() != NULL)
    {
        EnableTagType02Name->Caption = tagTypes[1] + ": ";
        EnableTagType02Name->Font->Color = clBlack;
        EnableTagType02Label->Font->Color = clMaroon;
    }
    else
    {
        EnableTagType02Name->Caption = "Type 2: ";
        EnableTagType02Name->Font->Color = clGray;
        EnableTagType02Label->Font->Color = clGray;
    }

    if (tagTypes[2].data() != NULL)
    {
        EnableTagType03Name->Caption = tagTypes[2] + ": ";
        EnableTagType03Name->Font->Color = clBlack;
        EnableTagType03Label->Font->Color = clMaroon;
    }
    else
    {
        EnableTagType03Name->Caption = "Type 3: ";
        EnableTagType03Name->Font->Color = clGray;
        EnableTagType03Label->Font->Color = clGray;
    }

    if (tagTypes[3].data() != NULL)
    {
        EnableTagType04Name->Caption = tagTypes[3] + ": ";
        EnableTagType04Name->Font->Color = clBlack;
        EnableTagType04Label->Font->Color = clMaroon;
    }
    else
    {
        EnableTagType04Name->Caption = "Type 4: ";
        EnableTagType04Name->Font->Color = clGray;
        EnableTagType04Label->Font->Color = clGray;
    }

    if (tagTypes[4].data() != NULL)
    {
        EnableTagType05Name->Caption = tagTypes[4] + ": ";
        EnableTagType05Name->Font->Color = clBlack;
        EnableTagType05Label->Font->Color = clMaroon;
    }
    else
    {
        EnableTagType05Name->Caption = "Type 5: ";
        EnableTagType05Name->Font->Color = clGray;
        EnableTagType05Label->Font->Color = clGray;
    }

    if (tagTypes[5].data() != NULL)
    {
        EnableTagType06Name->Caption = tagTypes[5] + ": ";
        EnableTagType06Name->Font->Color = clBlack;
        EnableTagType06Label->Font->Color = clMaroon;
    }
    else
    {
        EnableTagType06Name->Caption = "Type 6: ";
        EnableTagType06Name->Font->Color = clGray;
        EnableTagType06Label->Font->Color = clGray;
    }

    //Disable Tag Groupbox
    if (tagTypes[0].data() != NULL)
    {
        DisableTagType01Name->Caption = tagTypes[0] + ": ";
        DisableTagType01Name->Font->Color = clBlack;
        DisableTagType01Label->Font->Color = clMaroon;
    }
    else
    {
        DisableTagType01Name->Caption = "Type 1: ";
        DisableTagType01Name->Font->Color = clGray;
        DisableTagType01Label->Font->Color = clGray;
    }

    if (tagTypes[1].data() != NULL)
    {
        DisableTagType02Name->Caption = tagTypes[1] + ": ";
        DisableTagType02Name->Font->Color = clBlack;
        DisableTagType02Label->Font->Color = clMaroon;
    }
    else
    {
        DisableTagType02Name->Caption = "Type 2: ";
        DisableTagType02Name->Font->Color = clGray;
        DisableTagType02Label->Font->Color = clGray;
    }

    if (tagTypes[2].data() != NULL)
    {
        DisableTagType03Name->Caption = tagTypes[2] + ": ";
        DisableTagType03Name->Font->Color = clBlack;
        DisableTagType03Label->Font->Color = clMaroon;
    }
    else
    {
        DisableTagType03Name->Caption = "Type 3: ";
        DisableTagType03Name->Font->Color = clGray;
        DisableTagType03Label->Font->Color = clGray;
    }

    if (tagTypes[3].data() != NULL)
    {
        DisableTagType04Name->Caption = tagTypes[3] + ": ";
        DisableTagType04Name->Font->Color = clBlack;
        DisableTagType04Label->Font->Color = clMaroon;
    }
    else
    {
        DisableTagType04Name->Caption = "Type 4: ";
        DisableTagType04Name->Font->Color = clGray;
        DisableTagType04Label->Font->Color = clGray;
    }

    if (tagTypes[4].data() != NULL)
    {
        DisableTagType05Name->Caption = tagTypes[4] + ": ";
        DisableTagType05Name->Font->Color = clBlack;
        DisableTagType05Label->Font->Color = clMaroon;
    }
    else
    {
        DisableTagType05Name->Caption = "Type 5: ";
        DisableTagType05Name->Font->Color = clGray;
        DisableTagType05Label->Font->Color = clGray;
    }

    if (tagTypes[5].data() != NULL)
    {
        DisableTagType06Name->Caption = tagTypes[5] + ": ";
        DisableTagType06Name->Font->Color = clBlack;
        DisableTagType06Label->Font->Color = clMaroon;
    }
    else
    {
        DisableTagType06Name->Caption = "Type 6: ";
        DisableTagType06Name->Font->Color = clGray;
        DisableTagType06Label->Font->Color = clGray;
    }


    //ListView Tag Groupbox
    if (tagTypes[0].data() != NULL)
    {
        ReportType01Label->Caption = tagTypes[0] + ": ";
        ReportType01Label->Font->Color = clBlack;
        ReportType1Label->Font->Color = clMaroon;
    }
    else
    {
        ReportType01Label->Caption = "Type 1: ";
        ReportType01Label->Font->Color = clGray;
        ReportType1Label->Font->Color = clGray;
    }

    if (tagTypes[1].data() != NULL)
    {
        ReportType02Label->Caption = tagTypes[1] + ": ";
        ReportType02Label->Font->Color = clBlack;
        ReportType2Label->Font->Color = clMaroon;
    }
    else
    {
        ReportType02Label->Caption = "Type 2: ";
        ReportType02Label->Font->Color = clGray;
        ReportType2Label->Font->Color = clGray;
    }

    if (tagTypes[2].data() != NULL)
    {
        ReportType03Label->Caption = tagTypes[2] + ": ";
        ReportType03Label->Font->Color = clBlack;
        ReportType3Label->Font->Color = clMaroon;
    }
    else
    {
        ReportType03Label->Caption = "Type 3: ";
        ReportType03Label->Font->Color = clGray;
        ReportType3Label->Font->Color = clGray;
    }

    if (tagTypes[3].data() != NULL)
    {
        ReportType04Label->Caption = tagTypes[3] + ": ";
        ReportType04Label->Font->Color = clBlack;
        ReportType4Label->Font->Color = clMaroon;
    }
    else
    {
        ReportType04Label->Caption = "Type 4: ";
        ReportType04Label->Font->Color = clGray;
        ReportType4Label->Font->Color = clGray;
    }

    if (tagTypes[4].data() != NULL)
    {
        ReportType05Label->Caption = tagTypes[4] + ": ";
        ReportType05Label->Font->Color = clBlack;
        ReportType5Label->Font->Color = clMaroon;
    }
    else
    {
        ReportType05Label->Caption = "Type 5: ";
        ReportType05Label->Font->Color = clGray;
        ReportType5Label->Font->Color = clGray;
    }

    if (tagTypes[5].data() != NULL)
    {
        ReportType06Label->Caption = tagTypes[5] + ": ";
        ReportType06Label->Font->Color = clBlack;
        ReportType6Label->Font->Color = clMaroon;
    }
    else
    {
        ReportType06Label->Caption = "Type 6: ";
        ReportType06Label->Font->Color = clGray;
        ReportType6Label->Font->Color = clGray;
    }


}
//------------------------------------------------------------------------------
bool __fastcall TProgStationForm::CheckSameTag(unsigned int id, unsigned short type,
                                               unsigned char fGenID, bool gID,
                                               bool* fgenFlag, bool* gIDFlag,
                                               unsigned short* dIndex, unsigned short rdr,
                                               unsigned int cmd,
                                               unsigned short rssi)
{
    //int count = 0;
    bool ret = false;

    for (int i=0; i<MAX_TAG_DETECTED; i++)
    {
       if ((tagDetectedArray[i].tagID == id) && (tagDetectedArray[i].tagType == type) &&
            (tagDetectedArray[i].gID == gID) && (tagDetectedArray[i].fGenID == fGenID) &&
            (tagDetectedArray[i].readerID == rdr) && (tagDetectedArray[i].cmd == cmd) &&
            (tagDetectedArray[i].rssi == rssi))
       {
          *dIndex = i;
          return (true);
       }
    }

    for (int i=0; i<MAX_TAG_DETECTED; i++)
    {
       if ((tagDetectedArray[i].tagID == id) && (tagDetectedArray[i].tagType == type) &&
           (tagDetectedArray[i].cmd == cmd) && (tagDetectedArray[i].rssi == rssi))// && (tagDetectedArray[i].readerID != rdr))
       {
          ret = false;

          if (duplicateTagGIDDetect)
          {
             if ((tagDetectedArray[i].gID != gID) && (tagDetectedArray[i].readerID == rdr))
             {
                ret = false;
                *gIDFlag = true;
                *dIndex = i;
             }
          }
          else if ((tagDetectedArray[i].readerID == rdr) && (tagDetectedArray[i].fGenID == fGenID))
             return (true);
          //else
             //ret = false;

          if (duplicateTagFGenDetect)
          {
             if (tagDetectedArray[i].fGenID != fGenID)
             {
                ret = false;
                *fgenFlag = true;
             }
          }

          //return (ret);
       }

    } //for loop

    return (ret);
}
//------------------------------------------------------------------------------
bool __fastcall TProgStationForm::CheckSameTagTemp(unsigned int id,
                                                   unsigned short type,
                                                   bool gID,
                                                   bool* gIDFlag,
                                                   unsigned short* dIndex,
                                                   unsigned int rdr)
{
    bool ret = false;
    DWORD minPeriodicTime = 1000*60; // 1 min

    for (int i=0; i<MAX_TAG_DETECTED; i++)
    {
       if ((tagTempArray[i].tagID == id) && (tagTempArray[i].tagType == type) &&
            (tagTempArray[i].gID == gID) && (tagTempArray[i].readerID == (unsigned short)rdr))
       {
           if ((GetNowTimeValue() - tagTempArray[i].timeValue) < minPeriodicTime)
           {
             *dIndex = i;
             return (true);
           }
       }
    }

    /*for (int i=0; i<MAX_TAG_DETECTED; i++)
    {
       if ((tagDetectedArray[i].tagID == id) && (tagDetectedArray[i].tagType == type)) // && (tagDetectedArray[i].readerID != rdr))
       {
          ret = false;

          if (duplicateTagGIDDetect)
          {
             if ((tagDetectedArray[i].gID != gID) && (tagDetectedArray[i].readerID == rdr))
             {
                ret = false;
                *gIDFlag = true;
                *dIndex = i;
             }
          }
          else if (tagDetectedArray[i].readerID == rdr)
             return (true);

       }

    } //for loop */

    return (ret);
}
//------------------------------------------------------------------------------
bool __fastcall TProgStationForm::CheckDuplicatedTag(unsigned int id, unsigned short type)
{
    bool ret = false;

    for (unsigned int i=0; i<arrayIndex; i++)
    {
       if ((tagArray[i].tagID == id) && (tagArray[i].tagType == type))
          return (true);
    }

    return (ret);
}
//------------------------------------------------------------------------------
bool __fastcall TProgStationForm::CheckDuplicatedEnabledTag(unsigned int id, unsigned short type)
{
    bool ret = false;

    for (int i=0; i<arrayIndexEnabled; i++)
    {
       if ((enabledTagArray[i].tagID == id) && (enabledTagArray[i].tagType == type))
          return (true);
    }

    return (ret);
}
//------------------------------------------------------------------------------
bool __fastcall TProgStationForm::CheckDuplicatedDisabledTag(unsigned int id, unsigned short type)
{
    bool ret = false;

    for (int i=0; i<arrayIndexDisabled; i++)
    {
       if ((disabledTagArray[i].tagID == id) && (disabledTagArray[i].tagType == type))
          return (true);
    }

    return (ret);
}
//------------------------------------------------------------------------------
bool __fastcall TProgStationForm::CheckDuplicatedReader(unsigned int id)
{
    bool ret = false;

    for (unsigned int i=0; i<numReaderIDList; i++)
    {
       if (readerIDList[i] == id)
          return (true);
    }

    return (ret);
}
//------------------------------------------------------------------------------
bool __fastcall TProgStationForm::CheckTagTimeInterval(unsigned int id, unsigned short type, int index)
{
    TDateTime time = Now();
    DWORD d, d1, d2;
    Word Hour=0, Min=0, Sec=0, MSec=0;

    DecodeTime(time, Hour, Min, Sec, MSec);
    d = Hour*60*60*1000 + Min*60*1000 + Sec*1000;


    DecodeTime(tagDetectedArray[index].lastDetectTime, Hour, Min, Sec, MSec);
    d1 = Hour*60*60*1000 + Min*60*1000 + Sec*1000;

    d2 = d - d1;
    //Label37->Caption = d2;

    if (d2 > DELAY_TAG_SEND_TIME)
       return (true);
    else
       return (false);

}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::DetectedTagListViewDrawItem(
      TCustomListView *Sender, TListItem *Item, TRect &Rect,
      TOwnerDrawState State)
{
   //DetectedTagListView->Canvas->FillRect(Rect);
   //Draw(DetectedTagListView->Canvas, Rect.Left, Rect.Top, 0, false);
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::DetectedTagListViewDblClick(
      TObject *Sender)
{
   TListItem* item = DetectedTagListView->Selected;
   TStrings* str;
   AnsiString selectedTypeStr;
   unsigned short selectedTypeInt;
   int index;
   int p = 0;

   if (item)
   {
      str = item->SubItems;
      AnsiString s = str->Text;
      selectedType = GetItem(str, 2);  //s.SubString(1,3);
      selectedId = GetItem(str, 3);   //s.SubString(6, s.Length()-7);

      if ((index=GetIndexTagTypeAbr(selectedType)) < 0)
         return;

      ConfigTagTypeComboBox->ItemIndex = index;
      selectedTypeInt = index+1;

      /*if (selectedType == "ACC")
      {
         selectedTypeStr = "Access";
         selectedTypeInt = 1;
      }
      else if (selectedType == "AST")
      {
         selectedTypeStr = "Asset";
         selectedTypeInt = 3;
      }
      else if (selectedType == "INV")
      {
         selectedTypeStr = "Inventory";
         selectedTypeInt = 2;
      }
      else if (selectedType == "FACT")
      {
         selectedTypeStr = "Factory";
         selectedTypeInt = 7;
      }
      else
      {
         selectedTypeStr = "";
         selectedTypeInt = 0;
      }*/

      for (int i=0; i<MAX_TAG_DETECTED; i++)
      {
         if ((selectedId == tagDetectedArray[i].tagID) &&
             (selectedTypeInt == tagDetectedArray[i].tagType))
         {

            RxTagTypeLabel->Caption = selectedTypeStr;
            RxTagVersionLabel->Caption = tagDetectedArray[i].tagVersion;
            RxTagIDLabel->Caption = tagDetectedArray[i].tagID;
            if (tagDetectedArray[i].field)
              ContinuousLabel->Caption = "True";
            else
              ContinuousLabel->Caption = "False";
            RxTagTimeLabel->Caption = tagDetectedArray[i].tagResendTime;
            RxTIFLabel->Caption = tagDetectedArray[i].tagTIF;
            RxReaderIDLabel->Caption = tagDetectedArray[i].readerID;
            RxGCLabel->Caption = tagDetectedArray[i].tagGC;
            /*if (tagDetectedArray[i].batteryLow) //v1.18 03/25/03 temp work around
               BatteryStatus->Caption = "Low";
            else
               BatteryStatus->Caption = "OK";*/
            if (tagDetectedArray[i].tagEnabled)
               RxTagStatusLabel->Caption = "Enable";
            else
               RxTagStatusLabel->Caption = "Disable";
            RxTagDirection->Caption = "";
            if (tagDetectedArray[i].tamperEnabled)
               RxTamperLabel->Caption = "Yes";
            else
               RxTamperLabel->Caption = "No";
            if (tagDetectedArray[i].fGenID)
               FGenIDLabel->Caption = tagDetectedArray[i].fGenID;
            else
               FGenIDLabel->Caption = " ";
            RxCommandLabel->Caption = "";
            break;
         }
      }


      if (selectedType == "ACC")
         AccessCtrlRadioButton->Checked = true;
      else if (selectedType == "AST")
         AssetCtrlRadioButton->Checked = true;
      else if (selectedType == "INV")
         InvetRadioButton->Checked = true;
      //else if (selectedType == "FACT")
         //QueryTagFactoryRadioButton->Checked = true;

      tagIDMouseDown = true;
      //TagIDRadioButton->Checked = true;
      //TagIDEdit->Text = selectedId;
      if (ConfigTagLEDGroupBox->Visible)
      {
         if ((p=GetTagTypeComboBoxIndex(selectedType)) >= 0)
         {
             ConfigTagLEDTagTypeComboBox->ItemIndex = p;
             ConfigTagLEDTagTypeComboBox->Invalidate();
         }

         /*if (selectedType == "ACC")
            ConfigTagLEDAccRadioButton->Checked = true;
         else if (selectedType == "AST")
            ConfigTagLEDAssRadioButton->Checked = true;
         else if (selectedType == "INV")
            ConfigTagLEDInvRadioButton->Checked = true; */

         ConfigTagLEDTagIDRadioButton->Checked = true;
         ConfigTagLEDTagIDEdit->Text = selectedId;
      }
      else if (AssignTagReaderGroupBox->Visible)
      {
         if ((p=GetTagTypeComboBoxIndex(selectedType)) >= 0)
             AssignTagRdrTagTypeComboBox->ItemIndex = p;

         /*if (selectedType == "ACC")
            AssignTagRdrAccRadioButton->Checked = true;
         else if (selectedType == "AST")
            AssignTagRdrAssRadioButton->Checked = true;
         else if (selectedType == "INV")
            AssignTagRdrInvRadioButton->Checked = true;*/

         AssignTagRdrTagIDEdit->Text = selectedId;
      }
      else if (ConfigTagRandGroupBox->Visible)
      {
         if ((p=GetTagTypeComboBoxIndex(selectedType)) >= 0)
             ConfigTagRNDTagTypeComboBox->ItemIndex = p;

         /*if (selectedType == "ACC")
            ConfigTagRNDAccRadioButton->Checked = true;
         else if (selectedType == "AST")
            ConfigTagRNDAssRadioButton->Checked = true;
         else if (selectedType == "INV")
            ConfigTagRNDInvRadioButton->Checked = true;*/

         ConfigTagRNDTagIDEdit->Text = selectedId;
      }
      else if (ConfigTagGroupBox->Visible)  //config tag
      {
          if ((p=GetTagTypeComboBoxIndex(selectedType)) >= 0)
             ConfigTagTypeComboBox->ItemIndex = p;

         //if (selectedType == "ACC")
            //ConfigTagAccessCtrlRadioButton->Checked = true;
         //else if (selectedType == "AST")
            //ConfigTagAssetCtrlRadioButton->Checked = true;
         //else if (selectedType == "INV")
            //ConfigTagInvetRadioButton->Checked = true;
         //else if (selectedType == "FACT")
            //ConfigTagFactoryRadioButton->Checked = true;

         ConfigTagTagIDEdit->Text = selectedId;
         ConfigTagTagIDRadioButton->Checked = true;
      }
      else if (EnableTagGroupBox->Visible)
      {
          if ((p=GetTagTypeComboBoxIndex(selectedType)) >= 0)
             EnableTagTypeComboBox->ItemIndex = p;

         /*if (selectedType == "ACC")
            EnableTagAccRadioButton->Checked = true;
         else if (selectedType == "AST")
            EnableTagAssRadioButton->Checked = true;
         else if (selectedType == "INV")
            EnableTagInvRadioButton->Checked = true;
         else if (selectedType == "FACT")
            EnableTagFactoryRadioButton->Checked = true;*/

         EnableTagIDEdit->Text = selectedId;
         EnableTagIDRadioButton->Checked = true;
      }
      else if (DisableTagGroupBox->Visible)
      {
         if ((p=GetTagTypeComboBoxIndex(selectedType)) >= 0)
             DisableTagTypeComboBox->ItemIndex = p;

         /*if (selectedType == "ACC")
            DisableTagAccRadioButton->Checked = true;
         else if (selectedType == "AST")
            DisableTagAssRadioButton->Checked = true;
         else if (selectedType == "INV")
            DisableTagInvRadioButton->Checked = true;
         else if (selectedType == "FACT")
            DisableTagFactoryRadioButton->Checked = true;*/

         DisableTagIDEdit->Text = selectedId;
         DisableTagIDRadioButton->Checked = true;
      }
      else if (QueryTagGroupBox->Visible)
      {
          if ((p=GetTagTypeComboBoxIndex(selectedType)) >= 0)
             QueryTagTypeComboBox->ItemIndex = p;

         /*if (selectedType == "ACC")
            QueryTagAccRadioButton->Checked = true;
         else if (selectedType == "AST")
            QueryTagAssRadioButton->Checked = true;
         else if (selectedType == "INV")
            QueryTagInvRadioButton->Checked = true;
         else if (selectedType == "FACT")
            QueryTagFactoryRadioButton->Checked = true;*/

         QueryTagIDEdit->Text = selectedId;
         QueryTagIDRadioButton->Checked = true;
      }
      else if (CallTagGroupBox->Visible)
      {
          if ((p=GetTagTypeComboBoxIndex(selectedType)) >= 0)
             CallTagTypeComboBox->ItemIndex = p;

         /*if (selectedType == "ACC")
            CallTagAccRadioButton->Checked = true;
         else if (selectedType == "AST")
            CallTagAssRadioButton->Checked = true;
         else if (selectedType == "INV")
            CallTagInvRadioButton->Checked = true;
         else if (selectedType == "FACT")
            CallTagFactoryRadioButton->Checked = true;*/

         CallTagIDEdit->Text = selectedId;
         CallTagIDRadioButton->Checked = true;
      }
      else if (WriteMemoryGroupBox->Visible)
      {
         if ((p=GetTagTypeComboBoxIndex(selectedType)) >= 0)
             WriteMemoryTagTypeComboBox->ItemIndex = p;

         /*if (selectedType == "ACC")
            WriteMemoryAccRadioButton->Checked = true;
         else if (selectedType == "AST")
            WriteMemoryAssRadioButton->Checked = true;
         else if (selectedType == "INV")
            WriteMemoryInvRadioButton->Checked = true;*/

         WriteMemoryTagIDEdit->Text = selectedId;
         WriteMemoryTagIDRadioButton->Checked = true;
      }
      else if (ReadMemoryGroupBox->Visible)
      {
         if ((p=GetTagTypeComboBoxIndex(selectedType)) >= 0)
             ReadMemoryTagTypeComboBox->ItemIndex = p;

         /*if (selectedType == "ACC")
            ReadMemoryAccRadioButton->Checked = true;
         else if (selectedType == "AST")
            ReadMemoryAssRadioButton->Checked = true;
         else if (selectedType == "INV")
            ReadMemoryInvRadioButton->Checked = true;*/

         ReadMemoryTagIDEdit->Text = selectedId;
         ReadMemoryTagIDRadioButton->Checked = true;
      }
      else if (TagTempGroupBox->Visible)
      {
         if ((p=GetTagTypeComboBoxIndex(selectedType)) >= 0)
             TagTempTagTypeComboBox->ItemIndex = p;

         /*if (selectedType == "ACC")
            TagTempAccRadioButton->Checked = true;
         else if (selectedType == "AST")
            TagTempAssRadioButton->Checked = true;
         else if (selectedType == "INV")
            TagTempInvRadioButton->Checked = true;*/

         TagTempTagIDEdit->Text = selectedId;
         TagTempTagIDRadioButton->Checked = true;
      }
      else if (SmartFGenGroupBox->Visible)
      {
         if ((p=GetTagTypeComboBoxIndex(selectedType)) >= 0)
             SmartFGenTagTypeComboBox->ItemIndex = p;

         /*if (selectedType == "ACC")
            SmartFGenAccessRadioButton->Checked = true;
         else if (selectedType == "AST")
            SmartFGenAssetRadioButton->Checked = true;
         else if (selectedType == "INV")
            SmartFGenInventoryRadioButton->Checked = true;*/

         SmartFGenTagIDEdit->Text = selectedId;
         SmartFGenTagIDRadioButton->Checked = true;
      }
   }
   else
   {
      selectedType.SetLength(0);
      selectedId.SetLength(0);
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::RelayBitBtnClick(
      TObject *Sender)
{
   RelayBitBtn->Font->Color = clRed;

   TxClearTagCtrls();
   RxClearTagCtrls();
   ProgammingMode = true;
   programming = false;
   StaticText->Caption = "";

   receivedResponse = false;
   /*if (readerFgenButtonActivated)
   {
      ReaderFgenToolButton->Hint = "Set Programming Station To Field Generator Mode";
      readerFgenButtonActivated = false;
      if(networkOn)
         CloseNetworkConnection();
      else if (RS232On)
         ClosePort();
      EnableAllCommands(false);
      if (OpenSerial(comPort, lastBaudrate))
      {
         ProgStationForm->PortOpen = true;
         baudRate = curBaudrate = lastBaudrate;
         PlaySound("Ding.wav", NULL, SND_ASYNC );
      }
      EnableAllCommands(true);
      readerOffLine = true;
      readerOnLine = false;
      fieldGenOffLine = true;
      fieldGenOnLine = false;
   }*/

   if(networkOn)
   {
      /*int rdr = atoi(RelayReaderIDComboBox->Text.c_str());
      int index = GetIpAddressIndex(rdr);
      if (index >= 0)
      {
         if (EnableRelayCheckBox->State == cbChecked)
            WriteTCPIPComm(ENABLE_RELAY, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
         else
            WriteTCPIPComm(DISABLE_RELAY, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
      }*/

      int rdr = atoi(RelayReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         if ((EnableRelay1RadioButton->Checked) || (EnableRelay2RadioButton->Checked))
             WriteAWSocket(ENABLE_RELAY, 0, NULL, index, 'S', NULL, 0, index);
         else
             WriteAWSocket(DISABLE_RELAY, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      if ((EnableRelay1RadioButton->Checked) || (EnableRelay2RadioButton->Checked))
          WriteRS232Comm(ENABLE_RELAY, 0, NULL, 0);
      else
          WriteRS232Comm(DISABLE_RELAY, 0, NULL, 0);
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::AssignReaderBitBtnClick(TObject *Sender)
{
   /*if (!GeneralGroupBox->Visible)   //temp
   {
      GeneralGroupBox->Visible = true;
      ReaderCodeVerGroupBox->Visible = false;
      return;
   }

   GeneralGroupBox->Visible = true;
   ReaderCodeVerGroupBox->Visible = false; */

   /*if (!AssignReaderRadioButton->Checked)
   {
       //Application->MessageBox("Assign Reader Radio Button is NOT checked",
                               //"Programming Station Information Dialog",
                               //MB_OK | MB_ICONSTOP | MB_TOPMOST);

       AssignReaderRadioButton->Checked = true;
       return;
   }*/

   if ((AssignReaderNewRdrCheckBox->Checked) &&
       (AssignReaderNewIDEdit->Text.data() == NULL))
   {
      Application->MessageBox("Error: No value for new Reader ID.",
                               "Programming Station Information Dialog",
                               MB_OK | MB_ICONSTOP | MB_TOPMOST);
      return;
   }

   if ((AssignReaderNewHostCheckBox->Checked) &&
       (AssignReaderNewHostIDEdit->Text.data() == NULL))
   {
      Application->MessageBox("Error: No value for new Host ID.",
                               "Programming Station Information Dialog",
                               MB_OK | MB_ICONSTOP | MB_TOPMOST);
      return;
   }

   if (!AssignReaderNewRdrCheckBox->Checked &&
       !AssignReaderNewHostCheckBox->Checked &&
       !AssignReaderNoChangeCheckBox->Checked &&
       !AssignReaderModifyWTCheckBox->Checked &&
       !AssignReaderModifyMDCheckBox->Checked &&
       !AssignReaderModifyTXCheckBox->Checked)
   {
      Application->MessageBox("Error: No Modify checkBox is selected.",
                              "Programming Station Information Dialog",
                              MB_OK | MB_ICONSTOP | MB_TOPMOST);
      return;
   }
   AssignReaderBitBtn->Font->Color = clRed;

   TxClearTagCtrls();
   RxClearTagCtrls();
   ProgammingMode = true;
   programming = false;
   progStr = "Please wait. Configuring Reader ...";
   numReaderIDList = 0;
   StaticText->Caption = progStr;
   receivedResponse = false;
   /*if (readerFgenButtonActivated)
   {
      ReaderFgenToolButton->Hint = "Set Programming Station To Field Generator Mode";
      readerFgenButtonActivated = false;
      if(networkOn)
         CloseNetworkConnection();
      else if (RS232On)
         ClosePort();
      EnableAllCommands(false);
      if (OpenSerial(comPort, lastBaudrate))
      {
         ProgStationForm->PortOpen = true;
         baudRate = curBaudrate = lastBaudrate;
         PlaySound("Ding.wav", NULL, SND_ASYNC );
      }
      EnableAllCommands(true);

      readerOffLine = true;
      readerOnLine = false;
      fieldGenOffLine = true;
      fieldGenOnLine = false;
   }*/
   //WriteRS232Comm(ASSIGN_READER, 0, NULL, 0);
   AssignReaderListView->Items->Clear();
   if (AssignReaderModifyTXCheckBox->Checked ||
       AssignReaderModifyWTCheckBox->Checked ||
       AssignReaderModifyMDCheckBox->Checked)
       getRdrConfig = true;
   else
       getRdrConfig = false;

   rdrConfigFlag = false;
   rdrConfigTxFlag = false;
   fGenConfigFlag = false;

   if (AssignReaderNewRdrCheckBox->Checked ||
       AssignReaderNewHostCheckBox->Checked ||
       AssignReaderNoChangeCheckBox->Checked)
       rdrConfigFlag = true;

   if (AssignReaderModifyTXCheckBox->Checked ||
       AssignReaderModifyWTCheckBox->Checked ||
       AssignReaderModifyMDCheckBox->Checked)
       rdrConfigTxFlag = true;

   if(networkOn)
   {
      int rdr = atoi(AssignReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(ASSIGN_READER, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(ASSIGN_READER, 0, NULL, 0);
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::QueryReaderBitBtnClick(TObject *Sender)
{
   /*if (!GeneralGroupBox->Visible)   //temp
   {
      GeneralGroupBox->Visible = true;
      ReaderCodeVerGroupBox->Visible = false;
      return;
   }

   GeneralGroupBox->Visible = true;
   ReaderCodeVerGroupBox->Visible = false;*/

   /*if (!QueryReaderRadioButton->Checked)
   {
       //Application->MessageBox("Query Reader Radio Button is NOT checked",
                               //"Programming Station Information Dialog",
                               //MB_OK | MB_ICONSTOP | MB_TOPMOST);

       QueryReaderRadioButton->Checked = true;
       return;
   }*/

   QueryReaderBitBtn->Font->Color = clRed;
   QueryReaderListView->Items->Clear();

   TxClearTagCtrls();
   RxClearTagCtrls();
   ProgammingMode = true;
   programming = false;
   //ClearListView();
   //ReaderIDComboBox->Items->Clear();
   numReaderIDList = 0;
   //ReaderIDComboBox->Text = "";
   //GroupBox16->Caption = "Detected Tags / Readers";

   receivedResponse = false;
   /*if (readerFgenButtonActivated)
   {
      ReaderFgenToolButton->Hint = "Set Programming Station To Field Generator Mode";
      readerFgenButtonActivated = false;
      if(networkOn)
         CloseNetworkConnection();
      else if (RS232On)
         ClosePort();
      EnableAllCommands(false);
      if (OpenSerial(comPort, lastBaudrate))
      {
         ProgStationForm->PortOpen = true;
         baudRate = curBaudrate = lastBaudrate;
         PlaySound("Ding.wav", NULL, SND_ASYNC );
      }
      EnableAllCommands(true);

      readerOffLine = true;
      readerOnLine = false;
      fieldGenOffLine = true;
      fieldGenOnLine = false;
   }*/
   //WriteRS232Comm(QUERY_READER, 0, NULL, 0);
   if(networkOn)
   {
      if (QueryReaderBroadcastRdrCheckBox->State == cbChecked)
         WriteAWSocket(QUERY_READER, 0, "G", 0, 'B', NULL, 0, 0);
      else
      {
         int rdr = atoi(QueryReaderIDComboBox->Text.c_str());
         int index = GetSocketIndex(rdr);
         if (index >= 0)
            WriteAWSocket(QUERY_READER, 0, NULL, 0, 'S', NULL, 0, index);
         else
            StaticText->Caption = "No matching socket for the reader.";
      }
   }
   else if (RS232On)
   {
      WriteRS232Comm(QUERY_READER, 0, NULL, 0);
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::DetectedTagListViewColumnClick(
      TObject *Sender, TListColumn *Column)
{
   columnToSort = Column->Index;
  ((TCustomListView *)Sender)->AlphaSort();

}
//------------------------------------------------------------------------------
AnsiString __fastcall TProgStationForm::GetItem(TStrings* str, int itemNum)
{
   if (itemNum < str->Count)
     return (str->Strings[itemNum]);
   else
     return (" ");
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::DetectedTagListViewCompare(
      TObject *Sender, TListItem *Item1, TListItem *Item2, int Data,
      int &Compare)
{
    int index;
    AnsiString selectedItem1;
    AnsiString selectedItem2;
    AnsiString s;
    TStrings* str;
    int n1, n2;

    //if (columnToSort == 0)
       //Compare = CompareText(Item1->Caption,Item2->Caption);
    //else
    //{
      if (columnToSort == 1)  //FGen
      {
         /*str = Item1->SubItems;
         selectedItem1 = GetItem(str, 0);
         str = Item2->SubItems;
         selectedItem1 = GetItem(str, 0);
         Compare = CompareText(selectedItem1, selectedItem2);*/

         str = Item1->SubItems;
         selectedItem1 = GetItem(str, 0);

         str = Item2->SubItems;
         selectedItem2 = GetItem(str, 0);

         n1 = atoi(selectedItem1.c_str());
         n2 = atoi(selectedItem2.c_str());
         if (n1 == n2)
            Compare = 0;
         else if (n1 > n2)
            Compare = 1;
         else
           Compare = -1;
      }
      else if (columnToSort == 2) //rdr id
      {
         str = Item1->SubItems;
         selectedItem1 = GetItem(str, 1);

         str = Item2->SubItems;
         selectedItem2 = GetItem(str, 1);

         n1 = atoi(selectedItem1.c_str());
         n2 = atoi(selectedItem2.c_str());
         if (n1 == n2)
            Compare = 0;
         else if (n1 > n2)
            Compare = 1;
         else
           Compare = -1;
      }
      else if (columnToSort == 3) //type
      {
         str = Item1->SubItems;
         //s = str->Text;
         //selectedItem1 = s.SubString(1,3);
         selectedItem1 = GetItem(str, 2);
         str = Item2->SubItems;
         //s = str->Text;
         //selectedItem2 = s.SubString(1,3);
         selectedItem2 = GetItem(str, 2);
         Compare = CompareText(selectedItem1, selectedItem2);
      }
      else if (columnToSort == 4) //tag id
      {
         /*str = Item1->SubItems;
         selectedItem1 = GetItem(str, 2);
         str = Item2->SubItems;
         selectedItem2 = GetItem(str, 2);
         Compare = CompareText(selectedItem1, selectedItem2);*/

         str = Item1->SubItems;
         selectedItem1 = GetItem(str, 3);

         str = Item2->SubItems;
         selectedItem2 = GetItem(str, 3);

         n1 = atoi(selectedItem1.c_str());
         n2 = atoi(selectedItem2.c_str());
         if (n1 == n2)
            Compare = 0;
         else if (n1 > n2)
            Compare = 1;
         else
           Compare = -1;
      }
      else if (columnToSort == 5) //RSSI
      {
         str = Item1->SubItems;
         selectedItem1 = GetItem(str, 4);

         str = Item2->SubItems;
         selectedItem2 = GetItem(str, 4);

         n1 = atoi(selectedItem1.c_str());
         n2 = atoi(selectedItem2.c_str());
         if (n1 == n2)
            Compare = 0;
         else if (n1 > n2)
            Compare = 1;
         else
           Compare = -1;
      }
      else if (columnToSort == 6)  //Cmd
      {
         str = Item1->SubItems;
         //s = str->Text;
         //selectedItem1 = s.SubString(1,3);
         selectedItem1 = GetItem(str, 5);
         str = Item2->SubItems;
         //s = str->Text;
         //selectedItem2 = s.SubString(1,3);
         selectedItem2 = GetItem(str, 5);
         Compare = CompareText(selectedItem1, selectedItem2);
      }
      else if (columnToSort == 7)  //dup
      {
         str = Item1->SubItems;
         //s = str->Text;
         //selectedItem1 = s.SubString(1,3);
         selectedItem1 = GetItem(str, 6);
         str = Item2->SubItems;
         //s = str->Text;
         //selectedItem2 = s.SubString(1,3);
         selectedItem2 = GetItem(str, 6);
         Compare = CompareText(selectedItem1, selectedItem2);
      }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::UpdateTagDetectedArray(unsigned short readerID, unsigned short fGenID,
                                                         unsigned int tagID, unsigned short tagType, int configIndex)
{
    if (configIndex > 11)
       configIndex = 11;
    for (int i=0; i<=MAX_TAG_DETECTED; i++)
    {
       if ((tagDetectedArray[i].tagID == tagID) && (tagDetectedArray[i].tagType == tagType))
       {
          tagDetectedArray[i].readerID = readerID;
          tagDetectedArray[i].fGenID = fGenID;

          if ((recvBuf[configIndex] & 0x02) == 0x02)
             tagDetectedArray[i].tamperEnabled = true;  //Tamper switch enabled
          else
            tagDetectedArray[i].tamperEnabled = false;  //Tamper switch disabled

          if ((recvBuf[configIndex] & 0x04) == 0x04) //4.33 field
             tagDetectedArray[i].field = true;   //yes
          else
            tagDetectedArray[i].field = false;   //No

          if ((recvBuf[configIndex] & 0x10) == 0x10)  //tag enable
            tagDetectedArray[i].tagEnabled = true;  //enabled
          else
            tagDetectedArray[i].tagEnabled = false;  //disabled

          tagDetectedArray[i].lastDetectTime = Now();

          return;
       }
    }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::UpdateTagTempArray(unsigned short readerID,
                                                     unsigned int tagID,
                                                     unsigned short tagType,
                                                     int configIndex)
{
    if (configIndex > 11)
       configIndex = 11;
    for (int i=0; i<=MAX_TAG_DETECTED; i++)
    {
       if ((tagTempArray[i].tagID == tagID) && (tagTempArray[i].tagType == tagType))
       {
          tagTempArray[i].readerID = readerID;

          if ((recvBuf[configIndex] & 0x02) == 0x02)
             tagTempArray[i].tamperEnabled = true;  //Tamper switch enabled
          else
            tagTempArray[i].tamperEnabled = false;  //Tamper switch disabled

          if ((recvBuf[configIndex] & 0x10) == 0x10)  //tag enable
            tagTempArray[i].tagEnabled = true;  //enabled
          else
            tagTempArray[i].tagEnabled = false;  //disabled

          tagTempArray[i].lastDetectTime = Now();

          return;
       }
    }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::NewReaderIDCheckBoxClick(TObject *Sender)
{
   if (NewReaderIDCheckBox->State == cbUnchecked)
   {
      NewReaderIDEdit->Text = "";
      NewReaderIDEdit->ReadOnly = true;
      NewReaderIDEdit->Color = clMenu;
   }
   else
   {
      NewReaderIDEdit->Text = "";
      NewReaderIDEdit->ReadOnly = false;
      NewReaderIDEdit->Color = clWhite;
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::NewHostIDCheckBoxClick(TObject *Sender)
{
   if (NewHostIDCheckBox->State == cbUnchecked)
   {
      NewHostIDEdit->Text = "";
      NewHostIDEdit->ReadOnly = true;
      NewHostIDEdit->Color = clMenu;
   }
   else
   {
      NewHostIDEdit->Text = "";
      NewHostIDEdit->ReadOnly = false;
      NewHostIDEdit->Color = clWhite;
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::NewRepeaterIDCheckBoxClick(
      TObject *Sender)
{
   if (NewRepeaterIDCheckBox->State == cbUnchecked)
   {
      NewRepeaterIDEdit->Text = "";
      NewRepeaterIDEdit->ReadOnly = true;
      NewRepeaterIDEdit->Color = clMenu;
   }
   else
   {
      NewRepeaterIDEdit->Text = "";
      NewRepeaterIDEdit->ReadOnly = false;
      NewRepeaterIDEdit->Color = clWhite;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::TagIDEditChange(TObject *Sender)
{
   __int64  n = atof(TagIDEdit->Text.c_str());
   if (n > 0xFFFFFFFF)
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Exceeds max Tag ID 4294967295 (0xFFFFFFFF)",
      ( LPCSTR )"Programming Station Information Dialog",
      MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::TagIDEditExit(TObject *Sender)
{
   __int64  n = atof(TagIDEdit->Text.c_str());
   if (n > 0xFFFFFFFF)
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Exceeds max Tag ID 4294967295 (0xFFFFFFFF)",
      ( LPCSTR )"Programming Station Information Dialog",
      MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
}
//---------------------------------------------------------------------------

/*void __fastcall TProgStationForm::ReaderIDEditChange(TObject *Sender)
{
   int  n = atoi(ReaderIDComboBox->Text.c_str());
   if (n > 0xFFFF)
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Exceeds max Reader ID 65535 (0xFFFF)",
      ( LPCSTR )"Programming Station Information Dialog",
      MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
}*/
//---------------------------------------------------------------------------

/*void __fastcall TProgStationForm::ReaderIDEditExit(TObject *Sender)
{
   int  n = atoi(ReaderIDComboBox->Text.c_str());
   if (n > 0xFFFF)
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Exceeds max Reader ID 65535 (0xFFFF)",
      ( LPCSTR )"Programming Station Information Dialog",
      MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
} */
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::NewReaderIDEditChange(TObject *Sender)
{
   int  n = atoi(NewReaderIDEdit->Text.c_str());
   if (n > 0xFFFF)
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Exceeds max Reader ID 65535 (0xFFFF)",
      ( LPCSTR )"Programming Station Information Dialog",
      MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::NewReaderIDEditExit(TObject *Sender)
{
  (void)Sender;
   int  n = atoi(NewReaderIDEdit->Text.c_str());
   if (n > 0xFFFF)
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Exceeds max Reader ID 65535 (0xFFFF)",
      ( LPCSTR )"Programming Station Information Dialog",
      MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::HostIDEditChange(TObject *Sender)
{
   int  n = atoi(HostIDEdit->Text.c_str());
   if (n > 0xFF)
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Exceeds max Host ID 255 (0xFF)",
      ( LPCSTR )"Programming Station Information Dialog",
      MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::RdrCodeVerHostIDEdit(TObject *Sender)
{
   int  n = atoi(HostIDEdit->Text.c_str());
   if (n > 0xFF)
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Exceeds max Host ID 255 (0xFF)",
      ( LPCSTR )"Programming Station Information Dialog",
      MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::RepeaterIDEditChange(TObject *Sender)
{
   int  n = atoi(RepeaterIDEdit->Text.c_str());
   if (n > 0xFF)
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Exceeds max Repeater ID 255 (0xFF)",
      ( LPCSTR )"Programming Station Information Dialog",
      MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::RepeaterIDEditExit(TObject *Sender)
{
   int  n = atoi(RepeaterIDEdit->Text.c_str());
   if (n > 0xFF)
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Exceeds max Repeater ID 255 (0xFF)",
      ( LPCSTR )"Programming Station Information Dialog",
      MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::FieldGenIDEditChange(TObject *Sender)
{
   int  n = atoi(FieldGenIDEdit->Text.c_str());
   if (n > 0xFF)
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Exceeds max Field Gen. ID 255 (0xFF)",
      ( LPCSTR )"Programming Station Information Dialog",
      MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::FieldGenIDEditExit(TObject *Sender)
{
   int  n = atoi(FieldGenIDEdit->Text.c_str());
   if (n > 0xFF)
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Exceeds max Field Gen. ID 255 (0xFF)",
      ( LPCSTR )"Programming Station Information Dialog",
      MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::NewHostIDEditChange(TObject *Sender)
{
   int  n = atoi(NewHostIDEdit->Text.c_str());
   if (n > 0xFF)
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Exceeds max Host ID 255 (0xFF)",
      ( LPCSTR )"Programming Station Information Dialog",
      MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::NewHostIDEditExit(TObject *Sender)
{
   int  n = atoi(NewHostIDEdit->Text.c_str());
   if (n > 0xFF)
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Exceeds max Host ID 255 (0xFF)",
      ( LPCSTR )"Programming Station Information Dialog",
      MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::NewRepeaterIDEditChange(TObject *Sender)
{
   int  n = atoi(NewRepeaterIDEdit->Text.c_str());
   if (n > 0xFF)
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Exceeds max Repeater ID 255 (0xFF)",
      ( LPCSTR )"Programming Station Information Dialog",
      MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::NewRepeaterIDEditExit(TObject *Sender)
{
   int  n = atoi(NewRepeaterIDEdit->Text.c_str());
   if (n > 0xFF)
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Exceeds max Repeater ID 255 (0xFF)",
      ( LPCSTR )"Programming Station Information Dialog",
      MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::NewListItemCheckBoxClick(TObject *Sender)
{
   if (NewListItemCheckBox->State == cbChecked)
   {
      if (DetectedTagListView->Items->Count == 0)
      {
         NewListItemCheckBox->Checked = false;
         return;
      }

      newListItem = true;
   }
   else
   {
     newListItem = false;
     DetectedTagListView->Font->Color = clGreen;
   }

}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ChinaDemoToolButtonClick(TObject *Sender)
{
   //TChinaDemoForm* chinaDemoDlg = new TChinaDemoForm (this);
   //chinaDemoDlg->ShowModal();
   //delete chinaDemoDlg;

   /*ChinaDemoToolButton->Enabled = false;
   EnableReaderBitBtn->Enabled = false;
   DisableReaderBitBtn->Enabled = false;
   QueryReaderBitBtn->Enabled = false;
   AssignReaderBitBtn->Enabled = false;
   EnableFGenBitBtn->Enabled = false;
   ConfigTagBitBtn->Enabled = false;
   EnableTagBitBtn->Enabled = false;
   DisableTagBitBtn->Enabled = false;
   QueryTagBitBtn->Enabled = false;
   CallTagBitBtn->Enabled = false;

   closeChinaDemo = false;
   chinaDemoDlg = new TChinaDemoForm (this);
   Application->CreateForm(__classid(TChinaDemoForm), &chinaDemoDlg);
   chinaDemoDlg->Update(); // force display of Form5
   chinaDemoDlg->Caption = demoTitle;
   chinaDemoDlg->Show();*/
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::ClearMsgClick(TObject *Sender)
{
   DetectedMsg->Caption = "";
   TamperSWMsg->Caption = "";
}
//------------------------------------------------------------------------------

/*void __fastcall TProgStationForm::ChinaTimer1Timer(TObject *Sender)
{
    ProgStationForm->ChinaTimer1->Interval = timeCheckTags;
    chinaTagIndex = 0;
    //if(relay1On)
       //WriteComm(DISABLE_RELAY, 0, "1", 81);
    ChinaDemoForm->ClearTagStatus();
    //ChinaTimer2->Enabled = true;
} */
//---------------------------------------------------------------------------

/*void __fastcall TProgStationForm::ChinaTimer2Timer(TObject *Sender)
{
   if (chinaTagIndex >= MaxChinaTags)
   {
      chinaTagIndex = 0;
      ChinaTimer2->Enabled = false;
      ChinaDemoForm->UpdateForNoResponse();
      return;
   }
   AccessCtrlRadioButton->Checked = true;
   TagIDRadioButton->Checked = true;
   TagIDEdit->Text = demoTags[chinaTagIndex++][0];
   ChinaDemoCallTag();
}*/
//---------------------------------------------------------------------------
/*void __fastcall TProgStationForm::ChinaDemoCallTag()
{
   TxClearTagCtrls();
   RxClearTagCtrls();
   ProgammingMode = true;

   if (NewListItemCheckBox->Checked == false)
   {
      tagDetectCount = 0;
      accTagCount = 0;
      assTagCount = 0;
      invTagCount = 0;
      carTagCount = 0;
      nDuplicates = 0;
      ReportACCLabel->Caption = "";
      ReportASSLabel->Caption = "";
      ReportINVLabel->Caption = "";
      ReportCARLabel->Caption = "";
      ReportTotalLabel->Caption = "";
      ReportNDupLabel->Caption = "";
      DetectedTagListView->Items->Clear();
      for (int i=0; i<MAX_TAG_DETECTED; i++)
      {
          tagDetectedArray[i].tagID = 0;
          tagDetectedArray[i].tagType = 6;
          tagDetectedArray[i].fGenID = 0xFF;
          tagDetectedArray[i].gID = false;
          tagDetectedArray[i].lastDetectTime = Now();
      }
   }
   //StaticText->Caption = "";
   programming = true;
   progStr = "Please wait. ";
   if (AccessCtrlRadioButton->Checked)
   {
      tagTypeStr = "Access";
      progStr += "Calling Access Tag ";
   }
   else if (AssetCtrlRadioButton->Checked)
   {
      tagTypeStr = "Asset";
      progStr += "Calling Asset Tag ";
   }
   else if (InvetRadioButton->Checked)
   {
      tagTypeStr = "Inventory";
      progStr += "Calling Inventory Tag ";
   }
   else if (CarRadioButton->Checked)
   {
      tagTypeStr = "Car";
      progStr += "Calling Car Tag ";
   }
   else if (AnyTagRadioButton->Checked)
   {
      tagTypeStr = "Any Type";
      progStr += "Calling All Tag Types ";
   }
   else
   {
      progStr += "Calling Tag ";
   }

   //ShowTagsCheckBox->Checked = true;
   StaticText->Caption = progStr;
   WriteComm(CALL_TAG, 0, NULL, 0);
}
*/
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::DisplayQueryReadersInViewList(AnsiString id, AnsiString type,
                                  bool broadcast, bool Enable, bool RSSI)
{
   TListItem* ListItem;

   //for (int i=0; i<numReaderIDList; i++)
   {
      ListItem = QueryReaderListView->Items->Add();
      ListItem->ImageIndex = -1;
      //ListItem->SubItems->Add(readerIDList[i]);
      ListItem->SubItems->Add(id);
      ListItem->SubItems->Add(type);
      if (broadcast)
         ListItem->SubItems->Add("Yes");
      else
         ListItem->SubItems->Add("No");

      if (Enable)
         ListItem->SubItems->Add("Yes");
      else
         ListItem->SubItems->Add("No");

      if (RSSI)
         ListItem->SubItems->Add("Yes");
      else
         ListItem->SubItems->Add("No");
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::DisplayReadersInViewList(AnsiString type, AnsiString id)
{
   if (ResetReaderGroupBox->Visible)
      ResetListView->Items->Clear();
   else if (EnableReaderGroupBox->Visible)
      EnableReaderListView->Items->Clear();
   else if (DisableReaderGroupBox->Visible)
      DisableReaderListView->Items->Clear();
   else //if (AssignReaderGroupBox->Visible)
      AssignReaderListView->Items->Clear();

   TListItem* ListItem;

   for (unsigned int i=0; i<numReaderIDList; i++)
   {
      if (ResetReaderGroupBox->Visible)
         ListItem = ResetListView->Items->Add();
      else if (EnableReaderGroupBox->Visible)
         ListItem = EnableReaderListView->Items->Add();
      else if (DisableReaderGroupBox->Visible)
         ListItem = DisableReaderListView->Items->Add();
      else //if (AssignReaderGroupBox->Visible)
         ListItem = AssignReaderListView->Items->Add();

      ListItem->ImageIndex = -1;
      ListItem->SubItems->Add(readerIDList[i]);

   }
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::ClearListView()
{
   DetectedTagListView->Items->Clear();
   NewListItemCheckBox->Checked = false;
   DetectedTagListView->Font->Color = clGreen;
   newListItem = false;
   nDuplicates = 0;
   DetectedMsg->Caption = "";

   for (int i=0; i<MAX_TAG_DETECTED; i++)
   {
      tagDetectedArray[i].tagID = 0;
      tagDetectedArray[i].tagType = 6;
      tagDetectedArray[i].cmd = 0;
      tagDetectedArray[i].fGenID = 0xFF;
      tagDetectedArray[i].gID = false;
      tagDetectedArray[i].lastDetectTime = Now();
   }

   type1Count = 0;
   type2Count = 0;
   type3Count = 0;
   type4Count = 0;
   type5Count = 0;
   type6Count = 0;
   typeFacCount = 0;
   ReportType1Label->Caption = "";
   ReportType2Label->Caption = "";
   ReportType3Label->Caption = "";
   ReportType4Label->Caption = "";
   ReportType5Label->Caption = "";
   ReportType6Label->Caption = "";
   ReportFACTLabel->Caption = "";
   ReportTotalLabel->Caption = "";
   ReportNDupLabel->Caption = "";
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::ReaderIDComboBoxChange(TObject *Sender)
{
   int  n = atoi(ReaderIDComboBox->Text.c_str());
   if (n > 0xFFFF)
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Exceeds max Reader ID 65535 (0xFFFF)",
      ( LPCSTR )"Programming Station Information Dialog",
      MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ReaderIDComboBoxExit(TObject *Sender)
{
   int  n = atoi(ReaderIDComboBox->Text.c_str());
   if (n > 0xFFFF)
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Exceeds max Reader ID 65535 (0xFFFF)",
      ( LPCSTR )"Programming Station Information Dialog",
      MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::ReaderVersionClick(TObject *Sender)
{
   /*if (!ReaderCodeVerGroupBox->Visible)
   {
      GeneralGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = true;
   }

   DataCodeVerLabel->Caption = "";
   ProgCodeVerLabel->Caption = "";
   HostCodeVerLabel->Caption = "";

   if (PwUpHostAddr <= 0)
      RdrCodeVerHostEdit->Text = "";
   else
      RdrCodeVerHostEdit->Text = PwUpHostAddr;

   RdrCodeVerReaderComboBox->Items->Clear();
   for (int i=0; i<numReaderIDList; i++)
      RdrCodeVerReaderComboBox->Items->Add(readerIDList[i]);

   if (pwUpReaderAddr <= 0)
      RdrCodeVerReaderComboBox->Text = "";
   else
      RdrCodeVerReaderComboBox->Text = pwUpReaderAddr;
   */

   /*if (!ReaderVersionRadioButton->Checked)
   {
       //Application->MessageBox("Reader Version Radio Button is NOT checked",
                               //"Programming Station Information Dialog",
                               //MB_OK | MB_ICONSTOP | MB_TOPMOST);

       ReaderVersionRadioButton->Checked = true;
       return;
   }*/

   ReaderVersion->Font->Color = clRed;

   //DataCodeVerLabel->Caption = "";
   //ProgCodeVerLabel->Caption = "";
   //HostCodeVerLabel->Caption = "";
   RdrCodeVerListView->Items->Clear();

   TxClearTagCtrls();
   RxClearTagCtrls();
   StaticText->Caption = "";
   receivedResponse = false;
   /*if (readerFgenButtonActivated)
   {
      ReaderFgenToolButton->Hint = "Set Programming Station To Field Generator Mode";
      readerFgenButtonActivated = false;
      if(networkOn)
         CloseNetworkConnection();
      else if (RS232On)
         ClosePort();
      EnableAllCommands(false);
      if (OpenSerial(comPort, lastBaudrate))
      {
         ProgStationForm->PortOpen = true;
         baudRate = curBaudrate = lastBaudrate;
         PlaySound("Ding.wav", NULL, SND_ASYNC );
      }
      EnableAllCommands(true);

      readerOffLine = true;
      readerOnLine = false;
      fieldGenOffLine = true;
      fieldGenOnLine = false;
   }*/
   //WriteRS232Comm(READER_CODE_VER, 0, NULL, 0);
   if(networkOn)
   {
      /*int rdr = atoi(RdrCodeVerReaderComboBox->Text.c_str());
      int index = GetIpAddressIndex(rdr);
      if (index >= 0)
      {
         WriteTCPIPComm(READER_CODE_VER, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
      }*/

      int rdr = atoi(RdrCodeVerReaderComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(READER_CODE_VER, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(READER_CODE_VER, 0, NULL, 0);
   }

}
//---------------------------------------------------------------------------



void __fastcall TProgStationForm::TxTimeSecRadioButtonClick(
      TObject *Sender)
{
   TxTimeComboBox->Items->Clear();
   for (int i=1; i<=60; i++)
      TxTimeComboBox->Items->Add(i);
   TxTimeComboBox->Text = "";
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::WaitTimeSecRadioButtonClick(
      TObject *Sender)
{
   WaitTimeComboBox->Items->Clear();
   for (int i=1; i<=60; i++)
      WaitTimeComboBox->Items->Add(i);
   WaitTimeComboBox->Text = "";
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::WaitTimeMinRadioButtonClick(
      TObject *Sender)
{
   WaitTimeComboBox->Items->Clear();
   for (int i=1; i<=60; i++)
      WaitTimeComboBox->Items->Add(i);
   WaitTimeComboBox->Text = "";
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::WaitTimeHourRadioButtonClick(
      TObject *Sender)
{
   WaitTimeComboBox->Items->Clear();
   for (int i=1; i<=24; i++)
      WaitTimeComboBox->Items->Add(i);
   WaitTimeComboBox->Text = "";
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::TxTimeAllRadioButtonClick(
      TObject *Sender)
{
   TxTimeComboBox->Items->Clear();
   TxTimeComboBox->Text = "";
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::WaitTimeAllRadioButtonClick(
      TObject *Sender)
{
   WaitTimeComboBox->Items->Clear();
   WaitTimeComboBox->Text = "";
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ConfigTxTimeBitBtnClick(TObject *Sender)
{
   /*if (!ConfigTxTimeRadioButton->Checked)
   {
       //Application->MessageBox("Configure Reader Transmit Time Radio Button is NOT checked",
                               //"Programming Station Information Dialog",
                               //MB_OK | MB_ICONSTOP | MB_TOPMOST);

       ConfigTxTimeRadioButton->Checked = true;
       return;
   }*/

   ConfigTxTimeBitBtn->Font->Color = clRed;

   TxClearTagCtrls();
   RxClearTagCtrls();
   StaticText->Caption = "";
   receivedResponse = false;
   if (readerFgenButtonActivated)
   {
      ReaderFgenToolButton->Hint = "Set Programming Station To Field Generator Mode";
      readerFgenButtonActivated = false;
      ClosePort();
      EnableAllCommands(false);
      if (OpenSerial(comPort, lastBaudrate))
      {
         ProgStationForm->PortOpen = true;
         baudRate = curBaudrate = lastBaudrate;
         PlaySound("Ding.wav", NULL, SND_ASYNC );
      }
      EnableAllCommands(true);
   }
   WriteRS232Comm(CONFIG_TX_TIME, 0, NULL, 0);
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ConfigTxTimeReaderRadioButtonClick(
      TObject *Sender)
{
   ConfigTxTimeFieldGenIDEdit->ReadOnly = true;
   ConfigTxTimeFieldGenIDEdit->Color = clMenu;
   ConfigTxTimeFieldGenIDEdit->Text = "0";
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ConfigTxTimeFieldGenRadioButtonClick(
      TObject *Sender)
{
   ConfigTxTimeFieldGenIDEdit->ReadOnly = false;
   ConfigTxTimeFieldGenIDEdit->Color = clWhite;
   ConfigTxTimeFieldGenIDEdit->Text = "";
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ConfigFGenBitBtnClick(TObject *Sender)
{
   /*if (!ConfigFGenRadioButton->Checked)
   {
       //Application->MessageBox("Configure Field Generator Radio Button is NOT checked",
                               //"Programming Station Information Dialog",
                               //MB_OK | MB_ICONSTOP | MB_TOPMOST);

       ConfigFGenRadioButton->Checked = true;
       return;
   }*/

   ConfigFGenBitBtn->Font->Color = clRed;

   QueryTagBitBtn->Enabled = false;
   EnableReaderStaticText->Enabled = false;
   DisableReaderStaticText->Enabled = false;
   QueryReaderStaticText->Enabled = false;
   AssignReaderStaticText->Enabled = false;
   ReaderVersionStaticText->Enabled = false;
   ConfigTxTimeStaticText->Enabled = false;
   RelayStaticText->Enabled = false;
   //EnableRdrFGenStaticText->Enabled = false;
   ConfigFGenStaticText->Enabled = false;
   QueryFGenStaticText->Enabled = false;
   FGenResetStaticText->Enabled = false;
   SmartFGenStaticText->Enabled = false;
   ConfigTagStaticText->Enabled = false;
   EnableTagStaticText->Enabled = false;
   DisableTagStaticText->Enabled = false;
   QueryTagStaticText->Enabled = false;
   CallTagStaticText->Enabled = false;
   AssignTagRdrStaticText->Enabled = false;
   ConfigTagRNDStaticText->Enabled = false;
   WriteMemoryStaticText->Enabled = false;
   ReadMemoryStaticText->Enabled = false;
   TagTempStaticText->Enabled = false;
   InputsStaticText->Enabled = false;

   TxClearTagCtrls();
   RxClearTagCtrls();
   StaticText->Caption = "";
   receivedResponse = false;


      /*if (!readerFgenButtonActivated)
      {
         ReaderFgenToolButton->Hint = "Programming Station Is In Field Generator Mode";
         readerFgenButtonActivated = true;
         if(networkOn)
            CloseNetworkConnection();
         else if (RS232On)
            ClosePort();
         lastBaudrate = baudRate;
         baudRate = 9600;
         EnableAllCommands(false);
         if (OpenSerial(comPort, baudRate))
         {
            ProgStationForm->PortOpen = true;
            PlaySound("Ding.wav", NULL, SND_ASYNC );
         }
         EnableAllCommands(true);

         readerOffLine = true;
         readerOnLine = false;
         fieldGenOffLine = true;
         fieldGenOnLine = false;
      }*/

      FGenConfigWaitTimeSecClicked = false;
      FGenConfigWaitTimeMinClicked = false;
      FGenConfigWaitTimeHourClicked = false;

      WriteRS232Comm(CONFIG_FIELD_GEN, 0, NULL, 0);

   /*else   //smart field gen
   {
      receivedResponse = false;
      StaticText->Caption = progStr;
      receivedResponse = false;
      if (readerFgenButtonActivated)
      {
         ReaderFgenToolButton->Hint = "Set Programming Station To Field Generator Mode";
         readerFgenButtonActivated = false;
         if(networkOn)
            CloseNetworkConnection();
         else if (RS232On)
            ClosePort();
         EnableAllCommands(false);
         if (OpenSerial(comPort, lastBaudrate))
         {
            ProgStationForm->PortOpen = true;
            baudRate = curBaudrate = lastBaudrate;
            PlaySound("Ding.wav", NULL, SND_ASYNC );
         }
         EnableAllCommands(true);

         readerOffLine = true;
         readerOnLine = false;
         fieldGenOffLine = true;
         fieldGenOnLine = false;
      }

      if(networkOn)
      {
         int rdr = atoi(FGenConfigSmartFGenReaderIDComboBox->Text.c_str());
         int index = GetSocketIndex(rdr);
         if (index >= 0)
         {
            WriteAWSocket(CONFIG_SMART_FIELD_GEN, 0, NULL, index, 'S', NULL, 0, index);
         }
         else
            StaticText->Caption = "No matching socket for the reader.";
      }
      else if (RS232On)
      {
         WriteRS232Comm(CONFIG_SMART_FIELD_GEN, 0, NULL, 0);
      }
   }  //smart field gen  */
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::FGenConfigTxTimeSecRadioButtonClick(
      TObject *Sender)
{
   FGenConfigTxTimeComboBox->Items->Clear();
   for (int i=1; i<=60; i++)
      FGenConfigTxTimeComboBox->Items->Add(i);
   FGenConfigTxTimeComboBox->Text = "";
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::FGenConfigWaitTimeSecRadioButtonClick(
      TObject *Sender)
{
   /*if (FGenConfigWaitTimeSecClicked)
   {
      FGenConfigWaitTimeSecClicked = false;
      FGenConfigWaitTimeComboBox->Items->Clear();
      for (int i=1; i<=60; i++)
         FGenConfigWaitTimeComboBox->Items->Add(i);
      FGenConfigWaitTimeComboBox->Text = "";
      //FGenConfigWaitTimeTypeLabel->Caption = "";
   }*/

   if (FGenConfigWaitTimeSecClicked)
   {
      //if (FGenConfigWaitTimeCheckBox->Checked)
      {
          FGenConfigWaitTimeComboBox->Enabled = true;

          FGenConfigWaitTimeComboBox->Items->Clear();
          //FGenConfigWaitTimeComboBox->Text = "";


          for (int i=0; i<=60; i++)
             FGenConfigWaitTimeComboBox->Items->Add(i);

          if (atoi(FGenConfigWaitTimeComboBox->Text.c_str()) > 60)
             FGenConfigWaitTimeComboBox->Text = "";

          FGenConfigWaitTimeLabel->Caption = "sec";

      }

      /*if (FGenConfigHoldTimeCheckBox->Checked)
      {
          FGenConfigHoldTimeComboBox->Items->Clear();
          //FGenConfigWaitTimeComboBox->Text = "";
          for (int i=0; i<=60; i++)
            FGenConfigHoldTimeComboBox->Items->Add(i);

          if (atoi(FGenConfigHoldTimeComboBox->Text.c_str()) > 60)
            FGenConfigHoldTimeComboBox->Text = "";

          //FGenConfigHoldTimeLabel->Caption = "sec";
          FGenConfigWaitTimeLabel->Caption = "sec";
      } */
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::FGenConfigWaitTimeMinRadioButtonClick(
      TObject *Sender)
{
   /*if (FGenConfigWaitTimeMinClicked)
   {
      FGenConfigWaitTimeMinClicked = false;
      FGenConfigWaitTimeComboBox->Items->Clear();
      for (int i=0; i<=60; i++)
         FGenConfigWaitTimeComboBox->Items->Add(i);
      FGenConfigWaitTimeComboBox->Text = "";
      //FGenConfigWaitTimeTypeLabel->Caption = "";
   }*/

   if (FGenConfigWaitTimeMinClicked)
   {
      //if (FGenConfigWaitTimeCheckBox->Checked)
      {
          FGenConfigWaitTimeComboBox->Items->Clear();
          //FGenConfigWaitTimeComboBox->Text = "";
          for (int i=0; i<=60; i++)
            FGenConfigWaitTimeComboBox->Items->Add(i);

          if (atoi(FGenConfigWaitTimeComboBox->Text.c_str()) > 60)
             FGenConfigWaitTimeComboBox->Text = "";

          FGenConfigWaitTimeLabel->Caption = "min";

      }
      /*else if (FGenConfigHoldTimeCheckBox->Checked)
      {
          FGenConfigHoldTimeComboBox->Items->Clear();
          //FGenConfigWaitTimeComboBox->Text = "";
          for (int i=0; i<=60; i++)
            FGenConfigHoldTimeComboBox->Items->Add(i);

          if (atoi(FGenConfigHoldTimeComboBox->Text.c_str()) > 60)
             FGenConfigHoldTimeComboBox->Text = "";

          FGenConfigHoldTimeLabel->Caption = "min";
      }*/
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::FGenConfigWaitTimeHourRadioButtonClick(
      TObject *Sender)
{
   /*if (FGenConfigWaitTimeHourClicked)
   {
      FGenConfigWaitTimeHourClicked = false;
      FGenConfigWaitTimeComboBox->Items->Clear();
      for (int i=0; i<=24; i++)
         FGenConfigWaitTimeComboBox->Items->Add(i);
      FGenConfigWaitTimeComboBox->Text = "";
      //FGenConfigWaitTimeTypeLabel->Caption = "";
   }*/

   if (FGenConfigWaitTimeHourClicked)
   {
      //if (FGenConfigWaitTimeCheckBox->Checked)
      {
          FGenConfigWaitTimeComboBox->Items->Clear();
          //FGenConfigWaitTimeComboBox->Text = "";
         for (int i=0; i<=24; i++)
            FGenConfigWaitTimeComboBox->Items->Add(i);

         if (atoi(FGenConfigWaitTimeComboBox->Text.c_str()) > 24)
            FGenConfigWaitTimeComboBox->Text = "";

         FGenConfigWaitTimeLabel->Caption = "hour";
      }
      /*else if (FGenConfigHoldTimeCheckBox->Checked)
      {
          FGenConfigHoldTimeComboBox->Items->Clear();
          //FGenConfigWaitTimeComboBox->Text = "";
         for (int i=0; i<=24; i++)
            FGenConfigHoldTimeComboBox->Items->Add(i);

         if (atoi(FGenConfigHoldTimeComboBox->Text.c_str()) > 24)
            FGenConfigHoldTimeComboBox->Text = "";

         FGenConfigHoldTimeLabel->Caption = "hour";
      }*/
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::QueryFGenFgRadioButtonClick(
      TObject *Sender)
{
   QueryFGenSmartFGenRdrIDComboBox->Enabled = false;
   QueryFGenSmartFGenIDComboBox->Visible = false;
   QueryFGenRdrIDLabel->Enabled = false;
   QueryFGenIDEdit->Visible = true;
   QueryFGenSmartFGenBroadcastCheckBox->Enabled = false;
   QueryFGenSmartFGenBroadcastRdrCheckBox->Enabled = false;
   GetProcRevDateBitBtn->Enabled = false;
   QueryFGenStaticText->Caption = "Query FGen";
   QueryFGenBitBtn->Caption = "Query FGen";
   QueryFGenGroupBox->Caption = "Query Field Generator";
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::QueryFGenRdrRadioButtonClick(
      TObject *Sender)
{
   if (QueryFGenSmartFGenBroadcastRdrCheckBox->Checked)
   {
      QueryFGenIDEdit->Enabled = false;
      QueryFGenIDEdit->Text = "";
      QueryFGenSmartFGenRdrIDComboBox->Enabled = false;
      QueryFGenSmartFGenRdrIDComboBox->Color = clMenu;
      QueryFGenSmartFGenRdrIDComboBox->Text = "";
   }
   else
   {
      QueryFGenIDEdit->Enabled = false;
      QueryFGenIDEdit->Text = 0;
      QueryFGenSmartFGenRdrIDComboBox->Enabled = true;
      QueryFGenSmartFGenRdrIDComboBox->Color = clWhite;

      if (pwUpReaderAddr <= 0)
         QueryFGenSmartFGenRdrIDComboBox->Text = "";
      else
         QueryFGenSmartFGenRdrIDComboBox->Text = pwUpReaderAddr;
   }

   QueryFGenGroupBox->Caption = "Query Field Generator";
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::QueryFGenSmartFGRadioButtonClick(
      TObject *Sender)
{
   QueryFGenSmartFGenRdrIDComboBox->Enabled = true;
   QueryFGenSmartFGenIDComboBox->Visible = true;
   QueryFGenRdrIDLabel->Enabled = true;
   QueryFGenIDEdit->Visible = false;
   QueryFGenSmartFGenBroadcastCheckBox->Enabled = true;
   //QueryFGenSmartFGenBroadcastRdrCheckBox->Enabled = true;
   GetProcRevDateBitBtn->Enabled = true;

   QueryFGenStaticText->Caption = "Query Smart FGen";
   QueryFGenBitBtn->Caption = "Query Smart FGen";

   /*if (QueryFGenBroadcastCheckBox->Checked)
   {
      QueryFGenIDEdit->Enabled = false;
      QueryFGenIDEdit->Text = "";
      QueryFGenReaderIDComboBox->Enabled = false;
      QueryFGenReaderIDComboBox->Color = clMenu;
      QueryFGenReaderIDComboBox->Text = "";
   }
   else
   {
      QueryFGenIDEdit->Enabled = true;
      QueryFGenIDEdit->Text = "";
      QueryFGenReaderIDComboBox->Enabled = true;
      QueryFGenReaderIDComboBox->Color = clWhite;

      if (pwUpReaderAddr <= 0)
         QueryFGenReaderIDComboBox->Text = "";
      else
         QueryFGenReaderIDComboBox->Text = pwUpReaderAddr;
   }*/

   QueryFGenGroupBox->Caption = "Query Smart Field Generator";
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::QueryFGenBitBtnClick(TObject *Sender)
{
   QueryFGenBitBtn->Font->Color = clRed;
   if (!QueryFGenCheckBox->Checked)
      QueryFGenListView->Items->Clear();

   TxClearTagCtrls();
   RxClearTagCtrls();
   //QueryFGenListView->Items->Clear();
   StaticText->Caption = "";
   receivedResponse = false;


   /*ReaderFgenToolButton->Hint = "Programming Station Is In Field Generator Mode";
   readerFgenButtonActivated = true;
   if(networkOn)
      CloseNetworkConnection();
   else if (RS232On)
      ClosePort();
   lastBaudrate = baudRate;
   baudRate = 9600;
   EnableAllCommands(false);
   if (OpenSerial(comPort, baudRate))
   {
            ProgStationForm->PortOpen = true;
            PlaySound("Ding.wav", NULL, SND_ASYNC );
   }
   EnableAllCommands(true);

   readerOffLine = true;
   readerOnLine = false;
   fieldGenOffLine = true;
   fieldGenOnLine = false;  */

   WriteRS232Comm(QUERY_FIELD_GEN, 0, NULL, 0);
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::QueryFGenSmartFGenBroadcastRdrCheckBoxClick(
      TObject *Sender)
{
   if (QuerySFGenSmartFGenBroadcastRdrCheckBox->Checked)
   {
       QueryFGenSmartFGenRdrIDComboBox->Enabled = false;
       QueryFGenSmartFGenRdrIDComboBox->Color = clMenu;
   }
   else
   {
      QueryFGenSmartFGenRdrIDComboBox->Enabled = true;
       QueryFGenSmartFGenRdrIDComboBox->Color = clWhite;
   }

   /*if (QueryFGenSmartFGenBroadcastRdrCheckBox->State == cbChecked)
   {
      QueryFGenIDEdit->ReadOnly = true;
      QueryFGenIDEdit->Color = clMenu;
      if ((QueryFGenFgRadioButton->Checked) || (QueryFGenSmartFGRadioButton->Checked))
      {
         QueryFGenSmartFGenRdrIDComboBox->Enabled = false;
         QueryFGenRdrIDLabel->Enabled = false;
         //QueryFGenReaderIDComboBox->Color = clMenu;
         //QueryFGenReaderIDComboBox->Text = "";
      }
      else
      {
         QueryFGenSmartFGenRdrIDComboBox->Enabled = true;
         QueryFGenRdrIDLabel->Enabled = true;
         //QueryFGenReaderIDComboBox->Color = clWhite;
         if (pwUpReaderAddr <= 0)
            QueryFGenSmartFGenRdrIDComboBox->Text = "";
         else
            QueryFGenSmartFGenRdrIDComboBox->Text = pwUpReaderAddr;
      }
   }
   else
   {
      if (!QueryFGenFgRadioButton->Checked)
      {
         QueryFGenSmartFGenRdrIDComboBox->Enabled = true;
         QueryFGenRdrIDLabel->Enabled = true;
         //QueryFGenReaderIDComboBox->Color = clWhite;
         if (pwUpReaderAddr <= 0)
            QueryFGenSmartFGenRdrIDComboBox->Text = "";
         else
            QueryFGenSmartFGenRdrIDComboBox->Text = pwUpReaderAddr;
      }

      QueryFGenIDEdit->ReadOnly = false;
      QueryFGenIDEdit->Color = clWhite;


      if (QueryFGenFgRadioButton->Checked)
      {
         QueryFGenIDEdit->ReadOnly = false;
         QueryFGenIDEdit->Color = clWhite;
      }
      else
      {

         if (QueryFGenRdrRadioButton->Checked)
         {
             QueryFGenIDEdit->Text = "0";
             QueryFGenIDEdit->ReadOnly = true;
             QueryFGenIDEdit->Color = clWhite;
         }
         else
         {
            QueryFGenIDEdit->ReadOnly = false;
            QueryFGenIDEdit->Color = clWhite;
            QueryFGenIDEdit->Text = "";
         }

         QueryFGenSmartFGenRdrIDComboBox->Enabled = true;
         QueryFGenRdrIDLabel->Enabled = true;
         //QueryFGenReaderIDComboBox->Color = clWhite;
         if (pwUpReaderAddr <= 0)
            QueryFGenSmartFGenRdrIDComboBox->Text = "";
         else
            QueryFGenSmartFGenRdrIDComboBox->Text = pwUpReaderAddr;

      }
   }*/
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::DisplayConfigRdrListView(int rID, int hID, int tTime, int wType, int wTime, bool mdEnable, bool high, int dpot)
{
    AnsiString str;
    TListItem* ListItem;

    ListItem = AssignReaderListView->Items->Add();
    ListItem->ImageIndex = -1;

    str = rID;
    ListItem->SubItems->Add(str);
    AssignReaderIDComboBox->Text = rID;

    str = hID;
    ListItem->SubItems->Add(str);
    AssignReaderHostIDEdit->Text = hID;

    str = (tTime & 0x3F);
    if (str == "0")
    {
       str = "Forever";
       if (DebugDisplayToolButton->Visible || TextDisplayToolButton->Visible)
          AssignReaderTXComboBox->Text = str;
       else
          AssignReaderTXComboBox->Text = "";
    }
    else
      AssignReaderTXComboBox->Text = str;

    if ((tTime & 0x3F) > 0)
       str += " s";
    ListItem->SubItems->Add(str);    //transmit time

    AnsiString s = AssignReaderTypeComboBox->Text;
    bool bFGen = false;
    if (s.data() == NULL) {
       s = " ";
    } else {
       if ((s == "FGen Reader") ||
           (s == "SaniFaucet Door Unit") ||
           (s == "SaniFaucet Sanitization Unit") ||
           (s == "SaniFaucet Contamination Unit") ||
           (s == "SaniFaucet Bed Unit") ||
           (s == "Query FGen Reader")) {
            bFGen = true;
       }
    }

    if (bFGen)
    {
       str = wTime;
       AssignReaderWTComboBox->Text = str;
       if ((wType == 0) && (wTime > 0))
       {
          str += " s";
          AssignReaderWTSecRadioButton->Checked = true;
       }
       else if ((wType == 1) && (wTime > 0))
       {
          str += " m";
          AssignReaderWTMinRadioButton->Checked = true;
       }
       else if ((wType == 2) && (wTime > 0))
       {
          str += " h";
          AssignReaderWTHourRadioButton->Checked = true;
       }
       else
          str = "All time";
       ListItem->SubItems->Add(str);     //wait time
    }
    else
       ListItem->SubItems->Add(" -- ");     //wait time

    if (dpot >= 0)
       str = dpot;
    else
       str = " ";
    ListItem->SubItems->Add(str);     //Field Strength

    if (bFGen)
    {
       if (mdEnable)
       {
       ListItem->SubItems->Add("Enable");
       AssignReaderEnableMDCheckBox->Checked = true;
       }
       else
       {
       ListItem->SubItems->Add("Disable");
       AssignReaderEnableMDCheckBox->Checked = false;
       }
    }
    else
    {
       ListItem->SubItems->Add(" -- ");
       //AssignReaderEnableMDCheckBox->Checked = false;
    }

    if (bFGen)
    {
       if (high)
       {
       ListItem->SubItems->Add("High");
       AssignReaderMDActiveHiRadioButton->Checked = true;
       AssignReaderMDActiveLoRadioButton->Checked = false;
       }
       else
       {
       ListItem->SubItems->Add("Low");
       AssignReaderMDActiveHiRadioButton->Checked = false;
       AssignReaderMDActiveLoRadioButton->Checked = true;
       }
    }
    else
    {
       ListItem->SubItems->Add(" -- ");
       //AssignReaderMDActiveHiRadioButton->Checked = false;
       //AssignReaderMDActiveLoRadioButton->Checked = false;
    }

    ListItem->SubItems->Add(s);  //reader type
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::DisplayQueryFGenListView(int ID, int tType, int tTime, int wType, int wTime, int rdrID, AnsiString tagType, AnsiString tagID, bool PIR, bool high, int hTime, int motionSens)
{
    AnsiString str;
    TListItem* ListItem;

    ListItem = QueryFGenListView->Items->Add();
    ListItem->ImageIndex = -1;

    str = ID;   //Fgen ID
    ListItem->SubItems->Add(str);

    str = rdrID;     //reader ID
    ListItem->SubItems->Add(str);

    str = (tTime & 0x3F);
    str += " sec";
    ListItem->SubItems->Add(str);    //transmit time

    str = wTime;
    if (wType == 0)
       str += " sec";
    else if (wType == 1)
       str += " min";
    else if (wType == 2)
       str += " hour";
    else
       str = "All time";
    ListItem->SubItems->Add(str);  //wait time

    str = hTime;

    if (hTime < 0)
        ListItem->SubItems->Add("--");  //hold time
    else
        ListItem->SubItems->Add(str + " sec");

    //Motion Detector Enable/Disable
    //unsigned char ch = (unsigned char)tTime;
    //if ((ch & 0x40) == 0x40)  //0x00 0000   //PIR enable/disable
    if (PIR)
       ListItem->SubItems->Add("Enable");
    else
       ListItem->SubItems->Add("Disable");

    //Motion Detector Status
    //if ((ch& 0x80) == 0x80)  //x000 0000   //PIR enable/disable
    if (high)
       ListItem->SubItems->Add("Active High");
    else
       ListItem->SubItems->Add("Active Low");

    //ListItem->SubItems->Add("-----");  //FS

    //Tag Type
    /*ch = (unsigned char)tType;
    if ((ch & 0xE0) == 0x20)  //access
       ListItem->SubItems->Add("ACC");
    else if ((ch & 0xE0) == 0x40)  //inventory
       ListItem->SubItems->Add("INV");
    else if ((ch & 0xE0) == 0x60)  //asset
       ListItem->SubItems->Add("AST");*/

    //motion sensor
    if (motionSens < 0)
       ListItem->SubItems->Add("----");
    else if(motionSens == 0)
       ListItem->SubItems->Add("Disabled");
    else if (motionSens > 0)
       ListItem->SubItems->Add("Enabled");

    //Tag Type
    ListItem->SubItems->Add(tagType);   //tag Type

    ListItem->SubItems->Add(tagID);     //tag ID

}
void __fastcall TProgStationForm::QueryFGenClearBitBtnClick(
      TObject *Sender)
{
   QueryFGenListView->Items->Clear();
   numFgenIDList = 0;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::QueryFGenListViewColumnClick(
      TObject *Sender, TListColumn *Column)
{
   columnToSort = Column->Index;
  ((TCustomListView *)Sender)->AlphaSort();
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::QueryFGenListViewCompare(TObject *Sender,
      TListItem *Item1, TListItem *Item2, int Data, int &Compare)
{
   AnsiString selectedItem1;
   AnsiString selectedItem2;
   TStrings* str;
   int n1, n2;

   if (columnToSort == 1)
   {
      str = Item1->SubItems;
      selectedItem1 = GetItem(str, 0);

      str = Item2->SubItems;
      selectedItem2 = GetItem(str, 0);

      n1 = atoi(selectedItem1.c_str());
      n2 = atoi(selectedItem2.c_str());
      if (n1 == n2)
         Compare = 0;
      else if (n1 > n2)
         Compare = 1;
      else
         Compare = -1;
   }
   else if (columnToSort == 2)
   {
      str = Item1->SubItems;
      selectedItem1 = GetItem(str, 1);

      str = Item2->SubItems;
      selectedItem2 = GetItem(str, 1);

      n1 = atoi(selectedItem1.c_str());
      n2 = atoi(selectedItem2.c_str());
      if (n1 == n2)
         Compare = 0;
      else if (n1 > n2)
         Compare = 1;
      else
         Compare = -1;
   }
   else if (columnToSort == 3)
   {
      str = Item1->SubItems;
      selectedItem1 = GetItem(str, 2);

      str = Item2->SubItems;
      selectedItem2 = GetItem(str, 2);

      n1 = atoi(selectedItem1.c_str());
      n2 = atoi(selectedItem2.c_str());
      if (n1 == n2)
         Compare = 0;
      else if (n1 > n2)
         Compare = 1;
      else
         Compare = -1;
   }
   else if (columnToSort == 4)
   {
      str = Item1->SubItems;
      selectedItem1 = GetItem(str, 3);

      str = Item2->SubItems;
      selectedItem2 = GetItem(str, 3);

      n1 = atoi(selectedItem1.c_str());
      n2 = atoi(selectedItem2.c_str());
      if (n1 == n2)
         Compare = 0;
      else if (n1 > n2)
         Compare = 1;
      else
         Compare = -1;
   }
   else
      Compare = 0;

}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::AssignTagRdrBitBtnClick(TObject *Sender)
{
   /*if (!AssignTagRdrRadioButton->Checked)
   {
       //Application->MessageBox("Configure Field Generator Radio Button is NOT checked",
                               //"Programming Station Information Dialog",
                               //MB_OK | MB_ICONSTOP | MB_TOPMOST);

       AssignTagRdrRadioButton->Checked = true;
       return;
   }*/

   AssignTagRdrBitBtn->Font->Color = clRed;

   if (!NewListItemCheckBox->Checked)
   {
      TxClearTagCtrls();
      RxClearTagCtrls();
      ProgammingMode = true;
      StaticText->Caption = "";
      DetectedMsg->Caption = "";
      TamperSWMsg->Caption = "";
      TagDetectedGroupBox->Caption = "Detected Tags";
      tagDetectCount = 0;
      type1Count = 0;
      type2Count = 0;
      type3Count = 0;
      type4Count = 0;
      type5Count = 0;
      type6Count = 0;
      typeFacCount = 0;
      ReportType1Label->Caption = "";
      ReportType2Label->Caption = "";
      ReportType3Label->Caption = "";
      ReportType4Label->Caption = "";
      ReportType5Label->Caption = "";
      ReportType6Label->Caption = "";
      ReportFACTLabel->Caption = "";
      ReportTotalLabel->Caption = "";
      ReportNDupLabel->Caption = "";
      DetectedTagListView->Items->Clear();
      for (int i=0; i<MAX_TAG_DETECTED; i++)
      {
          tagDetectedArray[i].tagID = 0;
          tagDetectedArray[i].tagType = 6;
          tagDetectedArray[i].cmd = 0;
          tagDetectedArray[i].fGenID = 0xFF;
          tagDetectedArray[i].gID = false;
          tagDetectedArray[i].lastDetectTime = Now();
      }
   }
   //StaticText->Caption = "";
   programming = true;
   progStr = "Please wait. ";

   tagTypeStr = AssignTagRdrTagTypeComboBox->Text;
   progStr += "Assigning Reader to ";
   progStr += AssignTagRdrTagTypeComboBox->Text;
   progStr += " Tag";

   TxClearTagCtrls();
   RxClearTagCtrls();

   for (int i=0; i<MAX_TAG; i++)
   {
      tagArray[i].tagID = 0;
      tagArray[i].tagType = 0;
   }
   arrayIndex = 0;
   AssignTagRdrListView->Items->Clear();

   if ((AssignTagRdrTagIDRangeRadioButton->Checked) && (AssignTagRdrTagIDEdit->Text.data() == NULL))
   {
       Application->MessageBox("Error: Need Tag ID",
                               "Programming Station Information Dialog",
                               MB_OK | MB_ICONSTOP | MB_TOPMOST);
       AssignTagRdrBitBtn->Enabled = true;
       return;
   }

   if ((AssignTagRdrTagTypeComboBox->Text == "All Types") && (AssignTagRdrAnyTagIDRadioButton->Checked))
    {
        int ret = Application->MessageBox ("Do you want to Assign Reader To ALL tags?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "All Tags";
        progStr = "Please wait. Assigning Reader To All Tags";
    }
    else if ((AssignTagRdrTagTypeComboBox->Text == "All Types"))
    {
       int ret = Application->MessageBox ("Do you want to Assign Reader To Any Tag Type?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "All Types";
        progStr = "Please wait. Assigning Reader To All Tag Types";
    }
    else if (AssignTagRdrAnyTagIDRadioButton->Checked)
    {
       int ret = Application->MessageBox ("Do you want to Assign Reader To Any Tag ID?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        progStr = "Please wait. Assigning Reader To Any Tag ID";
    }
    else
       progStr = "Please wait, assigning tag reader. ";

   StaticText->Caption = progStr;

   /*if (readerFgenButtonActivated)
   {
      ReaderFgenToolButton->Hint = "Set Programming Station To Field Generator Mode";
      readerFgenButtonActivated = false;
      if(networkOn)
         CloseNetworkConnection();
      else if (RS232On)
         ClosePort();
      EnableAllCommands(false);
      if (OpenSerial(comPort, lastBaudrate))
      {
         ProgStationForm->PortOpen = true;
         baudRate = curBaudrate = lastBaudrate;
         PlaySound("Ding.wav", NULL, SND_ASYNC );
      }
      EnableAllCommands(true);

      readerOffLine = true;
      readerOnLine = false;
      fieldGenOffLine = true;
      fieldGenOnLine = false;
   }*/

   DisableTagStaticCommands();
   CMDEnableTimer->Enabled = true;
   AssignTagRdrBitBtn->Enabled = false;

   if(networkOn)
   {
      /*int rdr = atoi(AssignTagRdrRdrIDComboBox->Text.c_str());
      int index = GetIpAddressIndex(rdr);
      if (index >= 0)
      {
         WriteTCPIPComm(DEFINE_TAG_READER, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
      }*/

      int rdr = atoi(AssignTagRdrRdrIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(DEFINE_TAG_READER, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(DEFINE_TAG_READER, 0, NULL, 0);
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::AssignTagRdrClearBitBtnClick(
      TObject *Sender)
{
   AssignTagRdrListView->Items->Clear();
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::AssignTagRdrBroadcastRdrCheckBoxClick(
      TObject *Sender)
{
   if (AssignTagRdrBroadcastRdrCheckBox->State == cbUnchecked)
   {
      AssignTagRdrRdrIDComboBox->Enabled = true;
      AssignTagRdrRdrIDComboBox->Color = clWhite;
   }
   else
   {
      AssignTagRdrRdrIDComboBox->Enabled = false;
      AssignTagRdrRdrIDComboBox->Color = clMenu;
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ConfigTagRNDRadioButtonClick(
      TObject *Sender)
{
   if (!ConfigTagRandGroupBox->Visible)
   {
      ConfigTagRandGroupBox->Visible = true;
      AssignTagReaderGroupBox->Visible = false;
      GeneralGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
   }

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clGreen;
   EnableTagBitBtn->Font->Color = clGreen;
   DisableTagBitBtn->Font->Color = clGreen;
   QueryTagBitBtn->Font->Color = clGreen;
   CallTagBitBtn->Font->Color = clGreen;
   AssignTagRdrBitBtn->Font->Color = clGreen;
   ConfigTagRNDBitBtn->Font->Color = clRed;

   if (PwUpHostAddr <= 0)
      ConfigTagRNDHostIDEdit->Text = "";
   else
      ConfigTagRNDHostIDEdit->Text = PwUpHostAddr;

   if (pwUpReaderAddr <= 0)
      ConfigTagRNDRdrIDComboBox->Text = "";
   else
      ConfigTagRNDRdrIDComboBox->Text = pwUpReaderAddr;

   ConfigTagRNDRdrIDComboBox->Items->Clear();
   for (unsigned int i=0; i<numReaderIDList; i++)
      ConfigTagRNDRdrIDComboBox->Items->Add(readerIDList[i]);

   //Reset Device  0x01
   TxClearTagCtrls();
   RxClearTagCtrls();
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagRNDBitBtnClick(TObject *Sender)
{
   /*if (!ConfigTagRNDRadioButton->Checked)
   {
       //Application->MessageBox("Configure Field Generator Radio Button is NOT checked",
                               //"Programming Station Information Dialog",
                               //MB_OK | MB_ICONSTOP | MB_TOPMOST);

       ConfigTagRNDRadioButton->Checked = true;
       return;
   }*/

   ConfigTagRNDBitBtn->Font->Color = clRed;

   if (!NewListItemCheckBox->Checked)
   {
      TxClearTagCtrls();
      RxClearTagCtrls();
      ProgammingMode = true;
      StaticText->Caption = "";
      DetectedMsg->Caption = "";
      TamperSWMsg->Caption = "";
      TagDetectedGroupBox->Caption = "Detected Tags";
      tagDetectCount = 0;
      type1Count = 0;
      type2Count = 0;
      type3Count = 0;
      type4Count = 0;
      type5Count = 0;
      type6Count = 0;
      typeFacCount = 0;
      ReportType1Label->Caption = "";
      ReportType2Label->Caption = "";
      ReportType3Label->Caption = "";
      ReportType4Label->Caption = "";
      ReportType5Label->Caption = "";
      ReportType6Label->Caption = "";
      ReportFACTLabel->Caption = "";
      ReportTotalLabel->Caption = "";
      ReportNDupLabel->Caption = "";
      DetectedTagListView->Items->Clear();
      for (int i=0; i<MAX_TAG_DETECTED; i++)
      {
          tagDetectedArray[i].tagID = 0;
          tagDetectedArray[i].tagType = 6;
          tagDetectedArray[i].cmd = 0;
          tagDetectedArray[i].fGenID = 0xFF;
          tagDetectedArray[i].gID = false;
          tagDetectedArray[i].lastDetectTime = Now();
      }
   }
   //StaticText->Caption = "";
   programming = true;
   progStr = "Please wait. ";

   tagTypeStr = AssignTagRdrTagTypeComboBox->Text;
   progStr += "Configuring Tag RND for ";
   progStr += AssignTagRdrTagTypeComboBox->Text;
   progStr += " Tag";


   TxClearTagCtrls();
   RxClearTagCtrls();

   for (int i=0; i<MAX_TAG; i++)
   {
      tagArray[i].tagID = 0;
      tagArray[i].tagType = 0;
   }
   arrayIndex = 0;
   ConfigTagRNDListView->Items->Clear();

   if ((ConfigTagRNDTagIDRangeRadioButton->Checked) && (ConfigTagRNDTagIDEdit->Text.data() == NULL))
   {
       Application->MessageBox("Error: Need Tag ID",
                               "Programming Station Information Dialog",
                               MB_OK | MB_ICONSTOP | MB_TOPMOST);
       ConfigTagRNDBitBtn->Enabled = true;
       return;
   }

   if ((ConfigTagRNDTagTypeComboBox->Text == "All Types") && (ConfigTagRNDAnyTagIDRadioButton->Checked))
    {
        int ret = Application->MessageBox ("Do you want to Configure ALL tags?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "All Tags";
        progStr = "Please wait. Configuring All Tags RND Time";
    }
    else if (ConfigTagRNDTagTypeComboBox->Text == "All Types")
    {
       int ret = Application->MessageBox ("Do you want to Configure Any Tag Type?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "Any Type";
        progStr = "Please wait. Configuring all Tag Types RND Time";
    }
    else if (ConfigTagRNDAnyTagIDRadioButton->Checked)
    {
       int ret = Application->MessageBox ("Do you want to Configure Any Tag ID?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        progStr = "Please wait. Configuring Any Tag ID RND Time";
    }
    else
      progStr = "Please wait, configuraing Tag RND Time. ";

    StaticText->Caption = progStr;

   DisableTagStaticCommands();
   CMDEnableTimer->Enabled = true;
   ConfigTagRNDBitBtn->Enabled = false;

   if(networkOn)
   {
      /*int rdr = atoi(ConfigTagRNDRdrIDComboBox->Text.c_str());
      int index = GetIpAddressIndex(rdr);
      if (index >= 0)
      {
         WriteTCPIPComm(CONFIG_TAG_RND, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
      }*/

      int rdr = atoi(ConfigTagRNDRdrIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(CONFIG_TAG_RND, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(CONFIG_TAG_RND, 0, NULL, 0);
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagRNDClearBitBtnClick(
      TObject *Sender)
{
   ConfigTagRNDListView->Items->Clear();
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagRNDBroadcastCheckBoxClick(
      TObject *Sender)
{
   if (ConfigTagRNDBroadcastCheckBox->State == cbUnchecked)
   {
      ConfigTagRNDRdrIDComboBox->Enabled = true;
      ConfigTagRNDRdrIDComboBox->Color = clWhite;
   }
   else
   {
      ConfigTagRNDRdrIDComboBox->Enabled = false;
      ConfigTagRNDRdrIDComboBox->Color = clMenu;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ResetReaderStaticTextClick(
      TObject *Sender)
{
   if (!ResetReaderGroupBox->Visible)
   {
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = true;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = false;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = true;
   DownloadRdrStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = true;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = false;
   DownloadRdrBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   FGenResetBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Enabled = true;
   EnableReaderBitBtn->Enabled = true;
   DisableReaderBitBtn->Enabled = true;
   QueryReaderBitBtn->Enabled = true;
   AssignReaderBitBtn->Enabled = true;
   ReaderVersion->Enabled = true;
   //EnableFGenBitBtn->Enabled = true;
   DownloadRdrBitBtn->Enabled = true;
   ConfigTxTimeBitBtn->Enabled = true;
   ConfigFGenBitBtn->Enabled = true;
   QueryFGenBitBtn->Enabled = true;
   FGenResetBitBtn->Enabled = true;
   SmartFGenBitBtn->Enabled = true;
   RelayBitBtn->Enabled = true;
   ConfigTagBitBtn->Enabled = true;
   EnableTagBitBtn->Enabled = true;
   DisableTagBitBtn->Enabled = true;
   QueryTagBitBtn->Enabled = true;
   CallTagBitBtn->Enabled = true;
   AssignTagRdrBitBtn->Enabled = true;
   ConfigTagRNDBitBtn->Enabled = true;
   WriteMemoryBitBtn->Enabled = true;
   ReadMemoryBitBtn->Enabled = true;
   TagTempBitBtn->Enabled = true;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   DownloadRdrBitBtn->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   ResetListView->Items->Clear();
   if (lastReaderID > 0)
      ResetReaderIDComboBox->Text = lastReaderID;
   for (unsigned int i=0; i<numReaderIDList; i++)
   {
      if (ResetReaderIDComboBox->Items->IndexOf(readerIDList[i]) == -1 )
         ResetReaderIDComboBox->Items->Add(readerIDList[i]);
   }

   if (allHostID)
   {
      if (lastHostID > 0)
         ResetHostIDEdit->Text = lastHostID;
   }
   else
      ResetHostIDEdit->Text = sysHostID;

   //Reset Device  0x01
   TxClearTagCtrls();
   RxClearTagCtrls();

   waitingForRespone = false;
   waitResetRdrACK = false;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::EnableReaderStaticTextClick(
      TObject *Sender)
{
   if (!EnableReaderGroupBox->Visible)
   {
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = true;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      //GeneralGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = false;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = true;
   DownloadRdrStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = true;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = false;
   DownloadRdrBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   FGenResetBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   DownloadRdrBitBtn->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   EnableReaderListView->Items->Clear();
   if (lastReaderID > 0)
      EnableReaderIDComboBox->Text = lastReaderID;
   for (unsigned int i=0; i<numReaderIDList; i++)
   {
      if (EnableReaderIDComboBox->Items->IndexOf(readerIDList[i]) == -1 )
         EnableReaderIDComboBox->Items->Add(readerIDList[i]);
   }

   //if (lastHostID > 0)
      //EnableReaderHostIDEdit->Text = lastHostID;

   if (allHostID)
   {
      if (lastHostID > 0)
         EnableReaderHostIDEdit->Text = lastHostID;
   }
   else
      EnableReaderHostIDEdit->Text = sysHostID;

   //Reset Device  0x01
   TxClearTagCtrls();
   RxClearTagCtrls();
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::DisableReaderStaticTextClick(
      TObject *Sender)
{
   if (!DisableReaderGroupBox->Visible)
   {
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = true;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      //GeneralGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = false;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = true;
   DownloadRdrStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = true;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = false;
   DownloadRdrBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   FGenResetBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   DownloadRdrBitBtn->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   DisableReaderListView->Items->Clear();
   if (lastReaderID > 0)
      DisableReaderIDComboBox->Text = lastReaderID;
   for (unsigned int i=0; i<numReaderIDList; i++)
   {
      if (DisableReaderIDComboBox->Items->IndexOf(readerIDList[i]) == -1 )
         DisableReaderIDComboBox->Items->Add(readerIDList[i]);
   }

   //if (lastHostID > 0)
      //DisableReaderHostIDEdit->Text = lastHostID;
   if (allHostID)
   {
      if (lastHostID > 0)
         DisableReaderHostIDEdit->Text = lastHostID;
   }
   else
      DisableReaderHostIDEdit->Text = sysHostID;

   //Reset Device  0x01
   TxClearTagCtrls();
   RxClearTagCtrls();
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::QueryReaderStaticTextClick(
      TObject *Sender)
{
   if (!QueryReaderGroupBox->Visible)
   {
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = true;
      AssignReaderGroupBox->Visible = false;
      //GeneralGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      SetFStrengthBitBtn->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = false;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = true;
   DownloadRdrStaticText->Visible = true;
   RelayStaticText->Visible = true;
   //InputsStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = true;
   AssignReaderBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   DownloadRdrBitBtn->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   FGenResetBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   DownloadRdrBitBtn->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   QueryReaderListView->Items->Clear();
   if (lastReaderID > 0)
      QueryReaderIDComboBox->Text = lastReaderID;
   for (unsigned int i=0; i<numReaderIDList; i++)
   {
      if (QueryReaderIDComboBox->Items->IndexOf(readerIDList[i]) == -1 )
         QueryReaderIDComboBox->Items->Add(readerIDList[i]);
   }

   //if (lastHostID > 0)
      //QueryReaderHostIDEdit->Text = lastHostID;
   if (allHostID)
   {
      if (lastHostID > 0)
         QueryReaderHostIDEdit->Text = lastHostID;
   }
   else
      QueryReaderHostIDEdit->Text = sysHostID;


   //Reset Device  0x01
   TxClearTagCtrls();
   RxClearTagCtrls();
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::AssignReaderStaticTextClick(
      TObject *Sender)
{
   if (!AssignReaderGroupBox->Visible)
   {
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = true;
      EnableFGenGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      //GeneralGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = false;
   ReaderVersionStaticText->Visible = true;
  //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = true;
   DownloadRdrStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = true;
   SetFStrengthBitBtn->Visible = false;
   DownloadRdrBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   FGenResetBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   DownloadRdrBitBtn->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   AssignReaderNewRdrCheckBox->Checked = false;
   AssignReaderNewHostCheckBox->Checked = false;
   AssignReaderNoChangeCheckBox->Checked = false;

   if ((AssignReaderTypeComboBox->Text == "Standard Reader") ||
       (AssignReaderTypeComboBox->Text == "SaniFaucet Faucet Unit"))
      ChangeConfigReaderSTDControls(false);
   else
      ChangeConfigReaderSTDControls(true);
   AssignReaderListView->Items->Clear();

   if (AssignReaderIDComboBox->Text.data() == NULL)
   //if (lastReaderID > 0)
      AssignReaderIDComboBox->Text = lastReaderID;
   for (unsigned int i=0; i<numReaderIDList; i++)
   {
      if (AssignReaderIDComboBox->Items->IndexOf(readerIDList[i]) == -1 )
         AssignReaderIDComboBox->Items->Add(readerIDList[i]);
   }

   //if (lastHostID > 0)
      //AssignReaderHostIDEdit->Text = lastHostID;
   if (allHostID)
   {
      if (lastHostID > 0)
         AssignReaderHostIDEdit->Text = lastHostID;
   }
   else
      AssignReaderHostIDEdit->Text = sysHostID;


   TxClearTagCtrls();
   RxClearTagCtrls();
   AssignReaderListView->Items->Clear();

   StaticText->Caption = "";
   receivedResponse = false;

   if (AssignReaderIDComboBox->Text.data() == NULL)
      AssignReaderIDComboBox->Text = lastReaderID;

   for (unsigned int i=0; i<numReaderIDList; i++)
   {
      if (AssignReaderIDComboBox->Items->IndexOf(readerIDList[i]) == -1 )
         AssignReaderIDComboBox->Items->Add(readerIDList[i]);
   }

   if (allHostID)
   {
      if (lastHostID > 0)
         AssignReaderHostIDEdit->Text = lastHostID;
   }
   else
      AssignReaderHostIDEdit->Text = sysHostID;

  if(networkOn)
   {
      int rdr = atoi(AssignReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(QUERY_READER, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(QUERY_READER, 0, NULL, 0);
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ReaderVersionStaticTextClick(
      TObject *Sender)
{
   if (!ReaderCodeVerGroupBox->Visible)
   {
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      //GeneralGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = true;
      DownloadRdrGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   //DataCodeVerLabel->Caption = "";
   //ProgCodeVerLabel->Caption = "";
   //HostCodeVerLabel->Caption = "";

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = false;
   //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = true;
   DownloadRdrStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = false;
   DownloadRdrBitBtn->Visible = false;
   ReaderVersion->Visible = true;
   //EnableFGenBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   FGenResetBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   DownloadRdrBitBtn->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   //if (lastHostID <= 0)
      //RdrCodeVerHostEdit->Text = "";
   //else
      //RdrCodeVerHostEdit->Text = lastHostID;
   if (allHostID)
   {
      if (lastHostID > 0)
         RdrCodeVerHostEdit->Text = lastHostID;
   }
   else
      RdrCodeVerHostEdit->Text = sysHostID;

   RdrCodeVerReaderComboBox->Items->Clear();
   for (unsigned int i=0; i<numReaderIDList; i++)
      RdrCodeVerReaderComboBox->Items->Add(readerIDList[i]);

   if (lastReaderID <= 0)
      RdrCodeVerReaderComboBox->Text = "";
   else
      RdrCodeVerReaderComboBox->Text = lastReaderID;

   TxClearTagCtrls();
   RxClearTagCtrls();
   StaticText->Caption = "";
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTxTimeStaticTextClick(
      TObject *Sender)
{
   if (!ConfigReaderTxTimeGroupBox->Visible)
   {
      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = true;
      //GeneralGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   ConfigTxTimeStaticText->Visible = false;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = true;
   //EnableFGenStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = true;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;

   //if (lastHostID <= 0)
      //ConfigTxTimeHostIDEdit->Text = "";
   //else
      //ConfigTxTimeHostIDEdit->Text = lastHostID;
   if (allHostID)
   {
      if (lastHostID > 0)
         ConfigTxTimeHostIDEdit->Text = lastHostID;
   }
   else
      ConfigTxTimeHostIDEdit->Text = sysHostID;


   ConfigTxTimeReaderIDComboBox->Items->Clear();
   for (unsigned int i=0; i<numReaderIDList; i++)
      ConfigTxTimeReaderIDComboBox->Items->Add(readerIDList[i]);

   if (lastReaderID <= 0)
      ConfigTxTimeReaderIDComboBox->Text = "";
   else
      ConfigTxTimeReaderIDComboBox->Text = lastReaderID;

   //Reset Device  0x01
   TxClearTagCtrls();
   RxClearTagCtrls();
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::RelayStaticTextClick(
      TObject *Sender)
{
   if (!RelayGroupBox->Visible)
   {
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      //GeneralGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      SetFStrengthStaticText->Visible = true;
      SetFStrengthGroupBox->Visible = false;
      RelayGroupBox->Visible = true;
      InputGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = true;
   DownloadRdrStaticText->Visible = true;
   //ConfigTxTimeStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   RelayStaticText->Visible = false;
   InputsStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = false;
   DownloadRdrBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   FGenResetBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = true;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   DownloadRdrBitBtn->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clNavy;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   //if (lastHostID <= 0)
      //EnableFGenHostIDEdit->Text = "";
   //else
      //EnableFGenHostIDEdit->Text = lastHostID;
   if (allHostID)
   {
      if (lastHostID > 0)
         RelayHostIDEdit->Text = lastHostID;
   }
   else
      RelayHostIDEdit->Text = sysHostID;

   //FGenReaderIDComboBox->Items->Clear();
   for (unsigned int i=0; i<numReaderIDList; i++)
      RelayReaderIDComboBox->Items->Add(readerIDList[i]);

   if (lastReaderID <= 0)
      RelayReaderIDComboBox->Text = "";
   else
      RelayReaderIDComboBox->Text = lastReaderID;

   //Reset Device  0x01
   TxClearTagCtrls();
   RxClearTagCtrls();
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::InputsStaticTextClick(TObject *Sender)
{
   if (!InputGroupBox->Visible)
   {
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = true;
      //InputsGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = true;
   DownloadRdrStaticText->Visible = true;
   //ConfigTxTimeStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = false;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = false;
   DownloadRdrBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   FGenResetBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = true;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clNavy;
   DownloadRdrBitBtn->Font->Color = clNavy;
   InputsBitBtn->Font->Color = clNavy;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   //if (lastHostID <= 0)
      //EnableFGenHostIDEdit->Text = "";
   //else
      //EnableFGenHostIDEdit->Text = lastHostID;
   if (allHostID)
   {
      if (lastHostID > 0)
         InputHostIDEdit->Text = lastHostID;
   }
   else
      InputHostIDEdit->Text = sysHostID;

   InputReaderIDComboBox->Items->Clear();
   for (unsigned int i=0; i<numReaderIDList; i++)
      InputReaderIDComboBox->Items->Add(readerIDList[i]);

   if (lastReaderID <= 0)
      InputReaderIDComboBox->Text = "";
   else
      InputReaderIDComboBox->Text = lastReaderID;

   //Reset Device  0x01
   TxClearTagCtrls();
   RxClearTagCtrls();
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ConfigFGenStaticTextClick(
      TObject *Sender)
{
   if (!ConfigFGenGroupBox->Visible)
   {
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = true;
      ConfigSFGenGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      //GeneralGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = true;
   ConfigFGenStaticText->Visible = false;
   QueryFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = true;
   ConfigSFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   FGenResetBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   ConfigSFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   FGenConfigWaitTimeSecClicked = false;
   FGenConfigWaitTimeMinClicked = false;
   FGenConfigWaitTimeHourClicked = false;

   /////////////////////////////////
   if (allHostID)   //Host
   {
      if (lastHostID > 0)
         FGenConfigHostIDEdit->Text = lastHostID;
   }
   else
      FGenConfigHostIDEdit->Text = sysHostID;

   /*FGenConfigSmartFGenReaderIDComboBox->Items->Clear();  //reader smart Fgen
   for (int i=0; i<numReaderIDList; i++)
      FGenConfigSmartFGenReaderIDComboBox->Items->Add(readerIDList[i]);
   if (lastReaderID <= 0)
      FGenConfigSmartFGenReaderIDComboBox->Text = "";
   else
      FGenConfigSmartFGenReaderIDComboBox->Text = lastReaderID;

   FGenConfigSmartFieldGenIDComboBox->Items->Clear();  //FGen smart
   for (int i=0; i<numFgenIDList; i++)
      FGenConfigSmartFieldGenIDComboBox->Items->Add(fgenIDList[i]);
   if (lastSmartFieldGenID <= 0)
      FGenConfigSmartFieldGenIDComboBox->Text = "";
   else
      FGenConfigSmartFieldGenIDComboBox->Text = lastSmartFieldGenID; */

   if (lastFieldGenID <= 0)   //Fgen
      FGenConfigFieldGenIDEdit->Text = "";
   else
      FGenConfigFieldGenIDEdit->Text = lastFieldGenID;

   ///////////////////////////////
   /*if (allHostID)   //Host
   {
      if (lastHostID > 0)
         FGenConfigHostIDEdit->Text = lastHostID;
   }
   else
      FGenConfigHostIDEdit->Text = sysHostID;

   if (allHostID)
   {
      if (lastHostID > 0)
         FGenConfigHostIDEdit->Text = lastHostID;
   }
   else
      FGenConfigHostIDEdit->Text = sysHostID;

   if (lastFieldGenID <= 0)
      FGenConfigFieldGenIDEdit->Text = "";
   else
      FGenConfigFieldGenIDEdit->Text = lastFieldGenID;

   FGenConfigSmartFieldGenIDComboBox->Items->Clear();
   for (int i=0; i<numReaderIDList; i++)
      FGenConfigSmartFieldGenIDComboBox->Items->Add(readerIDList[i]);

   if (lastReaderID <= 0)
      FGenConfigSmartFieldGenIDComboBox->Text = "";
   else
      FGenConfigSmartFieldGenIDComboBox->Text = lastReaderID;

   TxClearTagCtrls();
   RxClearTagCtrls();


   QueryFGenIDEdit->Text = lastFieldGenID;
   WriteRS232Comm(QUERY_FIELD_GEN, 0, NULL, 0);
   */

}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::QueryFGenStaticTextClick(TObject *Sender)
{
   if (!QueryFGenGroupBox->Visible)
   {
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = true;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      //GeneralGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = false;
   QuerySFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   //EnableFGenStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = true;
   FGenResetBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   if (allHostID)   //Host
   {
      if (lastHostID > 0)
         QueryFGenHostIDEdit->Text = lastHostID;
   }
   else
      QueryFGenHostIDEdit->Text = sysHostID;

   /*QueryFGenSmartFGenRdrIDComboBox->Items->Clear();  //reader smart Fgen
   for (int i=0; i<numReaderIDList; i++)
      QueryFGenSmartFGenRdrIDComboBox->Items->Add(readerIDList[i]);
   if (lastReaderID <= 0)
      QueryFGenSmartFGenRdrIDComboBox->Text = "";
   else
      QueryFGenSmartFGenRdrIDComboBox->Text = lastReaderID;

   QueryFGenSmartFGenIDComboBox->Items->Clear();  //FGen smart
   for (int i=0; i<numFgenIDList; i++)
      QueryFGenSmartFGenIDComboBox->Items->Add(fgenIDList[i]);
   if (lastSmartFieldGenID <= 0)
      QueryFGenSmartFGenIDComboBox->Text = "";
   else
      QueryFGenSmartFGenIDComboBox->Text = lastSmartFieldGenID;  */

   if (lastFieldGenID <= 0)   //Fgen
      QueryFGenIDEdit->Text = "";
   else
      QueryFGenIDEdit->Text = lastFieldGenID;

   TxClearTagCtrls();
   RxClearTagCtrls();
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::SmartFGenStaticTextClick(TObject *Sender)
{
   if (!SmartFGenGroupBox->Visible)
   {
      EncryptGroupBox->Visible = false;
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      DownloadSFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = true;
      FGenResetGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   SmartFGenStaticText->Visible = false;
   QuerySFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   DownloadSFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   FGenResetBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = true;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   SmartFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;



   //if (lastFieldGenID <= 0)
      //SmartFGenIDComboBox->Text = "";
   //else
      //SmartFGenIDComboBox->Text = lastFieldGenID;

   SmartFGenReaderIDComboBox->Items->Clear();
   for (unsigned int i=0; i<numReaderIDList; i++)
      SmartFGenReaderIDComboBox->Items->Add(readerIDList[i]);

   if (lastReaderID <= 0)
      SmartFGenReaderIDComboBox->Text = "";
   else
      SmartFGenReaderIDComboBox->Text = lastReaderID;

   if (allHostID)
   {
      if (lastHostID > 0)
         QueryFGenHostIDEdit->Text = lastHostID;
   }
   else
      QueryFGenHostIDEdit->Text = sysHostID;

   TxClearTagCtrls();
   RxClearTagCtrls();

   ProgammingMode = true;
   programming = false;
   StaticText->Caption = "";

   receivedResponse = false;
   /*if (readerFgenButtonActivated)
   {
      ReaderFgenToolButton->Hint = "Set Programming Station To Field Generator Mode";
      readerFgenButtonActivated = false;
      if(networkOn)
         CloseNetworkConnection();
      else if (RS232On)
         ClosePort();
      EnableAllCommands(false);
      if (OpenSerial(comPort, lastBaudrate))
      {
         ProgStationForm->PortOpen = true;
         baudRate = curBaudrate = lastBaudrate;
         PlaySound("Ding.wav", NULL, SND_ASYNC );
      }
      EnableAllCommands(true);
      readerOffLine = true;
      readerOnLine = false;
      fieldGenOffLine = true;
      fieldGenOnLine = false;
   }*/

   if(networkOn)
   {
      /*int rdr = atoi(SmartFGenReaderIDComboBox->Text.c_str());
      int index = GetIpAddressIndex(rdr);
      if (index >= 0)
      {
         WriteTCPIPComm(GET_DPOT_SMART_FGEN, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
      }
      else
      {
         Application->MessageBox("Did not find IP address.",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return;
      }*/

      int rdr = atoi(SmartFGenReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(GET_DPOT_SMART_FGEN, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(GET_DPOT_SMART_FGEN, 0, NULL, 0);
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::DownloadSmartFGenStaticTextClick(
      TObject *Sender)
{
   if (!DownloadSFGenGroupBox->Visible)
   {
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      DownloadSFGenGroupBox->Visible = true;
      FGenResetGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      //GeneralGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   DownloadSmartFGenStaticText->Visible = false;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   //EnableFGenStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   DownloadSFGenBitBtn->Visible = true;
   FGenResetBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   QuerySFGenBitBtn->Font->Color = clPurple;
   DownloadSFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   if (allHostID)   //Host
   {
      if (lastHostID > 0)
         DownloadSFGenHostEdit->Text = lastHostID;
   }
   else
      DownloadSFGenHostEdit->Text = sysHostID;

   DownloadSFGenReaderComboBox->Items->Clear();  //reader smart Fgen
   for (unsigned int i=0; i<numReaderIDList; i++)
      DownloadSFGenReaderComboBox->Items->Add(readerIDList[i]);
   if (lastReaderID <= 0)
      DownloadSFGenReaderComboBox->Text = "";
   else
      DownloadSFGenReaderComboBox->Text = lastReaderID;

   DownloadSFGenIDComboBox->Items->Clear();  //FGen smart
   for (unsigned int i=0; i<numSFgenIDList; i++)
      DownloadSFGenIDComboBox->Items->Add(fgenIDList[i]);
   if (lastSmartFieldGenID <= 0)
      DownloadSFGenIDComboBox->Text = "";
   else
      DownloadSFGenIDComboBox->Text = lastSmartFieldGenID;

   TxClearTagCtrls();
   RxClearTagCtrls();
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::FGenResetStaticTextClick(TObject *Sender)
{
   if (!FGenResetGroupBox->Visible)
   {
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      DownloadSFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = true;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = false;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   DownloadSFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   FGenResetBitBtn->Visible = true;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   SmartFGenBitBtn->Font->Color = clPurple;
   FGenResetBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   if (allHostID)
   {
      if (lastHostID > 0)
         FGenResetHostIDEdit->Text = lastHostID;
   }
   else
      FGenResetHostIDEdit->Text = sysHostID;

   if (lastSmartFieldGenID <= 0)
      FGenResetIDComboBox->Text = "";
   else
      FGenResetIDComboBox->Text = lastSmartFieldGenID;

   FGenResetReaderIDComboBox->Items->Clear();
   for (unsigned int i=0; i<numReaderIDList; i++)
      FGenResetReaderIDComboBox->Items->Add(readerIDList[i]);

   if (lastReaderID <= 0)
      FGenResetReaderIDComboBox->Text = "";
   else
      FGenResetReaderIDComboBox->Text = lastReaderID;

   TxClearTagCtrls();
   RxClearTagCtrls();
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::FGenResetBitBtnClick(TObject *Sender)
{
   FGenResetBitBtn->Font->Color = clRed;

   TxClearTagCtrls();
   RxClearTagCtrls();
   ProgammingMode = true;
   programming = false;
   StaticText->Caption = "";

   receivedResponse = false;
   /*if (readerFgenButtonActivated)
   {
      ReaderFgenToolButton->Hint = "Set Programming Station To Field Generator Mode";
      readerFgenButtonActivated = false;
      if(networkOn)
         CloseNetworkConnection();
      else if (RS232On)
         ClosePort();
      EnableAllCommands(false);
      if (OpenSerial(comPort, lastBaudrate))
      {
         ProgStationForm->PortOpen = true;
         baudRate = curBaudrate = lastBaudrate;
         PlaySound("Ding.wav", NULL, SND_ASYNC );
      }
      EnableAllCommands(true);
      readerOffLine = true;
      readerOnLine = false;
      fieldGenOffLine = true;
      fieldGenOnLine = false;
   }*/

   //QueryTagBitBtn->Enabled = false;
   /*EnableReaderStaticText->Enabled = false;
   DisableReaderStaticText->Enabled = false;
   QueryReaderStaticText->Enabled = false;
   AssignReaderStaticText->Enabled = false;
   ReaderVersionStaticText->Enabled = false;
   ConfigTxTimeStaticText->Enabled = false;
   RelayStaticText->Enabled = false;
   EnableRdrFGenStaticText->Enabled = false;
   ConfigFGenStaticText->Enabled = false;
   QueryFGenStaticText->Enabled = false;
   FGenResetStaticText->Enabled = false;
   SmartFGenStaticText->Enabled = false;
   QuerySFGenStaticText->Enabled = false;
   ConfigSFGenStaticText->Enabled = false;
   ConfigTagStaticText->Enabled = false;
   EnableTagStaticText->Enabled = false;
   DisableTagStaticText->Enabled = false;
   QueryTagStaticText->Enabled = false;
   CallTagStaticText->Enabled = false;
   AssignTagRdrStaticText->Enabled = false;
   ConfigTagRNDStaticText->Enabled = false;
   WriteMemoryStaticText->Enabled = false;
   ReadMemoryStaticText->Enabled = false;
   TagTempStaticText->Enabled = false;
   InputsStaticText->Enabled = false; */

   FGenResetListView->Items->Clear();
   if (FGenResetBroadcastSmartFGenCheckBox->Checked)
   {
      FGenResetIDComboBox->Clear();
   }

   CMDEnableTimer->Enabled = true;
   DisableSmartFGenStaticCommands();
   FGenResetBitBtn->Enabled = false;

   if(networkOn)
   {
      /*int rdr = atoi(FGenResetReaderIDComboBox->Text.c_str());
      int index = GetIpAddressIndex(rdr);
      if (index >= 0)
      {
         WriteTCPIPComm(RESET_SMART_FGEN, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
      }
      else
      {
         Application->MessageBox("Did not find IP address.",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return;
      }*/

      int rdr = atoi(FGenResetReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(RESET_SMART_FGEN, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(RESET_SMART_FGEN, 0, NULL, 0);
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagStaticTextClick(TObject *Sender)
{
   if (!ConfigTagGroupBox->Visible)
   {
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      //GeneralGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = true;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   ConfigTagStaticText->Visible = false;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   FGenResetBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = true;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   ConfigTagFactoryIDCheckBox->Checked = false;
   ConfigTagEnableTimeCheckBox->Checked = false;
   ConfigTagTIFCheckBox->Checked = false;
   //ConfigTagGCCheckBox->Checked = false;
   ConfigTagRNNoChangeRadioButton->Checked = true;
   ConfigTagNewTagIDCheckBox->Checked = false;
   ConfigTagNewTagTypeCheckBox->Checked = false;

   //if (lastHostID <= 0)
      //ConfigTagHostIDEdit->Text = "";
   //else
      //ConfigTagHostIDEdit->Text = lastHostID;
   if (allHostID)
   {
      if (lastHostID > 0)
         ConfigTagHostIDEdit->Text = lastHostID;
   }
   else
      ConfigTagHostIDEdit->Text = sysHostID;

   ConfigTagReaderIDComboBox->Items->Clear();
   for (unsigned int i=0; i<numReaderIDList; i++)
      ConfigTagReaderIDComboBox->Items->Add(readerIDList[i]);

   if (lastReaderID <= 0)
      ConfigTagReaderIDComboBox->Text = "";
   else
      ConfigTagReaderIDComboBox->Text = lastReaderID;

   ConfigTagTagIDEdit->Text = "";
   ConfigTagDurationComboBox->Text = "";
   ConfigTagTIFComboBox->Text = "";
   ConfigTagGCComboBox->Text = "";
   //ConfigTagAccessCtrlRadioButton->Checked = true;
   ConfigTagModifyTamperCheckBox->Checked = false;
   ConfigTagModifyRNCheckBox->Checked = false;

   //Reset Device  0x01
   TxClearTagCtrls();
   RxClearTagCtrls();
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::EnableTagStaticTextClick(TObject *Sender)
{
   if (!EnableTagGroupBox->Visible)
   {
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      //GeneralGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = true;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = false;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   FGenResetBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = true;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   //if (lastHostID <= 0)
      //EnableTagHostIDEdit->Text = "";
   //else
      //EnableTagHostIDEdit->Text = lastHostID;
   if (allHostID)
   {
      if (lastHostID > 0)
         EnableTagHostIDEdit->Text = lastHostID;
   }
   else
      EnableTagHostIDEdit->Text = sysHostID;

   EnableTagIDComboBox->Items->Clear();
   for (unsigned int i=0; i<numReaderIDList; i++)
      EnableTagIDComboBox->Items->Add(readerIDList[i]);

   if (lastReaderID <= 0)
      EnableTagIDComboBox->Text = "";
   else
      EnableTagIDComboBox->Text = lastReaderID;

   EnableTagRNShortRadioButton->Checked = true;

   TxClearTagCtrls();
   RxClearTagCtrls();
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::DisableTagStaticTextClick(
      TObject *Sender)
{
   if (!DisableTagGroupBox->Visible)
   {
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      //GeneralGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = true;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = false;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   FGenResetBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = true;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   //if (lastHostID <= 0)
      //DisableTagHostIDEdit->Text = "";
   //else
      //DisableTagHostIDEdit->Text = lastHostID;
   if (allHostID)
   {
      if (lastHostID > 0)
         DisableTagHostIDEdit->Text = lastHostID;
   }
   else
      DisableTagHostIDEdit->Text = sysHostID;

   DisableTagIDComboBox->Items->Clear();
   for (unsigned int i=0; i<numReaderIDList; i++)
      DisableTagIDComboBox->Items->Add(readerIDList[i]);

   if (lastReaderID <= 0)
      DisableTagIDComboBox->Text = "";
   else
      DisableTagIDComboBox->Text = lastReaderID;

   DisableTagRNShortRadioButton->Checked = true;

   TxClearTagCtrls();
   RxClearTagCtrls();
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::QueryTagStaticTextClick(TObject *Sender)
{
   if (!QueryTagGroupBox->Visible)
   {
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      //GeneralGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = true;
      CallTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = false;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   FGenResetBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = true;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   QueryTagBitBtn->Enabled = true;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   TxClearTagCtrls();
   RxClearTagCtrls();
   ProgammingMode = true;
   StaticText->Caption = "";
   DetectedMsg->Caption = "";
   TamperSWMsg->Caption = "";
   TagDetectedGroupBox->Caption = "Detected Tags";
   tagDetectCount = 0;
   type1Count = 0;
   type2Count = 0;
   type3Count = 0;
   type4Count = 0;
   type5Count = 0;
   type6Count = 0;
   typeFacCount = 0;
   ReportType1Label->Caption = "";
   ReportType2Label->Caption = "";
   ReportType3Label->Caption = "";
   ReportType4Label->Caption = "";
   ReportType5Label->Caption = "";
   ReportType6Label->Caption = "";
   ReportFACTLabel->Caption = "";
   ReportTotalLabel->Caption = "";
   ReportNDupLabel->Caption = "";
   DetectedTagListView->Items->Clear();
   for (int i=0; i<MAX_TAG_DETECTED; i++)
   {
      tagDetectedArray[i].tagID = 0;
      tagDetectedArray[i].tagType = 6;
      tagDetectedArray[i].cmd = 0;
      tagDetectedArray[i].fGenID = 0xFF;
      tagDetectedArray[i].gID = false;
      tagDetectedArray[i].lastDetectTime = Now();
   }

   //if (lastHostID <= 0)
      //QueryTagHostIDEdit->Text = "";
   //else
      //QueryTagHostIDEdit->Text = lastHostID;
   if (allHostID)
   {
      if (lastHostID > 0)
         QueryTagHostIDEdit->Text = lastHostID;
   }
   else
      QueryTagHostIDEdit->Text = sysHostID;

   QueryTagReaderIDComboBox->Items->Clear();
   for (unsigned int i=0; i<numReaderIDList; i++)
      QueryTagReaderIDComboBox->Items->Add(readerIDList[i]);

   if (lastReaderID <= 0)
      QueryTagReaderIDComboBox->Text = "";
   else
      QueryTagReaderIDComboBox->Text = lastReaderID;

   QueryTagRNShortRadioButton->Checked = true;

   TxClearTagCtrls();
   RxClearTagCtrls();
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::CallTagStaticTextClick(TObject *Sender)
{
   if (!CallTagGroupBox->Visible)
   {
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      //GeneralGroupBox->Visible = true;
      EnableFGenGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = true;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = false;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   FGenResetBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = true;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   TxClearTagCtrls();
   RxClearTagCtrls();
   ProgammingMode = true;
   StaticText->Caption = "";
   DetectedMsg->Caption = "";
   TamperSWMsg->Caption = "";
   TagDetectedGroupBox->Caption = "Detected Tags";
   tagDetectCount = 0;
   type1Count = 0;
   type2Count = 0;
   type3Count = 0;
   type4Count = 0;
   type5Count = 0;
   type6Count = 0;
   typeFacCount = 0;
   ReportType1Label->Caption = "";
   ReportType2Label->Caption = "";
   ReportType3Label->Caption = "";
   ReportType4Label->Caption = "";
   ReportType5Label->Caption = "";
   ReportType6Label->Caption = "";
   ReportFACTLabel->Caption = "";
   ReportTotalLabel->Caption = "";
   ReportNDupLabel->Caption = "";
   DetectedTagListView->Items->Clear();
   for (int i=0; i<MAX_TAG_DETECTED; i++)
   {
      tagDetectedArray[i].tagID = 0;
      tagDetectedArray[i].tagType = 6;
      tagDetectedArray[i].cmd = 0;
      tagDetectedArray[i].fGenID = 0xFF;
      tagDetectedArray[i].gID = false;
      tagDetectedArray[i].lastDetectTime = Now();
   }

   //if (lastHostID <= 0)
      //CallTagHostIDEdit->Text = "";
   //else
      //CallTagHostIDEdit->Text = lastHostID;
   if (allHostID)
   {
      if (lastHostID > 0)
         CallTagHostIDEdit->Text = lastHostID;
   }
   else
      CallTagHostIDEdit->Text = sysHostID;

   CallTagReaderIDComboBox->Items->Clear();
   for (unsigned int i=0; i<numReaderIDList; i++)
      CallTagReaderIDComboBox->Items->Add(readerIDList[i]);

   if (lastReaderID <= 0)
      CallTagReaderIDComboBox->Text = "";
   else
      CallTagReaderIDComboBox->Text = lastReaderID;

   CallTagRNShortRadioButton->Checked = true;
   //Reset Device  0x01
   TxClearTagCtrls();
   RxClearTagCtrls();
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::AssignTagRdrStaticTextClick(
      TObject *Sender)
{
   if (!AssignTagReaderGroupBox->Visible)
   {
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      //GeneralGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = true;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = false;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   FGenResetBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = true;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   //if (lastHostID <= 0)
      //AssignTagRdrHostIDEdit->Text = "";
   //else
      //AssignTagRdrHostIDEdit->Text = lastHostID;
   if (allHostID)
   {
      if (lastHostID > 0)
         AssignTagRdrHostIDEdit->Text = lastHostID;
   }
   else
      AssignTagRdrHostIDEdit->Text = sysHostID;


   AssignTagRdrRdrIDComboBox->Items->Clear();
   for (unsigned int i=0; i<numReaderIDList; i++)
      AssignTagRdrRdrIDComboBox->Items->Add(readerIDList[i]);

   if (lastReaderID <= 0)
      AssignTagRdrRdrIDComboBox->Text = "";
   else
      AssignTagRdrRdrIDComboBox->Text = lastReaderID;

   //Reset Device  0x01
   TxClearTagCtrls();
   RxClearTagCtrls();
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ConfigTagRNDStaticTextClick(
      TObject *Sender)
{
   if (!ConfigTagRandGroupBox->Visible)
   {
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      //GeneralGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = true;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = false;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   FGenResetBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = true;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   //if (lastHostID <= 0)
      //ConfigTagRNDHostIDEdit->Text = "";
   //else
      //ConfigTagRNDHostIDEdit->Text = lastHostID;
   if (allHostID)
   {
      if (lastHostID > 0)
         ConfigTagRNDHostIDEdit->Text = lastHostID;
   }
   else
      ConfigTagRNDHostIDEdit->Text = sysHostID;


   ConfigTagRNDRdrIDComboBox->Items->Clear();
   for (unsigned int i=0; i<numReaderIDList; i++)
      ConfigTagRNDRdrIDComboBox->Items->Add(readerIDList[i]);

   if (lastReaderID <= 0)
      ConfigTagRNDRdrIDComboBox->Text = "";
   else
      ConfigTagRNDRdrIDComboBox->Text = lastReaderID;

   TxClearTagCtrls();
   RxClearTagCtrls();
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::WriteMemoryStaticTextClick(
      TObject *Sender)
{
   if (!WriteMemoryGroupBox->Visible)
   {
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      //GeneralGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = true;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = false;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   FGenResetBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = true;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   if (allHostID)
   {
      if (lastHostID > 0)
         WriteMemoryHostIDEdit->Text = lastHostID;
   }
   else
      WriteMemoryHostIDEdit->Text = sysHostID;

   WriteMemoryReaderIDComboBox->Items->Clear();
   for (unsigned int i=0; i<numReaderIDList; i++)
      WriteMemoryReaderIDComboBox->Items->Add(readerIDList[i]);

   if (lastReaderID <= 0)
      WriteMemoryReaderIDComboBox->Text = "";
   else
      WriteMemoryReaderIDComboBox->Text = lastReaderID;

   WriteMemoryTagRNLongRadioButton->Checked = true;

   for (int i=0; i<13; i++)
      WriteMemoryStringGrid->Cells[i][1] = "";

   TxClearTagCtrls();
   RxClearTagCtrls();



   /* int i, k=0;

    for (i = 1; i < WriteMemStringGrid->ColCount; i++)
       WriteMemStringGrid->Cells[i][0] = IntToStr(++k);

    for (i = 1, k=0; i < 21; i++)
       WriteMemStringGrid->Cells[0][i] = IntToStr(++k);
   */

   // for (I = 0; J < StringGrid1->RowCount; J++)
   /*if (allHostID)
   {
      if (lastHostID > 0)
         ConfigTagRNDHostIDEdit->Text = lastHostID;
   }
   else
      ConfigTagRNDHostIDEdit->Text = sysHostID;


   ConfigTagRNDRdrIDComboBox->Items->Clear();
   for (int i=0; i<numReaderIDList; i++)
      ConfigTagRNDRdrIDComboBox->Items->Add(readerIDList[i]);

   if (lastReaderID <= 0)
      ConfigTagRNDRdrIDComboBox->Text = "";
   else
      ConfigTagRNDRdrIDComboBox->Text = lastReaderID;

   TxClearTagCtrls();
   RxClearTagCtrls(); */
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::ReadMemoryStaticTextClick(
      TObject *Sender)
{
   if (!ReadMemoryGroupBox->Visible)
   {
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      //GeneralGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = true;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = false;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   FGenResetBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = true;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   if (allHostID)
   {
      if (lastHostID > 0)
         ReadMemoryHostIDEdit->Text = lastHostID;
   }
   else
      ReadMemoryHostIDEdit->Text = sysHostID;

   ReadMemoryReaderIDComboBox->Items->Clear();
   for (unsigned int i=0; i<numReaderIDList; i++)
      ReadMemoryReaderIDComboBox->Items->Add(readerIDList[i]);

   if (lastReaderID <= 0)
      ReadMemoryReaderIDComboBox->Text = "";
   else
      ReadMemoryReaderIDComboBox->Text = lastReaderID;

   ReadMemoryTagRNLongRadioButton->Checked = true;

   for (int i = 1; i < ReadMemoryStringGrid->ColCount; i++)
      for (int j = 1; j < ReadMemoryStringGrid->RowCount; j++)
       ReadMemoryStringGrid->Cells[i][j] = "";

   TxClearTagCtrls();
   RxClearTagCtrls();
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::TagTempStaticTextClick(TObject *Sender)
{
   if (!TagTempGroupBox->Visible)
   {
      EncryptGroupBox->Visible = false;
      if (TagTempDisplayListCheckBox->Checked)
      {
         TagTempListGroupBox->Visible = true;
         TagDetectedGroupBox->Visible = false;
      }
      else
      {
         TagTempListGroupBox->Visible = false;
         TagDetectedGroupBox->Visible = true;
      }
      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      //GeneralGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = true;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = false;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   FGenResetBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = true;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clNavy;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   if (allHostID)
   {
      if (lastHostID > 0)
         TagTempHostIDEdit->Text = lastHostID;
   }
   else
      TagTempHostIDEdit->Text = sysHostID;

   TagTempReaderIDComboBox->Items->Clear();
   for (unsigned int i=0; i<numReaderIDList; i++)
      TagTempReaderIDComboBox->Items->Add(readerIDList[i]);

   if (lastReaderID <= 0)
      TagTempReaderIDComboBox->Text = "";
   else
      TagTempReaderIDComboBox->Text = lastReaderID;

   TagTempTagRNShortRadioButton->Checked = true;

   AnsiString s;
   if (TagTempLimitCdegRadioButton->Checked)
   {
      if (tagTempCalibC == 0.0)
          s = "(0.00)";
       else if (tagTempCalibC > 0)
          s = s.FormatFloat("(+#0.00 C)", tagTempCalibC);
       else
          s = s.FormatFloat("(-#0.00 C)", -tagTempCalibC);
    }
    else
    {
       float f = ((tagTempCalibC/5.0)*9.0);

       if (f == 0.0)
          s = "(0.00)";
       else if (f > 0)
          s = s.FormatFloat("(+#0.00 F)", f);
       else
          s = s.FormatFloat("(-#0.00 F)", -f);
    }
    TagTempCalibValueLabel->Caption = s;

   TxClearTagCtrls();
   RxClearTagCtrls();
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ResetBroadcastReaderCheckBoxClick(
      TObject *Sender)
{
    if (ResetBroadcastReaderCheckBox->State == cbChecked)
    {
       ResetReaderIDComboBox->Enabled = false;
       //FGenResetReaderLabel->Enabled = false;
       ResetReaderIDComboBox->Color = clMenu;
    }
    else
    {
       ResetReaderIDComboBox->Enabled = true;
       //FGenResetReaderLabel->Enabled = true;
       ResetReaderIDComboBox->Color = clWhite;
    }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ResetBroadcastRepeaterCheckBoxClick(
      TObject *Sender)
{
   if (ResetBroadcastRepeaterCheckBox->State == cbChecked)
    {
       ResetRepeaterIDEdit->ReadOnly = true;
       ResetRepeaterIDEdit->Color = clMenu;
    }
    else
    {
       ResetRepeaterIDEdit->ReadOnly = false;
       ResetRepeaterIDEdit->Color = clWhite;
    }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ResetClearBitBtnClick(TObject *Sender)
{
   ResetListView->Items->Clear();
   numReaderIDList = 0;
   for (int i=0; i<128; i++)
      readerIDList[i] = 0;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::EnableReaderBroadcastRdrCheckBoxClick(
      TObject *Sender)
{
   if (EnableReaderBroadcastRdrCheckBox->State == cbChecked)
   {
      EnableReaderIDComboBox->Color = clMenu;
      EnableReaderIDComboBox->Enabled = false;
   }
   else
   {
      EnableReaderIDComboBox->Enabled = true;
      EnableReaderIDComboBox->Color = clWhite;
   }
}
//---------------------------------------------------------------------------


void __fastcall TProgStationForm::EnableReaderGroupBoxClick(
      TObject *Sender)
{
   EnableReaderListView->Items->Clear();
   numReaderIDList = 0;
   for (int i=0; i<128; i++)
      readerIDList[i] = 0;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::DisableReaderClearBitBtnClick(
      TObject *Sender)
{
   DisableReaderListView->Items->Clear();
   numReaderIDList = 0;
   for (int i=0; i<128; i++)
      readerIDList[i] = 0;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::DisableReaderBroadcastRdrCheckBoxClick(
      TObject *Sender)
{
   if (DisableReaderBroadcastRdrCheckBox->State == cbChecked)
   {
      DisableReaderIDComboBox->Color = clMenu;
      DisableReaderIDComboBox->Enabled = false;
   }
   else
   {
      DisableReaderIDComboBox->Enabled = true;
      DisableReaderIDComboBox->Color = clWhite;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::QueryReaderBroadcastRdrCheckBoxClick(
      TObject *Sender)
{
   if (QueryReaderBroadcastRdrCheckBox->State == cbChecked)
   {
      QueryReaderIDComboBox->Color = clMenu;
      QueryReaderIDComboBox->Enabled = false;
   }
   else
   {
      QueryReaderIDComboBox->Enabled = true;
      QueryReaderIDComboBox->Color = clWhite;
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::AssignReaderBroadcastRdrCheckBoxClick(
      TObject *Sender)
{
   if (AssignReaderBroadcastRdrCheckBox->State == cbChecked)
   {
      AssignReaderIDComboBox->Color = clMenu;
      AssignReaderIDComboBox->Enabled = false;

      AssignReaderNewIDEdit->Color = clMenu;
      AssignReaderNewIDEdit->Font->Color = clGray;
      AssignReaderNewIDEdit->ReadOnly = true;

      AssignReaderNewRdrCheckBox->Enabled = false;
   }
   else
   {
      AssignReaderIDComboBox->Enabled = true;
      AssignReaderIDComboBox->Color = clWhite;

      AssignReaderNewRdrCheckBox->Enabled = true;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagNewTagTypeCheckBoxClick(
      TObject *Sender)
{
    if (ConfigTagNewTagTypeCheckBox->State == cbChecked)
    {
       //ConfigTagNewAccessRadioButton->Enabled = true;
       //ConfigTagNewAssetRadioButton->Enabled = true;
       //ConfigTagNewInventRadioButton->Enabled = true;
       ConfigTagNewTagTypeComboBox->Enabled = true;

       ConfigTagFactoryIDCheckBox->Checked = false;

       ConfigTagRNChangeRadioButton->Checked = true;
       //ConfigTagNewAnyTagRadioButton->Enabled = true;
    }
    else
    {
        ConfigTagNewTagTypeComboBox->Enabled = false;
       //ConfigTagNewAccessRadioButton->Enabled = false;
       //ConfigTagNewAssetRadioButton->Enabled = false;
       //ConfigTagNewInventRadioButton->Enabled = false;

       //ConfigTagNewAccessRadioButton->Checked = false;
       //ConfigTagNewAssetRadioButton->Checked = false;
       //ConfigTagNewInventRadioButton->Checked = false;


       //ConfigTagNewAnyTagRadioButton->Enabled = false;
    }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagTIFCheckBoxClick(
      TObject *Sender)
{
   if (ConfigTagTIFCheckBox->Checked)
   {
       ConfigTagTIFComboBox->Enabled = true;
       ConfigTagGCComboBox->Enabled = true;
       //ConfigTagTIFComboBox->Color = clWhite;
       ConfigTagFactoryIDCheckBox->Checked = false;
   }
   else
   {
       ConfigTagTIFComboBox->Enabled = false;
       ConfigTagGCComboBox->Enabled = false;
       //ConfigTagTIFComboBox->Color = clMenu;
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ConfigTagGCCheckBoxClick(TObject *Sender)
{
   if (ConfigTagGCCheckBox->Checked)
   {
       ConfigTagGCComboBox->Enabled = true;
       ConfigTagGCComboBox->Color = clWhite;
       ConfigTagFactoryIDCheckBox->Checked = false;
   }
   else
   {
       ConfigTagGCComboBox->Enabled = false;
       ConfigTagGCComboBox->Color = clMenu;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagEnableTimeCheckBoxClick(
      TObject *Sender)
{
   if (ConfigTagEnableTimeCheckBox->Checked)
   {
      ConfigTagHourRadioButton->Enabled = true;
      ConfigTagMinRadioButton->Enabled = true;
      ConfigTagSecRadioButton->Enabled = true;
      ConfigTagMSRadioButton->Enabled = true;
      ConfigTagDurationComboBox->Enabled = true;
      //ConfigTagDurationComboBox->Color = clWhite;
      ConfigTagFactoryIDCheckBox->Checked = false;
   }
   else
   {
      ConfigTagHourRadioButton->Enabled = false;
      ConfigTagMinRadioButton->Enabled = false;
      ConfigTagSecRadioButton->Enabled = false;
      ConfigTagMSRadioButton->Enabled = false;
      ConfigTagDurationComboBox->Enabled = false;
      //ConfigTagDurationComboBox->Color = clMenu;
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ConfigTagTagIDRadioButtonClick(
      TObject *Sender)
{
   ConfigTagTagIDEdit->Enabled = true;
   ConfigTagTagIDEdit->ReadOnly = false;
   ConfigTagTagIDEdit->Color = clWhite;

   ConfigTagIDRangeComboBox->Enabled = false;
   ConfigTagIDRangeComboBox->Color = clMenu;
   ConfigTagIDRangeComboBox->Font->Color = clGray;

   ConfigTagModifyRNCheckBox->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagNewTagIDCheckBoxClick(
      TObject *Sender)
{
   if (ConfigTagNewTagIDCheckBox->State == cbChecked)
   {
      //ConfigTagNewIDRadioButton->Enabled = true;
      //ConfigTagNewAnyTagIDRadioButton->Enabled = true;
      //ConfigTagNewIDRadioButton->Checked = true;
      //TagNewIDLabel->Enabled = true;
      ConfigTagNewIDEdit->ReadOnly = false;
      ConfigTagNewIDEdit->Color = clWhite;
      ConfigTagNewIDEdit->Enabled = true;
      ConfigTagFactoryIDCheckBox->Checked = false;
   }
   else
   {
      //ConfigTagNewIDRadioButton->Enabled = false;
      //ConfigTagNewAnyTagIDRadioButton->Enabled = false;
      //TagNewIDLabel->Enabled = false;
      ConfigTagNewIDEdit->ReadOnly = true;
      ConfigTagNewIDEdit->Color = clMenu;
      ConfigTagNewIDEdit->Enabled = false;
   }
}
//---------------------------------------------------------------------------


void __fastcall TProgStationForm::ConfigTagAnyTagIDRadioButtonClick(
      TObject *Sender)
{
   ConfigTagTagIDEdit->ReadOnly = true;
   ConfigTagTagIDEdit->Color = clMenu;
   ConfigTagTagIDEdit->Enabled = false;

   ConfigTagIDRangeComboBox->Enabled = false;
   ConfigTagIDRangeComboBox->Color = clMenu;
   ConfigTagIDRangeComboBox->Font->Color = clGray;

   ConfigTagModifyRNCheckBox->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagFactoryIDCheckBoxClick(
      TObject *Sender)
{
   if (ConfigTagFactoryIDCheckBox->State == cbChecked)
   {
      ConfigTagNewTagIDCheckBox->Checked = false;
      ConfigTagNewTagTypeCheckBox->Checked = false;
      ConfigTagEnableTimeCheckBox->Checked = false;
      ConfigTagTIFCheckBox->Checked = false;
      //ConfigTagGCCheckBox->Checked = false;

      ConfigTagNewTagIDCheckBox->Enabled = false;
      ConfigTagNewTagTypeCheckBox->Enabled = false;
      ConfigTagEnableTimeCheckBox->Enabled = false;
      ConfigTagTIFCheckBox->Enabled = false;
      //ConfigTagGCCheckBox->Enabled = false;

      //ConfigTagNoReportRadioButton->Enabled = false;
      //ConfigTagNoChangeRadioButton->Enabled = false;
      //ConfigTagReportStatusRadioButton->Enabled = false;
      //ConfigTagReportHistoryRadioButton->Enabled = false;

      ConfigTagRNNoChangeRadioButton->Checked = true;
      ConfigTagRNNoChangeRadioButton->Enabled = false;
      ConfigTagRNChangeRadioButton->Enabled = false;

      ConfigTagModifyRNCheckBox->Enabled = false;
      ConfigTagModifyRNCheckBox->Checked = false;
      ConfigTagModifyTamperCheckBox->Enabled = false;
      ConfigTagModifyTamperCheckBox->Checked = false;
   }
   else
   {
      ConfigTagNewTagIDCheckBox->Enabled = true;
      ConfigTagNewTagTypeCheckBox->Enabled = true;
      ConfigTagEnableTimeCheckBox->Enabled = true;
      ConfigTagTIFCheckBox->Enabled = true;
      //ConfigTagGCCheckBox->Enabled = true;

      //ConfigTagNoReportRadioButton->Enabled = true;
      //ConfigTagNoChangeRadioButton->Enabled = true;
      //ConfigTagReportStatusRadioButton->Enabled = true;
      //ConfigTagReportHistoryRadioButton->Enabled = true;

      ConfigTagRNNoChangeRadioButton->Enabled = true;
      ConfigTagRNChangeRadioButton->Enabled = true;

      ConfigTagModifyRNCheckBox->Enabled = true;
      ConfigTagModifyTamperCheckBox->Enabled = true;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagMSRadioButtonClick(
      TObject *Sender)
{
   ConfigTagDurationComboBox->Clear();
   ConfigTagDurationComboBox->Items->Add("Stop");
   ConfigTagDurationComboBox->Items->Add("330");
   ConfigTagDurationComboBox->Items->Add("660");
   ConfigTagDurationComboBox->Items->Add("990");
   ConfigTagDurationComboBox->Items->Add("1320");
   ConfigTagDurationComboBox->Items->Add("1650");
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ConfigTagHourRadioButtonClick(
      TObject *Sender)
{
   ConfigTagDurationComboBox->Clear();
   ConfigTagDurationComboBox->Items->Add("Stop");
   ConfigTagDurationComboBox->Items->Add("1");
   ConfigTagDurationComboBox->Items->Add("2");
   ConfigTagDurationComboBox->Items->Add("3");
   ConfigTagDurationComboBox->Items->Add("4");
   ConfigTagDurationComboBox->Items->Add("5");
   ConfigTagDurationComboBox->Items->Add("6");
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ConfigTagMinRadioButtonClick(
      TObject *Sender)
{
   ConfigTagDurationComboBox->Clear();
   ConfigTagDurationComboBox->Items->Add("Stop");
   ConfigTagDurationComboBox->Items->Add("1");
   ConfigTagDurationComboBox->Items->Add("2");
   ConfigTagDurationComboBox->Items->Add("3");
   ConfigTagDurationComboBox->Items->Add("4");
   ConfigTagDurationComboBox->Items->Add("5");
   ConfigTagDurationComboBox->Items->Add("6");
   ConfigTagDurationComboBox->Items->Add("7");
   ConfigTagDurationComboBox->Items->Add("8");
   ConfigTagDurationComboBox->Items->Add("9");
   ConfigTagDurationComboBox->Items->Add("10");
   ConfigTagDurationComboBox->Items->Add("11");
   ConfigTagDurationComboBox->Items->Add("12");
   ConfigTagDurationComboBox->Items->Add("13");
   ConfigTagDurationComboBox->Items->Add("14");
   ConfigTagDurationComboBox->Items->Add("15");
   ConfigTagDurationComboBox->Items->Add("16");
   ConfigTagDurationComboBox->Items->Add("17");
   ConfigTagDurationComboBox->Items->Add("18");
   ConfigTagDurationComboBox->Items->Add("19");
   ConfigTagDurationComboBox->Items->Add("20");
   ConfigTagDurationComboBox->Items->Add("21");
   ConfigTagDurationComboBox->Items->Add("22");
   ConfigTagDurationComboBox->Items->Add("23");
   ConfigTagDurationComboBox->Items->Add("24");
   ConfigTagDurationComboBox->Items->Add("25");
   ConfigTagDurationComboBox->Items->Add("26");
   ConfigTagDurationComboBox->Items->Add("27");
   ConfigTagDurationComboBox->Items->Add("28");
   ConfigTagDurationComboBox->Items->Add("29");
   ConfigTagDurationComboBox->Items->Add("30");
   ConfigTagDurationComboBox->Items->Add("31");
   ConfigTagDurationComboBox->Items->Add("32");
   ConfigTagDurationComboBox->Items->Add("33");
   ConfigTagDurationComboBox->Items->Add("34");
   ConfigTagDurationComboBox->Items->Add("35");
   ConfigTagDurationComboBox->Items->Add("36");
   ConfigTagDurationComboBox->Items->Add("37");
   ConfigTagDurationComboBox->Items->Add("38");
   ConfigTagDurationComboBox->Items->Add("39");
   ConfigTagDurationComboBox->Items->Add("40");
   ConfigTagDurationComboBox->Items->Add("41");
   ConfigTagDurationComboBox->Items->Add("42");
   ConfigTagDurationComboBox->Items->Add("43");
   ConfigTagDurationComboBox->Items->Add("44");
   ConfigTagDurationComboBox->Items->Add("45");
   ConfigTagDurationComboBox->Items->Add("46");
   ConfigTagDurationComboBox->Items->Add("47");
   ConfigTagDurationComboBox->Items->Add("48");
   ConfigTagDurationComboBox->Items->Add("49");
   ConfigTagDurationComboBox->Items->Add("50");
   ConfigTagDurationComboBox->Items->Add("51");
   ConfigTagDurationComboBox->Items->Add("52");
   ConfigTagDurationComboBox->Items->Add("53");
   ConfigTagDurationComboBox->Items->Add("54");
   ConfigTagDurationComboBox->Items->Add("55");
   ConfigTagDurationComboBox->Items->Add("56");
   ConfigTagDurationComboBox->Items->Add("57");
   ConfigTagDurationComboBox->Items->Add("58");
   ConfigTagDurationComboBox->Items->Add("59");
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ConfigTagSecRadioButtonClick(
      TObject *Sender)
{
   ConfigTagDurationComboBox->Clear();
   ConfigTagDurationComboBox->Items->Add("Stop");
   ConfigTagDurationComboBox->Items->Add("1");
   ConfigTagDurationComboBox->Items->Add("2");
   ConfigTagDurationComboBox->Items->Add("3");
   ConfigTagDurationComboBox->Items->Add("4");
   ConfigTagDurationComboBox->Items->Add("5");
   ConfigTagDurationComboBox->Items->Add("6");
   ConfigTagDurationComboBox->Items->Add("7");
   ConfigTagDurationComboBox->Items->Add("8");
   ConfigTagDurationComboBox->Items->Add("9");
   ConfigTagDurationComboBox->Items->Add("10");
   ConfigTagDurationComboBox->Items->Add("11");
   ConfigTagDurationComboBox->Items->Add("12");
   ConfigTagDurationComboBox->Items->Add("13");
   ConfigTagDurationComboBox->Items->Add("14");
   ConfigTagDurationComboBox->Items->Add("15");
   ConfigTagDurationComboBox->Items->Add("16");
   ConfigTagDurationComboBox->Items->Add("17");
   ConfigTagDurationComboBox->Items->Add("18");
   ConfigTagDurationComboBox->Items->Add("19");
   ConfigTagDurationComboBox->Items->Add("20");
   ConfigTagDurationComboBox->Items->Add("21");
   ConfigTagDurationComboBox->Items->Add("22");
   ConfigTagDurationComboBox->Items->Add("23");
   ConfigTagDurationComboBox->Items->Add("24");
   ConfigTagDurationComboBox->Items->Add("25");
   ConfigTagDurationComboBox->Items->Add("26");
   ConfigTagDurationComboBox->Items->Add("27");
   ConfigTagDurationComboBox->Items->Add("28");
   ConfigTagDurationComboBox->Items->Add("29");
   ConfigTagDurationComboBox->Items->Add("30");
   ConfigTagDurationComboBox->Items->Add("31");
   ConfigTagDurationComboBox->Items->Add("32");
   ConfigTagDurationComboBox->Items->Add("33");
   ConfigTagDurationComboBox->Items->Add("34");
   ConfigTagDurationComboBox->Items->Add("35");
   ConfigTagDurationComboBox->Items->Add("36");
   ConfigTagDurationComboBox->Items->Add("37");
   ConfigTagDurationComboBox->Items->Add("38");
   ConfigTagDurationComboBox->Items->Add("39");
   ConfigTagDurationComboBox->Items->Add("40");
   ConfigTagDurationComboBox->Items->Add("41");
   ConfigTagDurationComboBox->Items->Add("42");
   ConfigTagDurationComboBox->Items->Add("43");
   ConfigTagDurationComboBox->Items->Add("44");
   ConfigTagDurationComboBox->Items->Add("45");
   ConfigTagDurationComboBox->Items->Add("46");
   ConfigTagDurationComboBox->Items->Add("47");
   ConfigTagDurationComboBox->Items->Add("48");
   ConfigTagDurationComboBox->Items->Add("49");
   ConfigTagDurationComboBox->Items->Add("50");
   ConfigTagDurationComboBox->Items->Add("51");
   ConfigTagDurationComboBox->Items->Add("52");
   ConfigTagDurationComboBox->Items->Add("53");
   ConfigTagDurationComboBox->Items->Add("54");
   ConfigTagDurationComboBox->Items->Add("55");
   ConfigTagDurationComboBox->Items->Add("56");
   ConfigTagDurationComboBox->Items->Add("57");
   ConfigTagDurationComboBox->Items->Add("58");
   ConfigTagDurationComboBox->Items->Add("59");
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::RNChangeRadioButtonClick(TObject *Sender)
{
   RNShortRadioButton->Enabled = true;
   RNLongRadioButton->Enabled = true;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::RNNoChangeRadioButtonClick(
      TObject *Sender)
{
   RNShortRadioButton->Enabled = false;
   RNLongRadioButton->Enabled = false;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ConfigTagRNChangeRadioButtonClick(
      TObject *Sender)
{
   ConfigTagRNShortRadioButton->Enabled = true;
   ConfigTagRNLongRadioButton->Enabled = true;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ConfigTagRNNoChangeRadioButtonClick(
      TObject *Sender)
{
   ConfigTagRNShortRadioButton->Enabled = false;
   ConfigTagRNLongRadioButton->Enabled = false;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::EnableTagListViewColumnClick(
      TObject *Sender, TListColumn *Column)
{
   columnToSort = Column->Index;
  ((TCustomListView *)Sender)->AlphaSort();
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::EnableTagListViewCompare(TObject *Sender,
      TListItem *Item1, TListItem *Item2, int Data, int &Compare)
{
   AnsiString selectedItem1;
   AnsiString selectedItem2;
   TStrings* str;
   int n1, n2;

   if (columnToSort == 1)
   {
      str = Item1->SubItems;
      selectedItem1 = GetItem(str, 0);

      str = Item2->SubItems;
      selectedItem2 = GetItem(str, 0);

      Compare = CompareText(selectedItem1, selectedItem2);
   }
   else if (columnToSort == 2)
   {
      str = Item1->SubItems;
      selectedItem1 = GetItem(str, 1);

      str = Item2->SubItems;
      selectedItem2 = GetItem(str, 1);

      n1 = atoi(selectedItem1.c_str());
      n2 = atoi(selectedItem2.c_str());
      if (n1 == n2)
         Compare = 0;
      else if (n1 > n2)
         Compare = 1;
      else
         Compare = -1;
   }
   else
      Compare = 0;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::EnableTagClearBitBtnClick(
      TObject *Sender)
{
   EnableTagListView->Items->Clear();
   eTagType01Count = 0;
   eTagType02Count = 0;
   eTagType03Count = 0;
   eTagType04Count = 0;
   eTagType05Count = 0;
   eTagType06Count = 0;
   eTagFactCount = 0;
   eTagTotalCount = 0;
   arrayIndexEnabled = 0;
   EnableTagType01Label->Caption = "0";
   EnableTagType02Label->Caption = "0";
   EnableTagType03Label->Caption = "0";
   EnableTagType04Label->Caption = "0";
   EnableTagType05Label->Caption = "0";
   EnableTagType06Label->Caption = "0";
   EnableTagFactoryLabel->Caption = "0";

   /*EnableTagAccLabel->Caption = "0";
   EnableTagAssLabel->Caption = "0";
   EnableTagInvLabel->Caption = "0";
   EnableTagFactoryLabel->Caption = "0";*/
   EnableTagTotalLabel->Caption = "0";
}
//---------------------------------------------------------------------------


void __fastcall TProgStationForm::DisableAnyTagIDRadioButtonClick(
      TObject *Sender)
{
   DisableTagIDEdit->ReadOnly = true;
   DisableTagIDEdit->Color = clMenu;
   DisableTagIDEdit->Enabled = false;

   DisableTagIDRangeComboBox->Color = clMenu;
   DisableTagIDRangeComboBox->Enabled = false;
   DisableTagIDRangeComboBox->Font->Color = clGray;

   DisableTagRNLongRadioButton->Enabled = true;
   DisableTagRNShortRadioButton->Enabled = true;
   DisableTagEnableLEDRadioButton->Enabled = true;
   DisableTagDisableLEDRadioButton->Enabled = true;
   DisableTagEnableSpeakerRadioButton->Enabled = true;
   DisableTagDisableSpeakerRadioButton->Enabled = true;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::DisableTagIDRadioButtonClick(
      TObject *Sender)
{
   DisableTagIDEdit->ReadOnly = false;
   DisableTagIDEdit->Color = clWhite;
   DisableTagIDEdit->Enabled = true;

   DisableTagIDRangeComboBox->Color = clMenu;
   DisableTagIDRangeComboBox->Enabled = false;
   DisableTagIDRangeComboBox->Font->Color = clGray;

   DisableTagRNLongRadioButton->Enabled = true;
   DisableTagRNShortRadioButton->Enabled = true;
   DisableTagEnableLEDRadioButton->Enabled = true;
   DisableTagDisableLEDRadioButton->Enabled = true;
   DisableTagEnableSpeakerRadioButton->Enabled = true;
   DisableTagDisableSpeakerRadioButton->Enabled = true;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::EnableTagIDRadioButtonClick(
      TObject *Sender)
{
   EnableTagIDEdit->ReadOnly = false;
   EnableTagIDEdit->Color = clWhite;
   EnableTagIDEdit->Enabled = true;
   EnableTagIDRangeComboBox->Color = clMenu;
   EnableTagIDRangeComboBox->Enabled = false;
   EnableTagIDRangeComboBox->Font->Color = clGray;

   EnableTagRNLongRadioButton->Enabled = true;
   EnableTagRNShortRadioButton->Enabled = true;
   EnableTagEnableLEDRadioButton->Enabled = true;
   EnableTagDisableLEDRadioButton->Enabled = true;
   EnableTagEnableSpeakerRadioButton->Enabled = true;
   EnableTagDisableSpeakerRadioButton->Enabled = true;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::EnableAnyTagIDRadioButtonClick(
      TObject *Sender)
{
   EnableTagIDEdit->ReadOnly = true;
   EnableTagIDEdit->Color = clMenu;
   EnableTagIDEdit->Enabled = false;

   EnableTagIDRangeComboBox->Color = clMenu;
   EnableTagIDRangeComboBox->Enabled = false;
   EnableTagIDRangeComboBox->Font->Color = clGray;

   EnableTagRNLongRadioButton->Enabled = true;
   EnableTagRNShortRadioButton->Enabled = true;
   EnableTagEnableLEDRadioButton->Enabled = true;
   EnableTagDisableLEDRadioButton->Enabled = true;
   EnableTagEnableSpeakerRadioButton->Enabled = true;
   EnableTagDisableSpeakerRadioButton->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::DisableTagClearBitBtnClick(
      TObject *Sender)
{
   DisableTagListView->Items->Clear();
   dTagType01Count = 0;
   dTagType02Count = 0;
   dTagType03Count = 0;
   dTagType04Count = 0;
   dTagType05Count = 0;
   dTagType06Count = 0;
   dTagFactCount = 0;
   dTagTotalCount = 0;
   arrayIndexDisabled = 0;
   /*DisableTagAccLabel->Caption = "0";
   DisableTagAssLabel->Caption = "0";
   DisableTagInvLabel->Caption = "0";
   DisableTagFactLabel->Caption = "0";
   DisableTagTotalLabel->Caption = "0";*/

   DisableTagType01Label->Caption = "0";
   DisableTagType02Label->Caption = "0";
   DisableTagType03Label->Caption = "0";
   DisableTagType04Label->Caption = "0";
   DisableTagType05Label->Caption = "0";
   DisableTagType06Label->Caption = "0";
   DisableTagFactoryLabel->Caption = "0";
   DisableTagTotalLabel->Caption = "0";
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::AssignReaderListViewColumnClick(
      TObject *Sender, TListColumn *Column)
{
    columnToSort = Column->Index;
   ((TCustomListView *)Sender)->AlphaSort();
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::AssignReaderListViewCompare(
      TObject *Sender, TListItem *Item1, TListItem *Item2, int Data,
      int &Compare)
{
    AnsiString selectedItem1;
    AnsiString selectedItem2;
    TStrings* str;
    int n1, n2;

    if (columnToSort == 1)  //FGen
    {
       str = Item1->SubItems;
       selectedItem1 = GetItem(str, 0);

       str = Item2->SubItems;
       selectedItem2 = GetItem(str, 0);

       n1 = atoi(selectedItem1.c_str());
       n2 = atoi(selectedItem2.c_str());
       if (n1 == n2)
            Compare = 0;
       else if (n1 > n2)
            Compare = 1;
       else
           Compare = -1;
    }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::QueryReaderListViewColumnClick(
      TObject *Sender, TListColumn *Column)
{
   columnToSort = Column->Index;
   ((TCustomListView *)Sender)->AlphaSort();
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::QueryReaderListViewCompare(
      TObject *Sender, TListItem *Item1, TListItem *Item2, int Data,
      int &Compare)
{
    int index;
    AnsiString selectedItem1;
    AnsiString selectedItem2;
    AnsiString s;
    TStrings* str;
    int n1, n2;

    if (columnToSort == 1)  //ID
    {
       str = Item1->SubItems;
       selectedItem1 = GetItem(str, 0);

       str = Item2->SubItems;
       selectedItem2 = GetItem(str, 0);

       n1 = atoi(selectedItem1.c_str());
       n2 = atoi(selectedItem2.c_str());
       if (n1 == n2)
          Compare = 0;
       else if (n1 > n2)
          Compare = 1;
       else
          Compare = -1;
    }
    else if (columnToSort == 2) //type
    {
       str = Item1->SubItems;

       selectedItem1 = GetItem(str, 1);
       str = Item2->SubItems;

       selectedItem2 = GetItem(str, 1);
       Compare = CompareText(selectedItem1, selectedItem2);
    }
    else if (columnToSort == 3) //broadcast
    {
       str = Item1->SubItems;
       selectedItem1 = GetItem(str, 2);
       str = Item2->SubItems;
       selectedItem2 = GetItem(str, 2);
       Compare = CompareText(selectedItem1, selectedItem2);
    }
    else if (columnToSort == 4)  //enable at power up
    {
       str = Item1->SubItems;
       selectedItem1 = GetItem(str, 3);
       str = Item2->SubItems;
       selectedItem2 = GetItem(str, 3);
       Compare = CompareText(selectedItem1, selectedItem2);
    }
    else if (columnToSort == 5)  //send RSSI
    {
       str = Item1->SubItems;
       selectedItem1 = GetItem(str, 4);
       str = Item2->SubItems;
       selectedItem2 = GetItem(str, 4);
       Compare = CompareText(selectedItem1, selectedItem2);
    }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::DisableReaderListViewColumnClick(
      TObject *Sender, TListColumn *Column)
{
   columnToSort = Column->Index;
   ((TCustomListView *)Sender)->AlphaSort();
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::DisableReaderListViewCompare(
      TObject *Sender, TListItem *Item1, TListItem *Item2, int Data,
      int &Compare)
{
    AnsiString selectedItem1;
    AnsiString selectedItem2;
    TStrings* str;
    int n1, n2;

    if (columnToSort == 1)  //FGen
    {
       str = Item1->SubItems;
       selectedItem1 = GetItem(str, 0);

       str = Item2->SubItems;
       selectedItem2 = GetItem(str, 0);

       n1 = atoi(selectedItem1.c_str());
       n2 = atoi(selectedItem2.c_str());
       if (n1 == n2)
            Compare = 0;
       else if (n1 > n2)
            Compare = 1;
       else
           Compare = -1;
    }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::EnableReaderListViewColumnClick(
      TObject *Sender, TListColumn *Column)
{
   columnToSort = Column->Index;
   ((TCustomListView *)Sender)->AlphaSort();
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::EnableReaderListViewCompare(
      TObject *Sender, TListItem *Item1, TListItem *Item2, int Data,
      int &Compare)
{
    AnsiString selectedItem1;
    AnsiString selectedItem2;
    TStrings* str;
    int n1, n2;

    if (columnToSort == 1)  //FGen
    {
       str = Item1->SubItems;
       selectedItem1 = GetItem(str, 0);

       str = Item2->SubItems;
       selectedItem2 = GetItem(str, 0);

       n1 = atoi(selectedItem1.c_str());
       n2 = atoi(selectedItem2.c_str());
       if (n1 == n2)
            Compare = 0;
       else if (n1 > n2)
            Compare = 1;
       else
           Compare = -1;
    }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ResetListViewColumnClick(TObject *Sender,
      TListColumn *Column)
{
   columnToSort = Column->Index;
   ((TCustomListView *)Sender)->AlphaSort();
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ResetListViewCompare(TObject *Sender,
      TListItem *Item1, TListItem *Item2, int Data, int &Compare)
{
    AnsiString selectedItem1;
    AnsiString selectedItem2;
    TStrings* str;
    int n1, n2;

    if (columnToSort == 1)  //FGen
    {
       str = Item1->SubItems;
       selectedItem1 = GetItem(str, 0);

       str = Item2->SubItems;
       selectedItem2 = GetItem(str, 0);

       n1 = atoi(selectedItem1.c_str());
       n2 = atoi(selectedItem2.c_str());
       if (n1 == n2)
            Compare = 0;
       else if (n1 > n2)
            Compare = 1;
       else
           Compare = -1;
    }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagRNDListViewColumnClick(
      TObject *Sender, TListColumn *Column)
{
   columnToSort = Column->Index;
   ((TCustomListView *)Sender)->AlphaSort();
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagRNDListViewCompare(
      TObject *Sender, TListItem *Item1, TListItem *Item2, int Data,
      int &Compare)
{
    AnsiString selectedItem1;
    AnsiString selectedItem2;
    TStrings* str;
    int n1, n2;

    if (columnToSort == 1)
    {
       str = Item1->SubItems;
       selectedItem1 = GetItem(str, 0);
       str = Item2->SubItems;
       selectedItem2 = GetItem(str, 0);
       Compare = CompareText(selectedItem1, selectedItem2);
    }
    else if (columnToSort == 2)
    {
       str = Item1->SubItems;
       selectedItem1 = GetItem(str, 1);

       str = Item2->SubItems;
       selectedItem2 = GetItem(str, 1);

       n1 = atoi(selectedItem1.c_str());
       n2 = atoi(selectedItem2.c_str());
       if (n1 == n2)
            Compare = 0;
       else if (n1 > n2)
            Compare = 1;
       else
           Compare = -1;
    }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::AssignTagRdrListViewColumnClick(
      TObject *Sender, TListColumn *Column)
{
    columnToSort = Column->Index;
   ((TCustomListView *)Sender)->AlphaSort();
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::AssignTagRdrListViewCompare(
      TObject *Sender, TListItem *Item1, TListItem *Item2, int Data,
      int &Compare)
{
    AnsiString selectedItem1;
    AnsiString selectedItem2;
    TStrings* str;
    int n1, n2;

    if (columnToSort == 1)
    {
       str = Item1->SubItems;
       selectedItem1 = GetItem(str, 0);
       str = Item2->SubItems;
       selectedItem2 = GetItem(str, 0);
       Compare = CompareText(selectedItem1, selectedItem2);
    }
    else if (columnToSort == 2)
    {
       str = Item1->SubItems;
       selectedItem1 = GetItem(str, 1);

       str = Item2->SubItems;
       selectedItem2 = GetItem(str, 1);

       n1 = atoi(selectedItem1.c_str());
       n2 = atoi(selectedItem2.c_str());
       if (n1 == n2)
            Compare = 0;
       else if (n1 > n2)
            Compare = 1;
       else
           Compare = -1;
    }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::QueryAnyTagIDRadioButtonClick(
      TObject *Sender)
{
   QueryTagIDEdit->ReadOnly = true;
   QueryTagIDEdit->Color = clMenu;
   QueryTagIDEdit->Enabled = false;

   QueryTagIDRangeComboBox->Enabled = false;
   QueryTagIDRangeComboBox->Color = clMenu;
   QueryTagIDRangeComboBox->Font->Color = clGray;

   QueryTagRNLongRadioButton->Enabled = true;
   QueryTagRNShortRadioButton->Enabled = true;

   QueryTagEnableLEDRadioButton->Enabled = true;
   QueryTagDisableLEDRadioButton->Enabled = true;

   QueryTagEnableSpeakerRadioButton->Enabled = true;
   QueryTagDisableSpeakerRadioButton->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::QueryTagIDRadioButtonClick(
      TObject *Sender)
{
   QueryTagIDEdit->ReadOnly = false;
   QueryTagIDEdit->Color = clWhite;
   QueryTagIDEdit->Enabled = true;

   QueryTagIDRangeComboBox->Enabled = false;
   QueryTagIDRangeComboBox->Color = clMenu;
   QueryTagIDRangeComboBox->Font->Color = clGray;

   QueryTagRNLongRadioButton->Enabled = true;
   QueryTagRNShortRadioButton->Enabled = true;

   QueryTagEnableLEDRadioButton->Enabled = true;
   QueryTagDisableLEDRadioButton->Enabled = true;

   QueryTagEnableSpeakerRadioButton->Enabled = true;
   QueryTagDisableSpeakerRadioButton->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::CallTagAnyTagIDRadioButtonClick(
      TObject *Sender)
{
   CallTagIDEdit->ReadOnly = true;
   CallTagIDEdit->Color = clMenu;
   CallTagIDEdit->Enabled = false;

   CallTagIDRangeComboBox->Color = clMenu;
   CallTagIDRangeComboBox->Enabled = false;
   CallTagIDRangeComboBox->Font->Color = clGray;

   CallTagRNLongRadioButton->Enabled = true;
   CallTagRNShortRadioButton->Enabled = true;

   CallTagEnableSpeakerRadioButton->Enabled = true;
   CallTagDisableSpeakerRadioButton->Enabled = true;

   CallTagEnableLEDRadioButton->Enabled = true;
   CallTagDisableLEDRadioButton->Enabled = true;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::AssignReaderClearBitBtnClick(
      TObject *Sender)
{
   numReaderIDList = 0;
   for (int i=0; i<128; i++)
      readerIDList[i] = 0;
   AssignReaderListView->Items->Clear();
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::EnableReaderClearBitBtnClick(
      TObject *Sender)
{
   numReaderIDList = 0;
   for (int i=0; i<128; i++)
      readerIDList[i] = 0;
   EnableReaderListView->Items->Clear();
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::DisableTagListViewColumnClick(
      TObject *Sender, TListColumn *Column)
{
   columnToSort = Column->Index;
  ((TCustomListView *)Sender)->AlphaSort();
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::DisableTagListViewCompare(
      TObject *Sender, TListItem *Item1, TListItem *Item2, int Data,
      int &Compare)
{
   AnsiString selectedItem1;
   AnsiString selectedItem2;
   TStrings* str;
   int n1, n2;

   if (columnToSort == 1)
   {
      str = Item1->SubItems;
      selectedItem1 = GetItem(str, 0);

      str = Item2->SubItems;
      selectedItem2 = GetItem(str, 0);

      Compare = CompareText(selectedItem1, selectedItem2);
   }
   else if (columnToSort == 2)
   {
      str = Item1->SubItems;
      selectedItem1 = GetItem(str, 1);

      str = Item2->SubItems;
      selectedItem2 = GetItem(str, 1);

      n1 = atoi(selectedItem1.c_str());
      n2 = atoi(selectedItem2.c_str());
      if (n1 == n2)
         Compare = 0;
      else if (n1 > n2)
         Compare = 1;
      else
         Compare = -1;
   }
   else
      Compare = 0;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::QueryReaderClearBitBtnClick(
      TObject *Sender)
{
   QueryReaderListView->Items->Clear();
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::ReaderFgenToolButtonClick(
      TObject *Sender)
{
   if (readerFgenButtonActivated)
   {
      ReaderFgenToolButton->Hint = "Set Programming Station To Field Generator Mode";
      readerFgenButtonActivated = false;
      if(networkOn)
         CloseNetworkConnection();
      else if (RS232On)
         ClosePort();
      EnableAllCommands(false);
      if (OpenSerial(comPort, lastBaudrate))
      {
         ProgStationForm->PortOpen = true;
         baudRate = curBaudrate = lastBaudrate;
         StaticText->Caption = "Programming Station In Reader Mode";
         PlaySound("Ding.wav", NULL, SND_ASYNC );
      }
      EnableAllCommands(true);
      fieldGenOffLine = true;
      fieldGenOnLine = false;
      readerOffLine = true;
      readerOnLine = false;
   }
   else
   {
      ReaderFgenToolButton->Hint = "Programming Station Is In Field Generator Mode";
      readerFgenButtonActivated = true;
      StaticText->Caption = "Programming Station In STD Field Gen Mode(9600 baudrate)";
      ClosePort();
      lastBaudrate = baudRate;
      baudRate = 9600;
      EnableAllCommands(false);
      if (OpenSerial(comPort, baudRate))
      {
         ProgStationForm->PortOpen = true;
         curBaudrate = baudRate;
         StaticText->Caption = "Programming Station In Field Generator Mode";
         PlaySound("Ding.wav", NULL, SND_ASYNC );
      }
      EnableAllCommands(true);
      fieldGenOffLine = true;
      fieldGenOnLine = false;
      readerOffLine = true;
      readerOnLine = false;
   }
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::GotoConfigFGenPage()
{
   if (!ConfigFGenGroupBox->Visible)
   {
      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = true;
      ConfigSFGenGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      //GeneralGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //ConfigTxTimeStaticText->Visible = true;
   ConfigFGenStaticText->Visible = false;
   QueryFGenStaticText->Visible = true;
   //EnableFGenStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = true;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;

   //if (lastHostID <= 0)
      //FGenConfigHostIDEdit->Text = "";
   //else
      //FGenConfigHostIDEdit->Text = lastHostID;
   if (allHostID)
   {
      if (lastHostID > 0)
         FGenConfigHostIDEdit->Text = lastHostID;
   }
   else
      FGenConfigHostIDEdit->Text = sysHostID;


   //FGenReaderIDComboBox->Items->Clear();
   //for (int i=0; i<numReaderIDList; i++)
      //FGenReaderIDComboBox->Items->Add(readerIDList[i]);

   //if (lastReaderID <= 0)
      //FGenReaderIDComboBox->Text = "";
   //else
      //FGenReaderIDComboBox->Text = lastReaderID;

   //Reset Device  0x01
   TxClearTagCtrls();
   RxClearTagCtrls();
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::HideAllCommandBtns()
{
                                              //READER
                                              //=============
   ResetDeviceBitBtn->Visible = false;        //Reset Reader
   EnableReaderBitBtn->Visible = false;       //Enable Reader
   DisableReaderBitBtn->Visible = false;      //Disable Reader
   QueryReaderBitBtn->Visible = false;        //Query Reader
   AssignReaderBitBtn->Visible = false;       //Config Reader
   ReaderVersion->Visible = false;            //Get Version Reader
   //EnableFGenBitBtn->Visible = false;         //Enable Transmitter
   RelayBitBtn->Visible = false;              //Output Realay
   InputsBitBtn->Visible = false;             //Input Status
   SetFStrengthBitBtn->Visible = false;       //Set Field Strength
   DownloadRdrBitBtn->Visible = false;        //Download


                                              //STD FIELD GEN
                                              //===============
   QueryFGenBitBtn->Visible = false;          //Query
   ConfigFGenBitBtn->Visible = false;         //Configure

                                              //SMART FIELD GEN
                                              //================
   FGenResetBitBtn->Visible = false;          //Reset
   QuerySFGenBitBtn->Visible = false;         //Query
   ConfigSFGenBitBtn->Visible = false;        //Configure
   SmartFGenBitBtn->Visible = false;          //Call
   DownloadSFGenBitBtn->Visible = false;      //Download

                                             //TAG
                                             //================
   EnableTagBitBtn->Visible = false;         //Enable
   DisableTagBitBtn->Visible = false;        //Disable
   ConfigTagBitBtn->Visible = false;         //Config
   QueryTagBitBtn->Visible = false;          //Query
   CallTagBitBtn->Visible = false;           //Cal
   AssignTagRdrBitBtn->Visible = false;      //Assign reader
   ConfigTagRNDBitBtn->Visible = false;      //Config RND
   ReadMemoryBitBtn->Visible = false;        //Read Memory
   WriteMemoryBitBtn->Visible = false;       //Write Memory
   TagTempBitBtn->Visible = false;           //Config Temp
   ConfigTagLEDBitBtn->Visible = false;      //Tag LED

}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::EnableAllCommands(bool b)
{
                                                 //READER
                                                 //=============
   ResetReaderStaticText->Enabled = b;        //Reset Reader
   EnableReaderStaticText->Enabled = b;       //Enable Reader
   DisableReaderStaticText->Enabled = b;      //Disable Reader
   QueryReaderStaticText->Enabled = b;        //Query Reader

   AssignReaderStaticText->Enabled = b;       //Config Reader
   ReaderVersionStaticText->Enabled = b;      //Get Version Reader
   //EnableRdrFGenStaticText->Enabled = b;      //Enable Transmitter
   RelayStaticText->Enabled = b;              //Output Realay
   InputsStaticText->Enabled = b;             //Input Status
   SetFStrengthStaticText->Enabled = b;       //Set Field Strength
  // DownloadRdrStaticText->Enabled = b;        //Download

                                                 //STD FIELD GEN
                                                 //===============
   QueryFGenStaticText->Enabled = b;          //Query
   ConfigFGenStaticText->Enabled = b;         //Configure

                                                 //SMART FIELD GEN
                                                 //================
   FGenResetStaticText->Enabled = b;          //Reset
   QuerySFGenStaticText->Enabled = b;         //Query
   ConfigSFGenStaticText->Enabled = b;        //Configure
   SmartFGenStaticText->Enabled = b;          //Call
   ////DownloadSmartFGenStaticText->Enabled = b;  //Download

                                              //TAG
                                             //================
   EnableTagStaticText->Enabled = b;         //Enable
   DisableTagStaticText->Enabled = b;        //Disable
   ConfigTagStaticText->Enabled = b;         //Config
   QueryTagStaticText->Enabled = b;          //Query
   CallTagStaticText->Enabled = b;           //Cal
   AssignTagRdrStaticText->Enabled = b;      //Assign reader
   ConfigTagRNDStaticText->Enabled = b;      //Config RND
   ReadMemoryStaticText->Enabled = b;        //Read Memory
   WriteMemoryStaticText->Enabled = b;       //Write Memory
   TagTempStaticText->Enabled = b;           //Config Temp
   TagTempReadTempValueBitBtn->Enabled = b;  //get Config Temp button
   TagTempRefreshBitBtn->Enabled = b;        //Refresh temp button
   ConfigTagLEDStaticText->Enabled = b;      //Tag LED
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::FGenConfigAssignedReaderIDModifyCheckBoxClick(
      TObject *Sender)
{
    if (FGenConfigAssignedReaderIDModifyCheckBox->Checked)
    {
       FGenConfigAssignedReaderIDEdit->ReadOnly = false;
       FGenConfigAssignedReaderIDEdit->Color = clWhite;
       FGenConfigAssignedReaderIDEdit->Font->Color = clBlue;
       FGenConfigAssignedReaderIDModifyCheckBox->Font->Color = clRed;

       FGenConfigFGenIDModifyCheckBox->Checked = false;
       FGenConfigFGenIDModifyCheckBox->Font->Color = clOlive;
       FGenConfigFGenIDModifyCheckBox->Enabled = false;

       FGenConfigFGenIDEdit->ReadOnly = true;
       FGenConfigFGenIDEdit->Text = "";
       FGenConfigFGenIDEdit->Color = clMenu;
       FGenConfigFGenIDEdit->Font->Color = clGray;
    }
    else
    {
       FGenConfigAssignedReaderIDEdit->ReadOnly = true;
       FGenConfigAssignedReaderIDEdit->Color = clMenu;
       FGenConfigAssignedReaderIDEdit->Font->Color = clGray;
       FGenConfigAssignedReaderIDModifyCheckBox->Font->Color = clOlive;

       FGenConfigFGenIDModifyCheckBox->Enabled = true;
       //FGenConfigReaderIDEdit->Text = "";
    }
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::FGenConfigFGenIDModifyCheckBoxClick(
      TObject *Sender)
{
    if (FGenConfigFGenIDModifyCheckBox->Checked)
    {
       FGenConfigFGenIDEdit->ReadOnly = false;
       FGenConfigFGenIDEdit->Color = clWhite;
       FGenConfigFGenIDEdit->Font->Color = clBlue;
       FGenConfigFGenIDModifyCheckBox->Font->Color = clRed;

       FGenConfigAssignedReaderIDModifyCheckBox->Checked = false;
       FGenConfigAssignedReaderIDModifyCheckBox->Font->Color = clOlive;
       FGenConfigAssignedReaderIDModifyCheckBox->Enabled = false;

       FGenConfigAssignedReaderIDEdit->ReadOnly = true;
       FGenConfigAssignedReaderIDEdit->Text = "";
       FGenConfigAssignedReaderIDEdit->Color = clMenu;
       FGenConfigAssignedReaderIDEdit->Font->Color = clGray;
    }
    else
    {
       FGenConfigFGenIDEdit->ReadOnly = true;
       FGenConfigFGenIDEdit->Color = clMenu;
       FGenConfigFGenIDEdit->Font->Color = clGray;
       FGenConfigFGenIDModifyCheckBox->Font->Color = clOlive;

       FGenConfigAssignedReaderIDModifyCheckBox->Enabled = true;
    }
}
//------------------------------------------------------------------------------

void __fastcall TProgStationForm::FGenConfigTagTypeModifyCheckBoxClick(
      TObject *Sender)
{
    if (FGenConfigTagTypeModifyCheckBox->Checked)
    {
       FGenConfigTagTypeComboBox->Enabled = true;
       FGenConfigLEDCheckBox->Enabled = true;
       FGenConfigSPKCheckBox->Enabled = true;

       FGenConfigRaRnModifyCheckBox->Checked = true;
       FGenConfigTagTypeModifyCheckBox->Font->Color = clRed;

       /*FGenConfigAccessRadioButton->Enabled = true;
       FGenConfigAssetRadioButton->Enabled = true;
       FGenConfigInventoryRadioButton->Enabled = true;
       FGenConfigAnyTypeRadioButton->Enabled = true;
       //FGenConfigRaRnModifyCheckBox->Checked = true;
       FGenConfigTagTypeModifyCheckBox->Font->Color = clRed;*/
    }
    else
    {
       FGenConfigTagTypeComboBox->Enabled = false;
       FGenConfigLEDCheckBox->Enabled = false;
       FGenConfigSPKCheckBox->Enabled = false;

       FGenConfigRaRnModifyCheckBox->Checked = false;
       FGenConfigTagTypeModifyCheckBox->Font->Color = clOlive;

       /*FGenConfigAccessRadioButton->Enabled = false;
       FGenConfigAssetRadioButton->Enabled = false;
       FGenConfigInventoryRadioButton->Enabled = false;
       FGenConfigAnyTypeRadioButton->Enabled = false;
       //FGenConfigRaRnModifyCheckBox->Checked = false;
       FGenConfigTagTypeModifyCheckBox->Font->Color = clOlive;*/
    }
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::FGenConfigTagIDModifyCheckBoxClick(
      TObject *Sender)
{
    if (FGenConfigTagIDModifyCheckBox->Checked)
    {
       FGenConfigTagIDRadioButton->Enabled = true;
       FGenConfigAnyTagIDRadioButton->Enabled = true;
       FGenConfigTagIDModifyCheckBox->Font->Color = clRed;

       if (FGenConfigTagIDRadioButton->Checked)
       {
          FGenConfigTagIDEdit->ReadOnly = false;
          FGenConfigTagIDEdit->Color = clWhite;
          FGenConfigTagIDEdit->Font->Color = clBlue;
          //FGenConfigTagIDModifyCheckBox->Font->Color = clRed;
       }
       else
       {
          FGenConfigTagIDEdit->ReadOnly = true;
          FGenConfigTagIDEdit->Color = clMenu;
          FGenConfigTagIDEdit->Font->Color = clGray;
          //FGenConfigTagIDModifyCheckBox->Font->Color = clOlive;
       }
    }
    else
    {
       FGenConfigTagIDRadioButton->Enabled = false;
       FGenConfigAnyTagIDRadioButton->Enabled = false;
       FGenConfigTagIDModifyCheckBox->Font->Color = clOlive;

       FGenConfigTagIDEdit->ReadOnly = true;
       FGenConfigTagIDEdit->Color = clMenu;
       FGenConfigTagIDEdit->Font->Color = clGray;
       FGenConfigTagIDEdit->Text = "";
    }
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::FGenConfigTxTimeModifyCheckBoxClick(
      TObject *Sender)
{
    if (FGenConfigTxTimeModifyCheckBox->Checked)
    {
       //FGenConfigDefaultTimeCheckBox->Checked = false;
       //FGenConfigActivePIRCheckBox->Enabled = true;
       //FGenConfigMonitorPIRCheckBox->Enabled = true;
       FGenConfigTxTimeComboBox->Enabled = true;
       FGenConfigMDCheckBox->Checked = true;
       FGenConfigTxTimeModifyCheckBox->Font->Color = clRed;
    }
    else
    {
       //FGenConfigActivePIRCheckBox->Enabled = false;
       //FGenConfigTxTimeComboBox->Enabled = false;
       //FGenConfigMonitorPIRCheckBox->Enabled = false;
       FGenConfigTxTimeModifyCheckBox->Font->Color = clOlive;
       //FGenConfigTxTimeComboBox->Text = "";
       FGenConfigTxTimeComboBox->Enabled = false;
       FGenConfigMDCheckBox->Checked = false;
       FGenConfigMDCheckBox->Checked = false;
    }
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::FGenConfigWaitTimeModifyCheckBoxClick(
      TObject *Sender)
{
    if (FGenConfigWaitTimeModifyCheckBox->Checked)
    {
       FGenConfigDefaultTimeCheckBox->Checked = false;

       FGenConfigWaitTimeSecRadioButton->Enabled = true;
       FGenConfigWaitTimeMinRadioButton->Enabled = true;
       FGenConfigWaitTimeHourRadioButton->Enabled = true;

       //FGenConfigWaitTimeAllRadioButton->Enabled = true;

       if (stdFGenType == 0x01)
       {
          //FGenConfigHoldTimeCheckBox->Enabled = true;
          FGenConfigHoldTimeComboBox->Enabled = true;
          FGenConfigWaitTimeComboBox->Enabled = true;
          //FGenConfigEnableISCheckBox->Enabled = true;
       }
       else
       {
          //FGenConfigHoldTimeCheckBox->Enabled = false;
          FGenConfigHoldTimeComboBox->Enabled = false;
          FGenConfigWaitTimeComboBox->Enabled = true;
          //FGenConfigEnableISCheckBox->Enabled = false;
       }

       //FGenConfigWaitTimeCheckBox->Enabled = true;
       /////FGenConfigWaitTimeComboBox->Enabled = true;

       FGenConfigWaitTimeModifyCheckBox->Font->Color = clRed;
    }
    else
    {
       FGenConfigWaitTimeSecRadioButton->Enabled = false;
       FGenConfigWaitTimeMinRadioButton->Enabled = false;
       FGenConfigWaitTimeHourRadioButton->Enabled = false;

       //FGenConfigWaitTimeAllRadioButton->Enabled = false;
       FGenConfigWaitTimeComboBox->Enabled = false;
       FGenConfigHoldTimeComboBox->Enabled = false;

       //FGenConfigWaitTimeCheckBox->Checked = false;
       //FGenConfigHoldTimeCheckBox->Checked = false;

       //FGenConfigWaitTimeCheckBox->Enabled = false;
       //FGenConfigHoldTimeCheckBox->Enabled = false;

       //FGenConfigHoldTimeComboBox->Enabled = false;

       /*FGenConfigWaitTimeCheckBox->Enabled = false;
       //FGenConfigWaitTimeCheckBox->Checked = false;
       //FGenConfigHoldTimeCheckBox->Enabled = false;

       FGenConfigHoldTimeCheckBox->Enabled = false;
       FGenConfigHoldTimeComboBox->Enabled = false;

       //FGenConfigWaitTimeComboBox->Enabled = false;
       //FGenConfigWaitTimeCheckBox->Enabled = false;

       //FGenConfigTxTimeComboBox->Text = "";
       //FGenConfigTxTimeComboBox->Text = "";
       */

       FGenConfigWaitTimeModifyCheckBox->Font->Color = clOlive;
    }
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::FGenConfigTagIDRadioButtonClick(
      TObject *Sender)
{
   FGenConfigTagIDRadioButton->Enabled = true;
   //FGenConfigAnyTagIDRadioButton->Enabled = false;
   FGenConfigTagIDEdit->ReadOnly = false;
   FGenConfigTagIDEdit->Color = clWhite;
   FGenConfigTagIDEdit->Font->Color = clBlue;
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::FGenConfigAnyTagIDRadioButtonClick(
      TObject *Sender)
{
   //FGenConfigTagIDRadioButton->Enabled = false;
   FGenConfigAnyTagIDRadioButton->Enabled = true;
   FGenConfigTagIDEdit->ReadOnly = true;
   FGenConfigTagIDEdit->Color = clMenu;
   FGenConfigTagIDEdit->Font->Color = clGray;
   FGenConfigTagIDEdit->Text = "";
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::FGenConfigRaRnModifyCheckBoxClick(
      TObject *Sender)
{
   if (FGenConfigRaRnModifyCheckBox->Checked)
   {
      FGenConfigRNShortRadioButton->Enabled = true;
      FGenConfigRALongRadioButton->Enabled = true;
      FGenConfigTagTypeModifyCheckBox->Checked = true;
      FGenConfigRaRnModifyCheckBox->Font->Color = clRed;
   }
   else
   {
      FGenConfigRNShortRadioButton->Enabled = false;
      FGenConfigRALongRadioButton->Enabled = false;
      FGenConfigRaRnModifyCheckBox->Font->Color = clOlive;
   }
}
//------------------------------------------------------------------------------

void __fastcall TProgStationForm::FGenConfigAssignedReaderIDEditChange(
      TObject *Sender)
{
   if (FGenConfigReaderIDEdit->ReadOnly)
      FGenConfigReaderIDEdit->Font->Color = clGray;
   else
      FGenConfigReaderIDEdit->Font->Color = clBlue;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::FGenConfigFGenIDEditChange(
      TObject *Sender)
{
   if (FGenConfigFGenIDEdit->ReadOnly)
      FGenConfigFGenIDEdit->Font->Color = clGray;
   else
      FGenConfigFGenIDEdit->Font->Color = clBlue;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::FGenConfigTagIDEditChange(
      TObject *Sender)
{
   if (FGenConfigTagIDEdit->ReadOnly)
      FGenConfigTagIDEdit->Font->Color = clGray;
   else
      FGenConfigTagIDEdit->Font->Color = clBlue;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ConfigFGenUpdateBitBtnClick(
      TObject *Sender)
{
   mouseClicked = false;

   if (FGenConfigStandFgenRadioButton->Checked)
   {
      if (FGenConfigHostIDEdit->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Host ID",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return;
      }

      if (FGenConfigFieldGenIDEdit->Text.data() == NULL)
      {
         Application->MessageBox("Error: Need Field Generator ID",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return;
      }

      if (!readerFgenButtonActivated)
      {
         ReaderFgenToolButton->Hint = "Programming Station Is In Field Generator Mode";
         readerFgenButtonActivated = true;
         if(networkOn)
            CloseNetworkConnection();
         else if (RS232On)
            ClosePort();
         lastBaudrate = baudRate;
         baudRate = 9600;
         EnableAllCommands(false);
         if (OpenSerial(comPort, baudRate))
         {
            ProgStationForm->PortOpen = true;
            PlaySound("Ding.wav", NULL, SND_ASYNC );
         }
         EnableAllCommands(true);

         readerOffLine = true;
         readerOnLine = false;
         fieldGenOffLine = true;
         fieldGenOnLine = false;
      }

      QueryFGenHostIDEdit->Text = FGenConfigHostIDEdit->Text;
      QueryFGenIDEdit->Text = FGenConfigFieldGenIDEdit->Text;

      Sleep(500);
      WriteRS232Comm(QUERY_FIELD_GEN, 0, NULL, 0);

   } //if std field gen
   else //smart field gen
   {
      if(networkOn)
      {
         /*int rdr = atoi(FGenConfigSmartFGenReaderIDComboBox->Text.c_str());
         int index = GetIpAddressIndex(rdr);
         if (index >= 0)
         {
            //EnableAllCommands(false);
            WriteTCPIPComm(QUERY_SMART_FIELD_GEN, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
         }*/

         int rdr = atoi(FGenConfigSmartFGenReaderIDComboBox->Text.c_str());
         int index = GetSocketIndex(rdr);
         if (index >= 0)
         {
            WriteAWSocket(QUERY_SMART_FIELD_GEN, 0, NULL, index, 'S', NULL, 0, index);
         }
         else
            StaticText->Caption = "No matching socket for the reader.";
      }
      else if (RS232On)
      {
          //EnableAllCommands(false);
          WriteRS232Comm(QUERY_SMART_FIELD_GEN, 0, NULL, 0);
      }
   }

   FGenConfigReaderIDEdit->Text = "";
   FGenConfigFGenIDEdit->Text = "";
   FGenConfigRNShortRadioButton->Checked = false;
   FGenConfigRALongRadioButton->Checked = false;
   //FGenConfigAccessRadioButton->Checked = false;
   //FGenConfigAssetRadioButton->Checked = false;
   //FGenConfigInventoryRadioButton->Checked = false;
   //FGenConfigAnyTypeRadioButton->Checked = false;
   FGenConfigTagIDEdit->Text = "";
   FGenConfigTxTimeComboBox->Text = "";
   FGenConfigActivePIRCheckBox->Checked = false;
   FGenConfigWaitTimeComboBox->Text = "";
   FGenConfigWaitTimeSecRadioButton->Checked = false;
   FGenConfigWaitTimeMinRadioButton->Checked = false;
   FGenConfigWaitTimeHourRadioButton->Checked = false;
   //FGenConfigWaitTimeAllRadioButton->Checked = false;

   FGenConfigAssignedReaderIDModifyCheckBox->Checked = false;
   FGenConfigFGenIDModifyCheckBox->Checked = false;
   FGenConfigRaRnModifyCheckBox->Checked = false;
   FGenConfigTagIDModifyCheckBox->Checked = false;
   FGenConfigTagTypeModifyCheckBox->Checked = false;
   FGenConfigTxTimeModifyCheckBox->Checked = false;
   FGenConfigWaitTimeModifyCheckBox->Checked = false;
   FGenConfigPotentiModifyCheckBox->Checked = false;
   FGenConfigTagRdrIDModifyCheckBox->Checked = false;

   //Sleep(500);

   //WriteRS232Comm(QUERY_FIELD_GEN, 0, NULL, 0);
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::FGenConfigWaitTimeSecRadioButtonMouseUp(
      TObject *Sender, TMouseButton Button, TShiftState Shift, int X,
      int Y)
{
   FGenConfigWaitTimeSecClicked = true;
}
//---------------------------------------------------------------------------


void __fastcall TProgStationForm::FGenConfigWaitTimeHourRadioButtonMouseUp(
      TObject *Sender, TMouseButton Button, TShiftState Shift, int X,
      int Y)
{
   FGenConfigWaitTimeHourClicked = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::FGenConfigWaitTimeMinRadioButtonMouseUp(
      TObject *Sender, TMouseButton Button, TShiftState Shift, int X,
      int Y)
{
   FGenConfigWaitTimeMinClicked = true;
}
//---------------------------------------------------------------------------
SOCKET __fastcall TProgStationForm::OpenSocket(char * hostname, int port, int type, struct sockaddr_in * peer)
{
   SOCKET	    sock;
   struct hostent   *hdata;
   unsigned long    ipaddr;
   int ret;

   #ifdef WIN32
   /*  start up winsock */
   WSADATA info;
   if ((ret = WSAStartup(MAKEWORD(1,1), &info)) < 0 )
   {
      Application->MessageBox("Error on WSAStartup()", "Error", MB_OK);
      return(ret);
   }
   #endif /* WIN32 */

   //  create the socket
   sock = socket(AF_INET, type, 0);
   if (sock < 0)
   {
      Application->MessageBox("Error creating sockets", "Error", MB_OK);
      return(0);
   }

   peer = new (sockaddr_in);
   // Find the IP address and convert to 4 byte int
   if (isdigit(hostname[0]))  // dot decimal notation?
   {
      if ((ipaddr = inet_addr(hostname)) == INADDR_NONE )
      {
          //inet_addr failed
          Application->MessageBox("inet_addr failed", "Error", MB_OK);
          //trace("inet_addr failed\n");

          CloseSocket();
          return(0);
      }

      //We have a valid address.
      memcpy (&peer->sin_addr, &ipaddr, 4);
   }
   else
   {
      if ((hdata = gethostbyname (hostname)) == (struct hostent *) NULL)
       {
          // Can't resolve hostname
          Application->MessageBox("Can't resolve hostname", "Error", MB_OK);
          //trace("Can't resolve hostname\n");
          CloseSocket();
          return(0);
       }

       memcpy (&peer->sin_addr, *(hdata->h_addr_list), hdata->h_length);
   }

   peer->sin_family = AF_INET;
   peer->sin_port = htons((unsigned short) port);

   if (peer->sin_addr.S_un.S_addr == 0)  //Wait for incoming
   {
      //bind struct the port
      if ((bind(sock, (struct sockaddr *) peer, sizeof(struct sockaddr_in))) < 0)
      {
         Application->MessageBox("Bind error", "Error", MB_OK);
         //trace("Bind error\n");
         closesocket(sock);
         return(-1);
      }
   }

   if (type == SOCK_DGRAM) // (UDP) we're done
      return(sock);

   // Must be TCP
   if (peer->sin_addr.S_un.S_addr != 0)  // active connect
   {
      //Let's connect to the peer
      if ((connect(sock, (struct sockaddr *) peer, sizeof(struct sockaddr_in))) != 0)
      {
         //Connection failed
         ret = WSAGetLastError();
         Application->MessageBox("Connection failed", "Error", MB_OK);
         //trace("Connection failed\n");
         shutdown(sock, 2);
         CloseSocket();
         return(0);
      }

      return(sock);
   }

  //Must be passive listen
  //Setup the listen queue
   if ((ret=listen(sock, 5)) != 0)
   {
      //trace("listen failure");
      ret = WSAGetLastError();
      Application->MessageBox("Listen failure", "Error", MB_OK);
      shutdown(sock, 2);
      closesocket(sock);
      return(-1);
   }

   //Return socket id
   return(sock);
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::CloseSingleSocket(int index)
{
   shutdown(networkInfo[index].activeSock, 2);
   closesocket(networkInfo[index].activeSock);
   networkInfo[index].validRec = false;
   networkInfo[index].reader = 0;
   networkInfo[index].host = 0;
   strcpy(networkInfo[index].status, "Offline");
   networkInfo[index].active = false;
   networkInfo[index].selected = false;
   networkInfo[index].activeSock = 0;
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::CloseSocket()
{
   for (int i=0; i<numOpenedSocket; i++)
   {
      shutdown(networkInfo[i].activeSock, 2);
      closesocket(networkInfo[i].activeSock);
      networkInfo[i].validRec = false;
      networkInfo[i].reader = 0;
      networkInfo[i].host = 0;
      strcpy(networkInfo[i].status, "Offline");
      networkInfo[i].active = false;
      networkInfo[i].selected = false;
      networkInfo[i].activeSock = 0;
      //strcpy(networkInfo[i].ipAddr, "          ");
   }

   if (tcipWindow)
   {
      TCPIPForm->ltx_closesocket(NULL, true);
      TCPIPForm->commThreadRunning = false;
   }

   networkOn = false;
}
//------------------------------------------------------------------------------
DWORD FAR PASCAL TCPIPCommThread(LPSTR lpData)
{
   SOCKET lsock;
   int i;
   //int encryption = 0;

   while(!startNetworkComm);

   //while ((ProgStationForm->main_loop(encryption)) > 0);
   ProgStationForm->CloseSocket();
   WSACleanup();
   return(0);

   /*if (peer.sin_addr.S_un.S_addr == 0) // && (type == SOCK_STREAM) )    //passive listen
   {

       do 	//wait for connect
       {
           //i = sizeof(peer);
           //if ((lsock = accept(openSock, (struct sockaddr *) &peer, &i)) < 0)
           //{
               //trace("accept failed\n");
               //Application->MessageBox("accept failed", "Error", MB_OK);
               //peer.sin_addr.S_un.S_addr = 0;
           //}
           //else
               //if (encryption)
               //{
                  //Read the IV from the peer
                  //if ((read_socket(ProgStationForm->networkInfo[0].activeSock[0], ProgStationForm->networkInfo[0].initVectorDecrypt, 16, ProgStationForm->networkInfo[0].peerSock)) != 16)
                  //{
                     //trace("Reading IV failed\n");
                     //Application->MessageBox("Reading IV failed", "Error", MB_OK);
                  //}
                  //memcpy(ProgStationForm->networkInfo[0].initVectorEncrypt, ProgStationForm->networkInfo[0].initVectorDecrypt, 16);
               //}

               //Main loop dance
               //while ((main_loop(lsock, &peer, encryption)) > 0);
               //while ((ProgStationForm->main_loop(openSock, &peer, encryption)) > 0);
	       while ((ProgStationForm->main_loop(encryption)) > 0);

               ProgStationForm->CloseSocket();
           //}

       } while (peer.sin_addr.S_un.S_addr != 0);
   }  //passive listen
   else
   {
      //Main loop dance
      //while ((ProgStationForm->main_loop(openSock, &peer, encryption)) > 0);
      while ((ProgStationForm->main_loop(encryption)) > 0);
   }

   //Shutdown and close the socket
   //ProgStationForm->CloseSocket(openSock);
   ProgStationForm->CloseSocket();

   //Clean up the WinSock resources
   WSACleanup();  */

   //Free the DLL
   //if (encryption && hDLL)
      //FreeLibrary(hDLL);

   //Done
}
//------------------------------------------------------------------------------
//int __fastcall TProgStationForm::main_loop(LTX_SOCKET sock, struct sockaddr_in * from, int encryption)
int __fastcall TProgStationForm::main_loop(int encryption)
{
   int timeout, in, out=0, toget;
   int counter = 0;
   fd_set rfds, efds, wfds;
   struct timeval timev;
   char *buf;
   //char plaintext[SOCKBUFSIZE];		//Plain text
   static int loop = 0;
   //char encrypText[SOCKBUFSIZE+34];	//Encrypted text. Round up to hold blocks(16), IV(16) and length(2)//

   //Encrypted text. Round up to hold blocks(16), IV(16) and length(2)

   //if (encryption)
   //{
      //receibuf = encrypText;
      //toget = sizeof(encrypText);
   //}
   //else
   //{
     // buf = plaintext;
      //toget = sizeof(plaintext);
      toget = 254;
   //}

   //main loop
   while (1)
   {
      FD_ZERO(&rfds);
      FD_ZERO(&wfds);
      FD_ZERO(&efds);
      for (loop=0; loop<numOpenedSocket; loop++)
      {
         FD_SET(networkInfo[loop].activeSock, &rfds);
         FD_SET(networkInfo[loop].activeSock, &wfds);
         FD_SET(networkInfo[loop].activeSock, &efds);
      }

      //Set timeout to 100mS.  This timeout will affect serial polling frequency
      timev.tv_sec = 0;
      timev.tv_usec = 100000;
      //timeout = select(FD_SETSIZE, &rfds, (fd_set *) NULL, &efds, &timev);
      timeout = select(FD_SETSIZE, &rfds, &wfds, &efds, &timev);

      if (timeout == -1)
      {
         //OS interrupt during select - should be ignored
         //return(timeout);
         ;
      }
      else if (timeout == 0)
      {
         //Real timeout - do nothing
         //return(0);
         ;
      }

      loop = 0;
      //for (loop=0; loop<numOpenedSocket; loop++)
      {
         if (FD_ISSET(networkInfo[loop].activeSock, &efds))
         {
            //Bad news, exception on socket - needs to be closed and reopened
            return(-2);
         }
         else if (FD_ISSET(networkInfo[loop].activeSock, &rfds))
         {
            /*if (justStartedUp[loop] && (counter <= 2))  //clear target buffer
            {
               counter++;
               if (counter >= 2)
                  justStartedUp[loop] = false;
               out += ClearReadSocket(networkInfo[loop].activeSock[0], networkInfo[loop].peerSock, loop);
               //Edit4->Text = out;
            }*/
            //Received socket data input, decrypt it if required, and write it to serial output
            if ((in = ReadSocket(networkInfo[loop].activeSock, recvBuf, toget, networkInfo[loop].peerSock, loop)) > 0)
            {
               /*if (encryption)
               {
                  strncpy(encrypText, recvBuf, in);
                  //if (displayRx)
                  //{
                     //pktCounter++;
                     //DisplayRecPackets(recvBuf, in, false, false);
                  //}
                  //pstatd = 0;
                  TCPDecrypt(encrypText, in, recvBuf, encryption, loop);
               }*/

               if (displayRx)
               {
                  pktCounter++;
                  DisplayRecPackets(recvBuf, in, false, false, NULL);
               }

               if (recvBuf[1] == POWER_UP)
               {
                  if ((recvBuf[3] & 0x38) == 0x30)  //exteded reader
                  {
                    //networkInfo[loop].activeSock[1] = (unsigned int)(unsigned char)recvBuf[4]*pow(2, 8)+(unsigned int)(unsigned char)recvBuf[5];  //reader ID
                    networkInfo[loop].reader = (unsigned int)(unsigned char)recvBuf[4]*pow(2, 8)+(unsigned int)(unsigned char)recvBuf[5];
                    networkInfo[loop].host = (unsigned char)recvBuf[6];
                  }
                  else
                  {
                    //networkInfo[loop].activeSock[1] = (int)recvBuf[4];
                    networkInfo[loop].reader = (unsigned char)recvBuf[4];
                    networkInfo[loop].host = (unsigned char)recvBuf[5];
                  }

                  strcpy(networkInfo[loop].status, "Online");
                  //networkInfo[loop].activeSock[2] = 1;  //set flag when populated
                  networkInfo[loop].validRec = true;

                  if (comConfigDialog != NULL)
                  {
                     comConfigDialog->UpdateIPListViewPowerup(loop);
                  }
               }

               PacketParser(in, loop);

            }
         }
         else if (FD_ISSET(networkInfo[loop].activeSock, &wfds))
         {
            //if (!doOnce)
            //{
               //WriteTCPIPComm(RESET_DEVICE, 0, NULL, 0, activeSock[loop][0], peerSock[loop]);
               //doOnce = true;
            //}
         }
      } //for loop
   }   //while(1)

   return(0);
}
//------------------------------------------------------------------------------
int __fastcall TProgStationForm::ReadSocket(SOCKET sock, char * rbuf, int len, struct sockaddr_in * from, int sockIndex)
{
   int in, fromlen;
   int bytesReadIn = 0;
   unsigned int pktLen = 0;
   int localIndex = 0;
   char BUFFER[256];
   char TEXT[256];
   AnsiString s;
   //char plaintext[16] = {'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0'};

   fromlen = sizeof(struct sockaddr_in);
   //if ((in = recvfrom(sock, &rbuf[localIndex], 255, 0, (struct sockaddr *) from, &fromlen)) < 0)
      if ((in = recvfrom(sock, BUFFER, 255, 0, (struct sockaddr *) from, &fromlen)) < 0)
      {
         //trace("recvfrom failed\n");
         sysStr = "Receive from network failed";
         MainStatusBar->Panels->Items[0]->Text = sysStr;
         //Application->MessageBox("recvfrom failed", "Error", MB_OK);
         return(-1);
      }

      //TCPDecrypt(BUFFER, in, TEXT, encryption, 0);
      DisplayRecPackets(TEXT, in, false, false, NULL);
      return(in);
   /*
   while(1)
   {
      if ((in = recvfrom(sock, &rbuf[localIndex], 1, 0, (struct sockaddr *) from, &fromlen)) < 0)
      {
         //trace("recvfrom failed\n");
         sysStr = "Receive from network failed";
         MainStatusBar->Panels->Items[0]->Text = sysStr;
         //Application->MessageBox("recvfrom failed", "Error", MB_OK);
         return(-1);
      }

      TCPDecrypt(&rbuf[localIndex], 1, plainText, 2, sockIndex);
      rbuf[0] = plainText[0];
      if (rbuf[0] == 0x7E)
      {
         index += 1;
         DisplayRecPackets(rbuf, localIndex, false, false);
         break;
      }
   }

   while(bytesReadIn < 2)
   {
      if ((in = recvfrom(sock, &rbuf[localIndex], 1, 0, (struct sockaddr *) from, &fromlen)) < 0)
      {
         sysStr = "Receive from network failed";
         MainStatusBar->Panels->Items[0]->Text = sysStr;
         //trace("recvfrom failed\n");
         //Application->MessageBox("recvfrom failed", "Error", MB_OK);
         DisplayRecPackets(rbuf, localIndex, false, false);
         return(-1);
      }

      //pstatd = 0;
      TCPDecrypt(&rbuf[localIndex], 1, plainText, 2, sockIndex);
      rbuf[localIndex] = plainText[0];

      bytesReadIn += 1;
      localIndex += 1;
   }

   pktLen = rbuf[localIndex-1];
   bytesReadIn = 0;

   DisplayRecPackets(rbuf, localIndex, false, false);

   while(bytesReadIn < (pktLen+2))
   {
      if ((in = recvfrom(sock, &rbuf[localIndex], 1, 0, (struct sockaddr *) from, &fromlen)) < 0)
      {
         sysStr = "Receive from network failed";
         MainStatusBar->Panels->Items[0]->Text = sysStr;
         //trace("recvfrom failed\n");
         //Application->MessageBox("recvfrom failed", "Error", MB_OK);
         DisplayRecPackets(rbuf, localIndex, false, false);
         return(-1);
      }

      //pstatd = 0;
      TCPDecrypt(&rbuf[localIndex], 1, plainText, 2, sockIndex);
      rbuf[localIndex] = plainText[0];

      bytesReadIn += 1;
      localIndex += 1;
   }

   DisplayRecPackets(rbuf, localIndex, false, false);

   if (!CheckCRC(localIndex, rbuf))
   {
      sysStr = "CRC check failed";
      MainStatusBar->Panels->Items[0]->Text = sysStr;
      //Application->MessageBox("CRC check failed", "Error", MB_OK);
      return(-1);
   }
   //if ((in = recvfrom(sock, rbuf, len, 0, (struct sockaddr *) from, &fromlen)) < 0)
   //{
      //trace("recvfrom failed\n");
      //Application->MessageBox("recvfrom failed", "Error", MB_OK);
   //}
   */
   return(localIndex);
}
//------------------------------------------------------------------------------
int __fastcall TProgStationForm::ClearReadSocket(SOCKET sock,  struct sockaddr_in * from, int loop)
{
   int in, fromlen;
   int nBytes = 0;
   char tempBuf[255] = {'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0'};
   char tempReadBuf[255];
   int counter = 0;

   fromlen = sizeof(struct sockaddr_in);
   while((in = recvfrom(sock, tempReadBuf, 200, 0, (struct sockaddr *) from, &fromlen)) > 0)
   {
      //pstatd = 0;
      //TCPDecrypt(tempReadBuf, in, tempBuf, encryption, loop);

      counter += 1;
      nBytes += in;
      if (displayRx)
      {
         pktCounter++;
         DisplayDumpedPackets(tempBuf, in);
      }

      if ((in < 200) && (counter >= 2))
         return(nBytes);

      if (in >= 200)
         counter -= 1;

      //Edit4->Text = in;
      //Edit5->Text = counter;
      Sleep(100);
   }
   return(nBytes);
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::serial_write(char * plaintext, int len)
{
   int i;
   AnsiString str;

   for (i = 0; i < len; i++)
   {
       //printf("%c", plaintext[i]);
       str += (unsigned char)plaintext[i];
   }

   DisplayRecPackets(plaintext, len, false, false, NULL);
   //ReceiveListBox->Items->Add(str);
}
//------------------------------------------------------------------------------
int __fastcall TProgStationForm::serial_read(char * plaintext, int len, int command)
{
    int in = 0;

    //in = 0;
    //while ( (_kbhit() != 0) && (in < len) )
    //{
       //plaintext[in++] = _getch();
    //}

    if (command == 1)
    {
       plaintext[0] = 0x7E;
       plaintext[1] = 0x01;
       plaintext[2] = 0x04;
       plaintext[3] = 0x0A;
       plaintext[4] = 0x01;
       plaintext[5] = 0x01;
       plaintext[6] = 0x01;
       plaintext[7] = 0x05;
       plaintext[8] = 0xBC;
       in = 9;
       command = 0;
    }
    else if (command == 2)
    {
       plaintext[0] = 0x7E;
       plaintext[1] = 0xB0;
       plaintext[2] = 0x04;
       plaintext[3] = 0x0A;
       plaintext[4] = 0x01;
       plaintext[5] = 0x01;
       plaintext[6] = 0xAF;
       plaintext[7] = 0x28;
       plaintext[8] = 0x36;
       in = 9;
       command = 0;
    }

    return(in);

}
//------------------------------------------------------------------------------
int __fastcall TProgStationForm::WriteSocket(SOCKET sock, char * sbuf, int len, struct sockaddr_in * to)
{
    int n, sent, tosend;

    sent = 0;
    tosend = len;
    while(tosend)
    {
       n = sendto(sock, (char *) &sbuf[sent], tosend, 0, (struct sockaddr *) to, sizeof (struct sockaddr));
       if (n <= 0)
       {
         /* sendto failed */
         //trace("sendto failed\n");
         //Application->MessageBox("sendto failed", "Error", MB_OK);
         sysStr = "send over network failed";
         MainStatusBar->Panels->Items[0]->Text = sysStr;
         perror(NULL);
         return(-1);
       }
       else
       {
          sent += n;
          tosend -= n;
       }
    }

    //DisplayTransmitPackets(sbuf, sent);
    return(sent);
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::CloseNetworkConnection()
{
   TerminateThread(hTCPIPCommThread, 0);
   //hTCPIPCommThread = NULL;
   //WSACleanup();
   //CloseSocket();
   //TerminateThread(hTCPIPCommThread, 0);

   //Registry-----------------------------

   TRegistry* Reg = new TRegistry;
   Reg->RootKey = HKEY_CURRENT_USER;
   if (Reg->KeyExists("Software"))
   {
      Reg->OpenKey("Software", false);
      if (!Reg->KeyExists("Active Wave"))
            Reg->CreateKey("Active Wave");

      Reg->OpenKey("Active Wave", false);

      if (!Reg->KeyExists("Programming Station"))
            Reg->CreateKey("Programming Station");

      Reg->OpenKey("Programming Station", false);
      //Reg->WriteString("IPAddress", lastIPAddress);
      Reg->WriteString("HostName", lastHostName);
      Reg->WriteInteger("PortID", lastPortID);
      Reg->WriteString("CommType", "Network");
   }
   delete Reg;

   //-----------------------------

   networkOn = false;
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::DisplayTxInfo()
{
   sysStr = "Transmit OK";
   MainStatusBar->Panels->Items[0]->Text =  "Transmit OK";
   pktCounter++;
   DisplayTransmitPackets(XBuf, lastLenBytesSent, NULL);

   if ((fileHandle != NULL) && recording)
   {
      txDebugStr = ProgStationForm->BuildTxRecordPktStr(XBuf, pktLenToTransmit);
      txDebugStr += "\n";
      fwrite(txDebugStr.c_str(), txDebugStr.Length(), 1, fileHandle);
   }
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::EnableRdrFGenStaticTextClick(
      TObject *Sender)
{
  if (!EnableFGenGroupBox->Visible)
   {
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      //GeneralGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = true;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = false;
   SetFStrengthStaticText->Visible = true;
   DownloadRdrStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = false;
   DownloadRdrBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = true;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   FGenResetBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   DownloadRdrBitBtn->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   //EnableFGenBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   //if (lastHostID <= 0)
      //EnableFGenHostIDEdit->Text = "";
   //else
      //EnableFGenHostIDEdit->Text = lastHostID;
   if (allHostID)
   {
      if (lastHostID > 0)
         EnableFGenHostIDEdit->Text = lastHostID;
   }
   else
      EnableFGenHostIDEdit->Text = sysHostID;


   //FGenReaderIDComboBox->Items->Clear();
   for (unsigned int i=0; i<numReaderIDList; i++)
      EnableFGenReaderIDComboBox->Items->Add(readerIDList[i]);

   if (lastReaderID <= 0)
      EnableFGenReaderIDComboBox->Text = "";
   else
      EnableFGenReaderIDComboBox->Text = lastReaderID;

   //Reset Device  0x01
   TxClearTagCtrls();
   RxClearTagCtrls();
}
//------------------------------------------------------------------------------

void __fastcall TProgStationForm::EnableFGenBitBtnClick(TObject *Sender)
{
   //EnableFGenBitBtn->Font->Color = clRed;

   if (EnableFGenHostIDEdit->Text.data() == NULL)
   {
      Application->MessageBox("Error: Need Host ID",
                              "Programming Station Information Dialog",
                              MB_OK | MB_ICONSTOP | MB_TOPMOST );
      //EnableFGenBitBtn->Enabled = true;
      return;
   }

   if (EnableFGenReaderIDComboBox->Text.data() == NULL)
   {
      Application->MessageBox("Error: Need Reader ID",
                              "Programming Station Information Dialog",
                              MB_OK | MB_ICONSTOP | MB_TOPMOST);
      //EnableFGenBitBtn->Enabled = true;
      return;
   }

   ResetReaderStaticText->Enabled = true;
   EnableReaderStaticText->Enabled = false;
   DisableReaderStaticText->Enabled = false;
   QueryReaderStaticText->Enabled = false;
   AssignReaderStaticText->Enabled = false;
   ReaderVersionStaticText->Enabled = false;
   //EnableRdrFGenStaticText->Enabled = false;
   ConfigTxTimeStaticText->Enabled = false;
   ConfigFGenStaticText->Enabled = false;
   QueryFGenStaticText->Enabled = false;
   RelayStaticText->Enabled = false;
   InputsStaticText->Enabled = false;
   ConfigTagStaticText->Enabled = false;
   EnableTagStaticText->Enabled = false;
   DisableTagStaticText->Enabled = false;
   QueryTagStaticText->Enabled = false;
   CallTagStaticText->Enabled = false;
   AssignTagRdrStaticText->Enabled = false;
   ConfigTagRNDStaticText->Enabled = false;
   WriteMemoryStaticText->Enabled = false;
   ReadMemoryStaticText->Enabled = false;
   TagTempStaticText->Enabled = false;

   //EnableFGenBitBtn->Visible = false;
   //EnableRdrFGenStaticText->Visible = true;

   TxClearTagCtrls();
   RxClearTagCtrls();
   ProgammingMode = true;
   StaticText->Caption = "";
   DetectedMsg->Caption = "";
   TamperSWMsg->Caption = "";
   TagDetectedGroupBox->Caption = "Detected Tags";
   if (NewListItemCheckBox->Checked == false)
   {
      tagDetectCount = 0;
      type1Count = 0;
      type2Count = 0;
      type3Count = 0;
      type4Count = 0;
      type5Count = 0;
      type6Count = 0;
      typeFacCount = 0;
      ReportType1Label->Caption = "";
      ReportType2Label->Caption = "";
      ReportType3Label->Caption = "";
      ReportType4Label->Caption = "";
      ReportType5Label->Caption = "";
      ReportType6Label->Caption = "";
      ReportFACTLabel->Caption = "";
      ReportTotalLabel->Caption = "";
      ReportNDupLabel->Caption = "";
      DetectedTagListView->Items->Clear();
      for (int i=0; i<MAX_TAG_DETECTED; i++)
      {
          tagDetectedArray[i].tagID = 0;
          tagDetectedArray[i].tagType = 6;
          tagDetectedArray[i].cmd = 0;
          tagDetectedArray[i].fGenID = 0xFF;
          tagDetectedArray[i].gID = false;
          tagDetectedArray[i].lastDetectTime = Now();
      }
   }

   TxClearTagCtrls();
   RxClearTagCtrls();
   ProgammingMode = true;
   programming = false;
   progStr = "Please Wait. Enabling Field Generator.";
   StaticText->Caption = progStr;
   receivedResponse = false;

   /*if (readerFgenButtonActivated)
   {
      ReaderFgenToolButton->Hint = "Set Programming Station To Field Generator Mode";
      readerFgenButtonActivated = false;
      if(networkOn)
         CloseNetworkConnection();
      else if (RS232On)
         ClosePort();
      EnableAllCommands(false);
      if (OpenSerial(comPort, lastBaudrate))
      {
         ProgStationForm->PortOpen = true;
         baudRate = curBaudrate = lastBaudrate;
         PlaySound("Ding.wav", NULL, SND_ASYNC );
      }
      EnableAllCommands(true);

      readerOffLine = true;
      readerOnLine = false;
      fieldGenOffLine = true;
      fieldGenOnLine = false;
   }*/

   //WriteRS232Comm(ENABLE_FIELD_GEN, 0, NULL, 0);
   if(networkOn)
   {
      /*int rdr = atoi(EnableFGenReaderIDComboBox->Text.c_str());
      int index = GetIpAddressIndex(rdr);
      if (index >= 0)
      {
            WriteTCPIPComm(ENABLE_FIELD_GEN, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
      }*/

      int rdr = atoi(EnableFGenReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(ENABLE_FIELD_GEN, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(ENABLE_FIELD_GEN, 0, NULL, 0);
   }
}
//------------------------------------------------------------------------------
bool __fastcall TProgStationForm::CheckHostID()
{
   unsigned int hID;
   if ((recvBuf[3] & 0x38) == 0x10)  //00 010 000 std rdr
   {
      hID = (unsigned char)recvBuf[5];
      if (lastHostID == hID)
         return(true);
      else
      {
         sysStr = "Got Wrong Host ID ";
         sysStr += hID;
         MainStatusBar->Panels->Items[0]->Text = sysStr;
         StaticText->Caption = "Error: Wrong Host ID";
         return(false);
      }
   }
   else if ((recvBuf[3] & 0x38) == 0x30)  //00 110 000 ext rdr
   {
      hID = (unsigned char)recvBuf[6];
      if (lastHostID == hID)
         return(true);
      else
      {
         sysStr = "Got Wrong Host ID ";
         sysStr += hID;
         MainStatusBar->Panels->Items[0]->Text = sysStr;
         StaticText->Caption = "Error: Wrong Host ID";
         return(false);
      }
   }
   else if ((recvBuf[3] & 0x38) == 0x00)  //00 000 000 field gen
   {
      hID = (unsigned char)recvBuf[5];
      if (lastHostID == hID)
         return(true);
      else
      {
         sysStr = "Got Wrong Host ID ";
         sysStr += hID;
         MainStatusBar->Panels->Items[0]->Text = sysStr;
         StaticText->Caption = "Error: Wrong Host ID";
         return(false);
      }
   }

   return(false);
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::DisplayInputListView(unsigned short rdr, unsigned char cbyte)
{
   if (!InputKeepItemsCheckBox->Checked)
       InputListView->Clear();
    TListItem* ListItem = InputListView->Items->Insert(0);
    ListItem->ImageIndex = -1;
    ListItem->Caption = "";
    ListItem->SubItems->Add(rdr);

    if ((cbyte & 0x03) == 0x00)   //---- --00
       ListItem->SubItems->Add("Normal Close");
    else if ((cbyte & 0x03) == 0x01)   //---- --01
       ListItem->SubItems->Add("Normal Open");
    else if ((cbyte & 0x03) == 0x02)   //---- --10
    {
       if (Input1SupervisedCheckBox->Checked)
          ListItem->SubItems->Add("Faulty Close");
       else
          ListItem->SubItems->Add("Normal Close");
    }
    else // ((cbyte | 0xFC) == 0xFF)   //---- --11
    {
       if (Input1SupervisedCheckBox->Checked)
          ListItem->SubItems->Add("Faulty Open");
       else
          ListItem->SubItems->Add("Normal Open");
    }

    if ((cbyte & 0x0C) == 0x00)   //---- 00--
       ListItem->SubItems->Add("Normal Close");
    else if ((cbyte & 0x0C) == 0x04)   //---- 01--
       ListItem->SubItems->Add("Normal Open");
    else if ((cbyte & 0x0C) == 0x08)   //---- 10--
    {
       if (Input2SupervisedCheckBox->Checked)
          ListItem->SubItems->Add("Faulty Close");
       else
          ListItem->SubItems->Add("Normal Close");
    }
    else // ((cbyte | 0xFC) == 0xFF)   //---- 11--
    {
       if (Input2SupervisedCheckBox->Checked)
          ListItem->SubItems->Add("Faulty Open");
       else
          ListItem->SubItems->Add("Normal Open");
    }

}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::DisplayRelayListView(int rID, int relID, bool enable)
{
    if (!RelayKeepListCheckBox->Checked)
       RelayListView->Clear();
    TListItem* ListItem = RelayListView->Items->Insert(0);
    ListItem->ImageIndex = -1;
    ListItem->Caption = "";
    ListItem->SubItems->Add(rID);
    if (relID == 1)
    {
       if (enable)
          ListItem->SubItems->Add("Enabled");
       else
          ListItem->SubItems->Add("Disabled");

       ListItem->SubItems->Add("---");
    }
    else if (relID == 2)
    {
       ListItem->SubItems->Add("---");
       if (enable)
          ListItem->SubItems->Add("Enabled");
       else
          ListItem->SubItems->Add("Disabled");
    }
}
//------------------------------------------------------------------------------
AnsiString __fastcall TProgStationForm::GetDate(unsigned char day, unsigned char my)
{
   AnsiString str;
   str = (unsigned int)day;
   switch (((unsigned int)my & 0xF0) >> 4)
   {
      case 1:
        str += " Jan ";
      break;

      case 2:
        str += " Feb ";
      break;

      case 3:
        str += " Mar ";
      break;

      case 4:
        str += " Apr ";
      break;

      case 5:
        str += " May ";
      break;

      case 6:
        str += " Jun ";
      break;

      case 7:
        str += " Jul ";
      break;

      case 8:
        str += " Aug ";
      break;

      case 9:
        str += " Sep ";
      break;

      case 10:
        str += " Oct ";
      break;

      case 11:
        str += " Nov ";
      break;

      case 12:
        str += " Dec ";
      break;

      default:
        str += " ";
      break;
   }

   str += "0";
   str += ((unsigned int)my & 0x0F);
   return str;
}
//------------------------------------------------------------------------------
bool __fastcall TProgStationForm::BuildTxSockets(unsigned int Command, int Len, unsigned char* buf, unsigned int pktID, AnsiString ip)
{
   txCommand = Command;
   txLen = Len;
   //char encrypText[SOCKBUFSIZE+34];
   //char decrypText[SOCKBUFSIZE+34];

   DWORD BytesSend;
   DWORD dwRes;
   int totalLen;
   int eTotalLen;
   int sendBytes = 0;
   bool glob;
   int i=0;
   int reader = 0;
   int indx = 0;

   LastCommand = Command;

   if ((totalLen = BuildPacket(Command, Len, buf, pktID, &reader)) <= 0)
      return (false);


      if (buf != NULL)
      {

         if (*buf == 'G')
         {
            if (ip.data() != NULL)
            {
               indx = GetSockPollQueIndex(ip);
               if (indx >= 0)
               {
                  for (i=0; i<totalLen; i++)
                     sockPollQue[indx].XBuf[i] = XBuf[i];
                  sockPollQue[indx].txLen = totalLen;
                  sockPollQue[indx].txFlag = true;
                  return(true);
               }
               else
                  return(false);
            }
            else
            {
               for (unsigned int j=0; j<numSockPoll; j++)
               {
                  for (i=0; i<totalLen; i++)
                     sockPollQue[j].XBuf[i] = XBuf[i];
                  sockPollQue[j].txLen = totalLen;
                  sockPollQue[j].txFlag = true;
               }
               return(true);
            }
         }//'G'
      }   //if null
      else
      {
            //indx = GetIpAddressIndex(reader);
            indx = GetSockPollQueIndex(reader);
            if (indx >= 0)
            {
               for (i=0; i<totalLen; i++)
                 sockPollQue[indx].XBuf[i] = XBuf[i];
               sockPollQue[indx].txLen = totalLen;
               sockPollQue[indx].txFlag = true;
               return(true);
            }
            else
               return(false);
      }//null

      return(true);


   int k = ClientSocket->Socket->SendBuf((unsigned char*)XBuf, totalLen);
   if (displayTx)
            {
               pktCounter++;
               DisplayTransmitPackets(XBuf, totalLen, NULL);


            }

            if ((fileHandle != NULL) && recording)
            {
               txDebugStr = BuildTxRecordPktStr(XBuf, totalLen);
               txDebugStr += "\n";
               fwrite(txDebugStr.c_str(), txDebugStr.Length(), 1, fileHandle);
            }

   return (true);
}
//------------------------------------------------------------------------------
bool __fastcall TProgStationForm::WriteTCPIPComm(unsigned int Command, int Len, unsigned char* buf, unsigned int pktID, SOCKET activeSocket, sockaddr_in* activePeer, int encrypIndx)
{
   txCommand = Command;
   txLen = Len;
   //char encrypText[SOCKBUFSIZE+34];
   //char decrypText[SOCKBUFSIZE+34];

   DWORD BytesSend;
   DWORD dwRes;
   int totalLen;
   int eTotalLen;
   int sendBytes = 0;
   bool glob;
   int i=0;
   int reader = 0;

   LastCommand = Command;

   if ((totalLen = BuildPacket(Command, Len, buf, pktID, &reader)) <= 0)
      return (false);

   AnsiString s;
   for (i=0; i<totalLen; i++)
      s += XBuf[i];
   int k = ClientSocket->Socket->SendBuf((unsigned char*)XBuf, totalLen);
   return (true);

   if (buf != NULL)
   {
      if (buf[0] == 'G')
        glob = true;
      else
        glob = false;
   }
   else
      glob = false;

   //if (encryption)
   //int out;
   //int in = TCPIPForm->ltx_encrypt((char*)XBuf, in, encryptedtext, 2);
   //if ((out =  TCPIPForm->write_socket(sock, (char*)XBuf, totalLen, (struct sockaddr_in *)&peer, 0)) < totalLen)
   //{
      // Socket write error
      //return(-4);
   //}

   if (glob)   //global command
   {
      //for (i=0; i<numOpenedSocket; i++)
      for (i=0; i<numItems; i++)
      {
         if (networkInfo[i].selected)
         {
            //if (encryption)
            //{
               //strncpy(encrypText, (char*)XBuf, totalLen);
               //eTotalLen = TCPEncrypt((char*)XBuf,  totalLen, encrypText, encryption, i);
               //if ((sendBytes = WriteSocket(networkInfo[i].activeSock[0], encrypText, eTotalLen, &networkInfo[i].peerSock[0])) < eTotalLen)
               if ((sendBytes = TCPIPForm->write_socket(networkInfo[i].activeSock, (char*)XBuf, totalLen, (struct sockaddr_in *)networkInfo[i].peerSock, i)) < totalLen)
               {
                  //socket write error
                  sysStr = "Transmit Failed";
                  MainStatusBar->Panels->Items[0]->Text =  "Transmit Failed";
               }
               else
               {
                  sysStr = "Transmit OK";
                  MainStatusBar->Panels->Items[0]->Text =  "Transmit OK";
               }
            //}
            /*else
            {
               if ((sendBytes = WriteSocket(networkInfo[i].activeSock, XBuf, totalLen, &networkInfo[i].peerSock[0])) < totalLen)
               {
                  //socket write error
                  sysStr = "Transmit Failed";
                  MainStatusBar->Panels->Items[0]->Text =  "Transmit Failed";
                  return(0);
               }
               else
               {
                  sysStr = "Transmit OK";
               }
            }*/

            lastLenBytesSent = totalLen;
            if (displayTx)
            {
               pktCounter++;
               DisplayTransmitPackets(XBuf, totalLen, NULL);

               /*pktCounter++;
               DisplayTransmitPackets(encrypText, eTotalLen);

               pktCounter++;
               pstatd = 0;
               int n = TCPDecrypt(encrypText, eTotalLen, decrypText, 2, 0);
               DisplayTransmitPackets(decrypText, n);*/
            }

            if ((fileHandle != NULL) && recording)
            {
               txDebugStr = BuildTxRecordPktStr(XBuf, totalLen);
               txDebugStr += "\n";
               fwrite(txDebugStr.c_str(), txDebugStr.Length(), 1, fileHandle);
            }
         }//selected
      }//for loop
   } //global
   else
   {
      //if (encryption)
      //{
         //strncpy(encrypText, (char*)XBuf, totalLen);
         //pstate = 0;
         //eTotalLen = TCPEncrypt(encrypText, totalLen, (char*)XBuf, encryption, 0);
         //if ((sendBytes = WriteSocket(activeSocket, encrypText, eTotalLen, activePeer)) < eTotalLen)
         if ((sendBytes = TCPIPForm->write_socket(activeSocket, XBuf, totalLen, (struct sockaddr_in *)activePeer, encrypIndx)) < totalLen)
         {
            MainStatusBar->Panels->Items[2]->Text = "Write Socket Failed";
            PlaySound("Ding.wav", NULL, SND_ASYNC );
            return(0);
         }
      //}
      /*else
      {
         if ((sendBytes = WriteSocket(activeSocket, XBuf, totalLen, activePeer)) < totalLen)
         {
            //socket write error
            return(0);
         }
      }*/

      lastLenBytesSent = totalLen;

      sysStr = "Transmit OK";
      MainStatusBar->Panels->Items[0]->Text =  "Transmit OK";

      if (displayTx)
      {
         pktCounter++;
         DisplayTransmitPackets(XBuf, totalLen, NULL);
      }

      if ((fileHandle != NULL) && recording)
      {
         txDebugStr = BuildTxRecordPktStr(XBuf, totalLen);
         txDebugStr += "\n";
         fwrite(txDebugStr.c_str(), txDebugStr.Length(), 1, fileHandle);
      }
   }//not glob

   return (true);
}
//------------------------------------------------------------------------------
int __fastcall TProgStationForm::GetBroadcastNum()
{
   int k = 0;
   for (int i=0; i<MAX_DESCRIPTOR; i++)
   {
     if (AWSockets[i])
     {
        if (AWSockets[i]->AWClientSocket->Active &&
            AWSockets[i]->connected)
          k += 1;
     }
   }

   return k;
}
//------------------------------------------------------------------------------
bool __fastcall TProgStationForm::WriteAWSocket(unsigned int Command, int Len, unsigned char* buf, unsigned int pktID, char type, unsigned int selectList[MAX_DESCRIPTOR], int numEntry, int sockIndex)
{
   txCommand = Command;
   txLen = Len;
   //char encrypText[SOCKBUFSIZE+34];
   //char decrypText[SOCKBUFSIZE+34];

   DWORD BytesSend;
   DWORD dwRes;
   int totalLen;
   int eTotalLen;
   int sendBytes = 0;
   bool glob;
   int i=0;
   int k=0;
   int reader = 0;
   AnsiString s;

   LastCommand = Command;

   if (sockIndex < 0)
      return (false);

   if ((totalLen = BuildPacket(Command, Len, buf, pktID, &reader)) <= 0)
      return (false);

   if (type == 'B')
   {
      broadcastNum = GetBroadcastNum();
      for (i=0; i<broadcastNum; i++)  //broadCastNum
      {
         k = AWSockets[i]->AWClientSocket->Socket->SendBuf((unsigned char*)XBuf, totalLen);
         if ( k != totalLen)
         {
            if (comConfigDialog)
            {
               s = "Transmit to IP = ";
               s += AWSockets[sockIndex]->AWClientSocket->Address;
               s += " failed. N = ";
               s += k;
               comConfigDialog->Msg->Caption = s;
            }
          }

          if (displayTx)
          {
             pktCounter++;
             DisplayTransmitPackets(XBuf, totalLen, AWSockets[sockIndex]->AWClientSocket->Address);
          }

          if ((fileHandle != NULL) && recording)
          {
             txDebugStr = BuildTxRecordPktStr(XBuf, totalLen);
             txDebugStr += "\n";
             fwrite(txDebugStr.c_str(), txDebugStr.Length(), 1, fileHandle);
          }
      }//for
   }//type = B
   else if (type == 'L')
   {


   }
   else  //type == S
   {
         k = AWSockets[sockIndex]->AWClientSocket->Socket->SendBuf((unsigned char*)XBuf, totalLen);
         if ( k != totalLen)
         {
            if (comConfigDialog)
            {
               s = "Transmit to IP = ";
               s += AWSockets[sockIndex]->AWClientSocket->Address;
               s += " failed. N = ";
               s += k;
               comConfigDialog->Msg->Caption = s;
            }
          }

          if (displayTx)
          {
             pktCounter++;
             DisplayTransmitPackets(XBuf, totalLen, AWSockets[sockIndex]->AWClientSocket->Address);
          }

          if ((fileHandle != NULL) && recording)
          {
             txDebugStr = BuildTxRecordPktStr(XBuf, totalLen);
             txDebugStr += "\n";
             fwrite(txDebugStr.c_str(), txDebugStr.Length(), 1, fileHandle);
          }

   }//type = S

   if (Command != 0x30)   //powerup
   {
      BootloadTimer->Enabled = true;  //reader offline
      callingReaderID =  (int)XBuf[5];
      rdrWentOffline = false;
   }

   return (true);

}//WriteAWSocket
//---------------------------------------------------------------------------
DWORD __fastcall TProgStationForm::GetNowTimeValue()
{
    TDateTime time = Now();
    DWORD d;
    Word Hour=0, Min=0, Sec=0, MSec=0;

    DecodeTime(time, Hour, Min, Sec, MSec);
    d = Hour*60*60*1000 + Min*60*1000 + Sec*1000;

    return(d);
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::DisplayTagTempInListView(unsigned int tagID, float temp, unsigned char status, char type, unsigned int rdr)
{
    TListItem* ListItem;
    AnsiString s;
    float f;

    if (TagTempListCdegRadioButton->Checked)
    {
       temp -= tagTempCalibC;
       s = s.FormatFloat("##0.### C", temp);
    }
    else
    {
       f = ((temp/5.0)*9.0) + 32.0;
       f -= tagTempCalibF;
       s = s.FormatFloat("##0.### F", f);
    }

    if (TagTempListView->Items->Count >= MAX_ENTRY_TEMP_LISTVIEW)
    {
       ListItem = TagTempListView->Items->Item[0];
       if (ListItem)
          ListItem->Delete();
       /*int ret = Application->MessageBox("Max entry for the Temperature ListView, Do you want to empty the list(RECOMMENDED)", "Programming Station", MB_YESNO);
       //if (ret == IDYES)
       {
          TagTempListView->Items->Clear();
          tagTempCount = 0;

          for (int i=0; i<MAX_TAG_DETECTED; i++)
          {
            tagTempArray[i].tagID = 0;
            tagTempArray[i].tagType = 6;
            tagTempArray[i].fGenID = 0xFF;
            tagTempArray[i].gID = false;
            tagTempArray[i].lastDetectTime = Now();
            tagTempArray[i].timeValue = 0;
          }
       }*/
    }

    ListItem = TagTempListView->Items->Add();
    ListItem->ImageIndex = -1;
    ListItem->SubItems->Add(tagID);
    ListItem->SubItems->Add(s);

    ListItem->SubItems->Add(Time());

    if ((status & 0x80) == 0x80)
    {
      if ((status & 0x04) == 0x04)  //0000 0100
         ListItem->SubItems->Add("Low");
      else if ((status & 0x08) == 0x08)  //0000 1000
         ListItem->SubItems->Add("High");
      else
         ListItem->SubItems->Add("Norm");
    }
    else
       ListItem->SubItems->Add("Norm");

    ListItem->SubItems->Add(Date());

    /*if (type == 0x01)    //0010 0000   //acc
       ListItem->SubItems->Add("ACC");
    else if (type == 0x02)   //0100 0000  //inv
       ListItem->SubItems->Add("INV");
    else if (type == 0x03)    //0110 0000  //ass
       ListItem->SubItems->Add("AST");
    else if (type == 0x07)    //1110 0000  //factory
       ListItem->SubItems->Add("FACT");
    else
       ListItem->SubItems->Add("");*/

    if ((type >= 0x01) && (type <= 0x07))
    {
        if (tagTypesAbr[type-1].data() == NULL)
        {
            AnsiString s;
            if (type == 1)
               s = "T00";
            else
            {
               s = "T0";
               s += type;
            }
            ListItem->SubItems->Add(s);
        }
        else
           ListItem->SubItems->Add(tagTypesAbr[type-1]);
    }
    else
       ListItem->SubItems->Add("");

    ListItem->SubItems->Add(rdr);
    TagTempListView->Refresh();
}
//----------------------------------------------------------------------------
void __fastcall TProgStationForm::UpdateTemperatureScreen()
{
    tempDisplayed = true;
    AnsiString s;
    if (TagTempLimitFdegRadioButton->Checked)
    {
       float temp;
       temp = ((tagTempHiLimit/5.0)*9.0) + 32.0;
       temp -= tagTempCalibF;
       s = s.FormatFloat("##0.###", temp);
       TagTempCurrUpLimitEdit->Text = s;
       //temp += ((tagTempCalibC/5.0)*9.0);
       //s = s.FormatFloat("##0.###", temp);
       //TagTempCurrUpCalibLimitEdit->Text = s;

       temp = ((tagTempLoLimit/5.0)*9.0) + 32.0;
       temp -= tagTempCalibF;
       s = s.FormatFloat("##0.###", temp);
       TagTempCurrLowLimitEdit->Text = s;
       //temp += ((tagTempCalibC/5.0)*9.0);
       //s = s.FormatFloat("##0.###", temp);
       //TagTempCurrLowCalibLimitEdit->Text = s;
    }
    else
    {
       s = s.FormatFloat("##0.###", tagTempHiLimit - tagTempCalibC);
       TagTempCurrUpLimitEdit->Text = s;
       //s = s.FormatFloat("##0.###", tagTempHiLimit-tagTempCalibC);
       //TagTempCurrUpCalibLimitEdit->Text = s;

       s = s.FormatFloat("##0.###", tagTempLoLimit - tagTempCalibC);
       TagTempCurrLowLimitEdit->Text = s;
       //s = s.FormatFloat("##0.###", tagTempLoLimit-tagTempCalibC);
       //TagTempCurrLowCalibLimitEdit->Text = s;
    }

    /*if (tagTempCalib == 0.0)
       s = "(0.00)";
    else if (tagTempCalib > 0)
       s = s.FormatFloat("(+#0.00 C)", tagTempCalib);
    else
       s = s.FormatFloat("(#0.00 C)", tagTempCalib);
    TagTempCalibValueLabel->Caption = s;*/

    //Periodic Report Time
    if ((tagTempPeriodByte & 0x80) == 0x80)
    {
       TagTempPeriodRepTimeHourRadioButton->Checked = true;
       TagTempPeriodRepTimeMinRadioButton->Checked = false;
    }
    else
    {
       TagTempPeriodRepTimeHourRadioButton->Checked = false;
       TagTempPeriodRepTimeMinRadioButton->Checked = true;
    }
    TagTempPeriodRepTimeEdit->Text = tagTempPeriodByte & 0x7F;

    //ave num read
    unsigned short n = tagTempCtrlByte & 0x03;
    if (n == 0)
       TagTempNumReadAveComboBox->Text = 4;
    else if (n == 1)
       TagTempNumReadAveComboBox->Text = 8;
    else if (n == 2)
       TagTempNumReadAveComboBox->Text = 2;
    else if (n == 3)
       TagTempNumReadAveComboBox->Text = 1;
    else
       TagTempNumReadAveComboBox->Text = "";

    //report if under lower limit
    n = tagTempCtrlByte & 0x04;
    if (n == 0)
       TagTempRepLowLimitCheckBox->Checked = false;
    else
       TagTempRepLowLimitCheckBox->Checked = true;

    //report if under upper limit
    n = tagTempCtrlByte & 0x08;
    if (n == 0)
       TagTempRepUpLimitCheckBox->Checked = false;
    else
       TagTempRepUpLimitCheckBox->Checked = true;

    //report periodic read
    n = tagTempCtrlByte & 0x80;
    if (n == 0)
       TagTempRepPeriodCheckBox->Checked = false;
    else
       TagTempRepPeriodCheckBox->Checked = true;

    //report enable logging
    n = tagTempCtrlByte & 0x40;
    if (n == 0)
       TagTempLoggingCheckBox->Checked = false;
    else
       TagTempLoggingCheckBox->Checked = true;

    //report enable logging
    n = tagTempCtrlByte & 0x10;
    if (n == 0)
       TagTempWarpAroundCheckBox->Checked = false;
    else
       TagTempWarpAroundCheckBox->Checked = true;

}
//------------------------------------------------------------------------------
int __fastcall TProgStationForm::GetNetworkInfoIndex(int reader)
{
   for (int i=0; i<listViewItemCount; i++)
   {
      if ((listViewInfo[i].reader == reader) &&
          listViewInfo[i].full)
          //(strcmp(listViewInfo[i].netStatus,"Active") == 0) &&
          //(strcmp(listViewInfo[i].rdrStatus, "Online") == 0))
      {

         return (i);
      }
   }

   return(-1);
}
//------------------------------------------------------------------------------
int __fastcall TProgStationForm::GetListViewInfoIndex(int reader)
{
   for (int i=0; i<listViewItemCount; i++)
   {
      if (listViewInfo[i].reader == reader)
         return (i);
   }

   return(-1);
}
//------------------------------------------------------------------------------
int __fastcall TProgStationForm::GetIpAddressIndex(int reader)
{
   for (unsigned i=0; i<numSockPoll; i++)
   {
      if (sockPollQue[i].reader == reader)
            return (i);
   }

   return (-1);
}
//------------------------------------------------------------------------------
int __fastcall TProgStationForm::GetSocketIndex(int reader)
{
   int i;

   for (i=0; i<MAX_DESCRIPTOR; i++)
   {
      if (AWSockets[i])
      {
         if (AWSockets[i]->reader == reader)
            return (i);
      }
   }

   return (-1);
}
//------------------------------------------------------------------------------
int __fastcall TProgStationForm::GetIpAddressIndex(AnsiString ip)
{
   for (int i=0; i<listViewItemCount; i++)
   {
      if (listViewInfo[i].ip == ip)
        return (i);
   }

   return (-1);
}
//------------------------------------------------------------------------------
int __fastcall TProgStationForm::GetSockConnectQueIndex(AnsiString ip)
{
   for (unsigned int i=0; i<numSelectedSockConnect; i++)
   {
      if (sockConnectQue[i].ip == ip)
        return (i);
   }

   return (-1);
}
//------------------------------------------------------------------------------
int __fastcall TProgStationForm::GetSockPollQueIndex(AnsiString ip)
{
   for (unsigned int i=0; i<numSockPoll; i++)
   {
      if (sockPollQue[i].ip == ip)
        return (i);
   }

   return (-1);
}
//------------------------------------------------------------------------------
int __fastcall TProgStationForm::GetSockPollQueIndex(int reader)
{
   for (unsigned int i=0; i<numSockPoll; i++)
   {
      if (sockPollQue[i].reader == reader)
        return (i);
   }

   return (-1);
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::WriteMemoryBitBtnClick(TObject *Sender)
{
   WriteMemoryBitBtn->Font->Color = clRed;

   programming = true;
   /*progStr = "Please wait. ";
   if (CallTagAccRadioButton->Checked)
   {
      tagTypeStr = "Access";
      progStr += "Writing to Access Tag";
   }
   else if (CallTagAssRadioButton->Checked)
   {
      tagTypeStr = "Asset";
      progStr += "Writing to Asset Tag";
   }
   else if (CallTagInvRadioButton->Checked)
   {
      tagTypeStr = "Inventory";
      progStr += "Writing to Inventory Tag";
   }
   else if (CallTagAnyRadioButton->Checked)
   {
      tagTypeStr = "Any Type";
      progStr += "Writing to All Tag Type";
   }

   if (CallTagAnyTagIDRadioButton->Checked)
      progStr += "s";
   else
      progStr += " ";

   //ShowTagsCheckBox->Checked = true;
   if (!CallTagIDRadioButton->Checked || CallTagAnyTagIDRadioButton->Checked)
      global = true;

   /*if (global)
   {
      CallTagBitBtn->Enabled = false;
      EnableReaderStaticText->Enabled = false;
      DisableReaderStaticText->Enabled = false;
      QueryReaderStaticText->Enabled = false;
      AssignReaderStaticText->Enabled = false;
      ReaderVersionStaticText->Enabled = false;
      ConfigTxTimeStaticText->Enabled = false;
      EnableFGenStaticText->Enabled = false;
      EnableRdrFGenStaticText->Enabled = false;
      ConfigFGenStaticText->Enabled = false;
      QueryFGenStaticText->Enabled = false;
      ConfigTagStaticText->Enabled = false;
      EnableTagStaticText->Enabled = false;
      DisableTagStaticText->Enabled = false;
      QueryTagStaticText->Enabled = false;
      CallTagStaticText->Enabled = false;
      AssignTagRdrStaticText->Enabled = false;
      ConfigTagRNDStaticText->Enabled = false;
   }*/

   if (!NewListItemCheckBox->Checked)
   {
      TxClearTagCtrls();
      RxClearTagCtrls();
      ProgammingMode = true;
      StaticText->Caption = "";
      DetectedMsg->Caption = "";
      TamperSWMsg->Caption = "";
      TagDetectedGroupBox->Caption = "Detected Tags";
      tagDetectCount = 0;
      type1Count = 0;
      type2Count = 0;
      type3Count = 0;
      type4Count = 0;
      type5Count = 0;
      type6Count = 0;
      typeFacCount = 0;
      ReportType1Label->Caption = "";
      ReportType2Label->Caption = "";
      ReportType3Label->Caption = "";
      ReportType4Label->Caption = "";
      ReportType5Label->Caption = "";
      ReportType6Label->Caption = "";
      ReportFACTLabel->Caption = "";
      ReportTotalLabel->Caption = "";
      ReportNDupLabel->Caption = "";
      DetectedTagListView->Items->Clear();
      for (int i=0; i<MAX_TAG_DETECTED; i++)
      {
          tagDetectedArray[i].tagID = 0;
          tagDetectedArray[i].tagType = 6;
          tagDetectedArray[i].cmd = 0;
          tagDetectedArray[i].fGenID = 0xFF;
          tagDetectedArray[i].gID = false;
          tagDetectedArray[i].lastDetectTime = Now();
      }
   }
   //StaticText->Caption = "";
   programming = true;
   progStr = "Please wait. ";

   tagTypeStr = WriteMemoryTagTypeComboBox->Text;
   progStr += "Writing ";
   progStr += WriteMemoryTagTypeComboBox->Text;
   progStr += " Tag";


   if ((WriteMemoryTagIDRangeRadioButton->Checked) && (WriteMemoryTagIDEdit->Text.data() == NULL))
   {
       Application->MessageBox("Error: Need Tag ID",
                               "Programming Station Information Dialog",
                               MB_OK | MB_ICONSTOP | MB_TOPMOST);
       WriteMemoryBitBtn->Enabled = true;
       return;
   }

   if ((WriteMemoryTagTypeComboBox->Text == "All Types") && (WriteMemoryAnyTagIDRadioButton->Checked))
    {
        int ret = Application->MessageBox ("Do you want to Write To ALL tags Memory?",
                                           "Programming Station Information Dialog",
                                           MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "All Tags";
        progStr = "Please wait. Writing To All Tags Memory";
    }
    else if (WriteMemoryTagTypeComboBox->Text == "All Types")
    {
       int ret = Application->MessageBox ("Do you want to Write To All Tag Types Memory?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "All Types";
        progStr = "Please wait. Writing To All Tag Types Memory";
    }
    else if (WriteMemoryAnyTagIDRadioButton->Checked)
    {
       int ret = Application->MessageBox ("Do you want to Write To Any Tag ID Memory?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        progStr = "Please wait. Writing To Any Tag ID Memory";
    }
    else
       progStr = "Please wait, writing to tag memory. ";

   StaticText->Caption = progStr;

   DisableTagStaticCommands();
   CMDEnableTimer->Enabled = true;
   WriteMemoryBitBtn->Enabled = false;

   retry = 0;
   totByteWritten = 0;
   lastWritePktID = 0;
   writePktID = 0;
   writeTagData = true;
   GeneralTimer->Enabled = true;

   WriteTimeLabel->Caption = "00  sec";

   if (LargeDataCheckBox->Checked)
   {
      //TDateTime wStartTime = Now();
      //Word Hour=0, Min=0, Sec=0, MSec=0;
      //DecodeTime(wStartTime, Hour, Min, Sec, MSec);
      //wStartTimeValue = Hour*60*60*1000 + Min*60*1000 + Sec*1000;
      displayElapsedTime = true;
      elapsedTime = 0;
      numWritePkts = 0;
      numWriteRetry = 0;
      WriteTimeLabel->Visible = true;
      //WriteNumPKtLabel->Visible = true;
      //WriteNumRetryLabel->Visible = true;
      writeDigitNum = 0;
      largDataWriteAck = false;

      largeDataWriteRetry = false;
      largeDataReadRetry = false;
      largeDataWriteRetryCt = 0;
      largeDataReadRetryCt = 0;
      WriteTimer->Enabled = false;
      ReadTimer->Enabled = false;

      lastReadPktID = 255;
      WriteNumRetryLabel->Caption = "pktID: 00";
      ReadNumRetryLabel->Caption = "oldPkt: 00";
      BytesWrittenLabel->Caption = "Bytes Written : 00 ";
      WriteTimeLabel->Caption = "00 sec ";
      WriteNumPKtLabel->Caption = "#Pkts: 00 ";
      largeDataReadAckCounter = 0;
      largeDataWriteAckCounter = 0;
      RetryTimer->Enabled = true;
      GeneralTimer->Enabled = true;
   }

   if(networkOn)
   {
      /*int rdr = atoi(WriteMemoryReaderIDComboBox->Text.c_str());
      int index = GetIpAddressIndex(rdr);
      if (index >= 0)
      {
            WriteTCPIPComm(WRITE_TAG_MEMORY, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
      }*/

      int rdr = atoi(WriteMemoryReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(WRITE_TAG_MEMORY, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(WRITE_TAG_MEMORY, 0, NULL, 0);

      numWritePkts += 1;
      AnsiString s = "#Pkts: ";
      s += numWritePkts;
      WriteNumPKtLabel->Caption = s;
      WriteNumPKtLabel->Invalidate();
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::WriteMemoryTagIDRadioButtonClick(
      TObject *Sender)
{
   WriteMemoryTagIDEdit->ReadOnly = false;
   WriteMemoryTagIDEdit->Color = clWhite;
   WriteMemoryTagIDEdit->Enabled = true;

   WriteMemoryTagIDRangeComboBox->Color = clMenu;
   WriteMemoryTagIDRangeComboBox->Font->Color = clGray;
   WriteMemoryTagIDRangeComboBox->Enabled = false;

   WriteMemoryTagRNLongRadioButton->Enabled = true;
   WriteMemoryTagRNShortRadioButton->Enabled = true;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::WriteMemoryAnyTagIDRadioButtonClick(
      TObject *Sender)
{
   WriteMemoryTagIDEdit->ReadOnly = true;
   WriteMemoryTagIDEdit->Color = clMenu;
   WriteMemoryTagIDEdit->Enabled = false;

   WriteMemoryTagIDRangeComboBox->Color = clMenu;
   WriteMemoryTagIDRangeComboBox->Font->Color = clGray;
   WriteMemoryTagIDRangeComboBox->Enabled = false;

   WriteMemoryTagRNLongRadioButton->Enabled = true;
   WriteMemoryTagRNShortRadioButton->Enabled = true;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::WriteMemoryBroadcastRdrCheckBoxClick(
      TObject *Sender)
{
   if (WriteMemoryBroadcastRdrCheckBox->State == cbChecked)
   {
      WriteMemoryReaderIDComboBox->Color = clMenu;
      WriteMemoryReaderIDComboBox->Enabled = false;
   }
   else
   {
      WriteMemoryReaderIDComboBox->Enabled = true;
      WriteMemoryReaderIDComboBox->Color = clWhite;
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::WriteMemoryHexRadioButtonClick(
      TObject *Sender)
{
    AnsiString s;
    int n;
    char buf[3] = {'\0', '\0'};

    for (int j=1; j<WriteMemoryStringGrid->RowCount; j++)
    {
       for (int i=1; i<WriteMemoryStringGrid->ColCount; i++)
       {
           s = WriteMemoryStringGrid->Cells[i][j];
           if (s.data() != NULL)
           {
              if (writeFormat == "CHAR")
              {
                 strcpy(buf, s.c_str());
                 n = (int)buf[0];
                 s = s.IntToHex(n, 2);
              }
              else
              {
                 n = atoi(s.c_str());
                 s = s.IntToHex(n, 2);
              }

              WriteMemoryStringGrid->Cells[i][j] = s;
           }
       }
    }

    writeFormat = "HEX";
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::WriteMemDecRadioButtonClick(
      TObject *Sender)
{
    AnsiString s;
    int n;
    char buf[3] = {'\0', '\0'};

    for (int j=1; j<WriteMemoryStringGrid->RowCount; j++)
    {
       for (int i=1; i<WriteMemoryStringGrid->ColCount; i++)
       {
           s = WriteMemoryStringGrid->Cells[i][j];
           if (s.data() != NULL)
           {
              if (writeFormat == "HEX")
                 n = HexToInt(s.c_str(), 2);
              else
              {
                 strcpy(buf, s.c_str());
                 n = (int)buf[0];
              }
              WriteMemoryStringGrid->Cells[i][j] = n;
           }
       }
    }

    writeFormat = "DEC";
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::WriteMemCharRadioButtonClick(TObject *Sender)
{
    AnsiString s;
    char c;
    int n;

    for (int j=1; j<WriteMemoryStringGrid->RowCount; j++)
    {
       for (int i=1; i<WriteMemoryStringGrid->ColCount; i++)
       {
           s = WriteMemoryStringGrid->Cells[i][j];
           if (s.data() != NULL)
           {
              if (writeFormat == "HEX")
                 n = HexToInt(s.c_str(), 2);
              else if (writeFormat == "DEC")
                 n = atoi(s.c_str());
               c = (char)n;
              WriteMemoryStringGrid->Cells[i][j] = c;
           }
       }
    }

    writeFormat = "CHAR";
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ReadMemoryTagIDRadioButtonClick(
      TObject *Sender)
{
   ReadMemoryTagIDEdit->ReadOnly = false;
   ReadMemoryTagIDEdit->Color = clWhite;
   ReadMemoryTagIDEdit->Enabled = true;

   ReadMemoryTagIDRangeComboBox->Color = clMenu;
   ReadMemoryTagIDRangeComboBox->Font->Color = clGray;
   ReadMemoryTagIDRangeComboBox->Enabled = false;

   ReadMemoryTagRNLongRadioButton->Enabled = true;
   ReadMemoryTagRNShortRadioButton->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ReadMemoryAnyTagIDRadioButtonClick(
      TObject *Sender)
{
   ReadMemoryTagIDEdit->ReadOnly = true;
   ReadMemoryTagIDEdit->Color = clMenu;
   ReadMemoryTagIDEdit->Enabled = false;

   ReadMemoryTagIDRangeComboBox->Color = clMenu;
   ReadMemoryTagIDRangeComboBox->Font->Color = clGray;
   ReadMemoryTagIDRangeComboBox->Enabled = false;

   ReadMemoryTagRNLongRadioButton->Enabled = true;
   ReadMemoryTagRNShortRadioButton->Enabled = true;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ReadMemoryHexRadioButtonClick(
      TObject *Sender)
{
   AnsiString s;
    int n;
    unsigned char buf[3] = {'\0', '\0'};

    for (int j=1; j<ReadMemoryStringGrid->RowCount; j++)
    {
       for (int i=1; i<ReadMemoryStringGrid->ColCount; i++)
       {
           s = ReadMemoryStringGrid->Cells[i][j];
           if (s.data() != NULL)
           {
              if (readFormat == "CHAR")
              {
                 strcpy(buf, s.c_str());
                 n = (int)buf[0];
                 s = s.IntToHex(n, 2);
              }
              else
              {
                 n = atoi(s.c_str());
                 s = s.IntToHex(n, 2);
              }

              ReadMemoryStringGrid->Cells[i][j] = s;
           }
       }
    }

    readFormat = "HEX";
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ReadMemDecRadioButtonClick(
      TObject *Sender)
{
   AnsiString s;
    unsigned int n;
    unsigned char buf[3] = {'\0', '\0'};

    for (int j=1; j<ReadMemoryStringGrid->RowCount; j++)
    {
       for (int i=1; i<ReadMemoryStringGrid->ColCount; i++)
       {
           s = ReadMemoryStringGrid->Cells[i][j];
           if (s.data() != NULL)
           {
              if (readFormat == "HEX")
                 n = HexToInt(s.c_str(), 2);
              else
              {
                 strcpy(buf, s.c_str());
                 n = (unsigned int)buf[0];
              }
              ReadMemoryStringGrid->Cells[i][j] = n;
           }
       }
    }

    readFormat = "DEC";
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ReadMemCharRadioButtonClick(
      TObject *Sender)
{
   AnsiString s;
    char c;
    int n;

    for (int j=1; j<ReadMemoryStringGrid->RowCount; j++)
    {
       for (int i=1; i<ReadMemoryStringGrid->ColCount; i++)
       {
           s = ReadMemoryStringGrid->Cells[i][j];
           if (s.data() != NULL)
           {
              if (readFormat == "HEX")
                 n = HexToInt(s.c_str(), 2);
              else if (readFormat == "DEC")
                 n = atoi(s.c_str());
               c = (char)n;
              ReadMemoryStringGrid->Cells[i][j] = c;
           }
       }
    }

    readFormat = "CHAR";
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ReadMemoryNumByteEditChange(
      TObject *Sender)
{
   /*int size = atoi(ReadMemoryNumByteEdit->Text.c_str());
   if (size == 0)
   {
     ReadMemoryStringGrid->RowCount = 1;
     return;
   }
   int row = size/10;
   if  ((size - (row*10)) != 0)
      row += 1;
   row += 1;
   ReadMemoryStringGrid->RowCount = row;

   int k=0;
    for (int i = 1, k=0; i<row; i++)
       ReadMemoryStringGrid->Cells[0][i] = IntToStr(++k);*/
}
//---------------------------------------------------------------------------


void __fastcall TProgStationForm::WriteMemoryClearBitBtnClick(
      TObject *Sender)
{
   if (!LargeDataCheckBox->Checked)  //Clear
   {
      for (int i = 1; i < WriteMemoryStringGrid->ColCount; i++)
          for (int j = 1; j < WriteMemoryStringGrid->RowCount; j++)
              WriteMemoryStringGrid->Cells[i][j] = "";
   }
   else   //Stop
   {
       GeneralTimer->Enabled = false;
       writeTagData = false;
       retry = 0;
       totByteWritten = 0;
       lastWritePktID = 0;
       writePktID = 0;
       numWritePkts = 0;
       numWriteRetry = 0;
       writeDigitNum = 0;
       displayElapsedTime = false;
       RetryTimer->Enabled = false;
       ReadTimer->Enabled = false;
       WriteTimer->Enabled = false;
       displayElapsedTime = false;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::TagTempRepLowLimitCheckBoxClick(
      TObject *Sender)
{
   if (!TagTempChangeReportCheckBox->Checked && mouseClicked)
   {
      mouseClicked = false;
      if (TagTempRepLowLimitCheckBox->Checked)
         TagTempRepLowLimitCheckBox->Checked = false;
      else
         TagTempRepLowLimitCheckBox->Checked = true;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::TagTempRepUpLimitCheckBoxClick(
      TObject *Sender)
{
   if (!TagTempChangeReportCheckBox->Checked && mouseClicked)
   {
      mouseClicked = false;
      if (TagTempRepUpLimitCheckBox->Checked)
         TagTempRepUpLimitCheckBox->Checked = false;
      else
         TagTempRepUpLimitCheckBox->Checked = true;
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::TagTempRepPeriodCheckBoxClick(
      TObject *Sender)
{
   if (!TagTempChangeReportCheckBox->Checked && mouseClicked)
   {
      mouseClicked = false;
      if (TagTempRepPeriodCheckBox->Checked)
         TagTempRepPeriodCheckBox->Checked = false;
      else
         TagTempRepPeriodCheckBox->Checked = true;
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::TagTempChangeReportCheckBoxClick(
      TObject *Sender)
{
   if (TagTempChangeReportCheckBox->Checked)
   {
      TagTempPeriodRepTimeEdit->ReadOnly = false;
      TagTempPeriodRepTimeEdit->Color = clWhite;
      TagTempNumReadAveComboBox->Enabled = true;
      TagTempNumReadAveComboBox->Color = clWhite;
      TagTempRepLowLimitCheckBox->Enabled = true;
      TagTempRepUpLimitCheckBox->Enabled = true;
      TagTempRepPeriodCheckBox->Enabled = true;
      TagTempPeriodRepTimeHourRadioButton->Enabled = true;
      TagTempPeriodRepTimeMinRadioButton->Enabled = true;
      TagTempLoggingCheckBox->Enabled = true;
      if (TagTempLoggingCheckBox->Checked)
      {
          TagTempWarpAroundCheckBox->Enabled = true;
          TagTempTimeStampBitBtn->Enabled = true;
      }
      else
      {
          TagTempWarpAroundCheckBox->Enabled = false;
          TagTempWarpAroundCheckBox->Checked = false;
          TagTempTimeStampBitBtn->Enabled = false;
      }
   }
   else
   {
      TagTempPeriodRepTimeEdit->ReadOnly = true;
      TagTempPeriodRepTimeEdit->Color = clMenu;
      TagTempNumReadAveComboBox->Enabled = false;
      TagTempNumReadAveComboBox->Color = clMenu;
      TagTempRepLowLimitCheckBox->Enabled = false;
      TagTempRepUpLimitCheckBox->Enabled = false;
      TagTempRepPeriodCheckBox->Enabled = false;
      TagTempPeriodRepTimeHourRadioButton->Enabled = false;
      TagTempPeriodRepTimeMinRadioButton->Enabled = false;
      TagTempLoggingCheckBox->Enabled = false;
      TagTempWarpAroundCheckBox->Enabled = false;
      TagTempTimeStampBitBtn->Enabled = false;
      if (!TagTempLoggingCheckBox->Checked)
          TagTempWarpAroundCheckBox->Checked = false;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::TagTempChangeUpLimitCheckBoxClick(
      TObject *Sender)
{
   if (TagTempChangeUpLimitCheckBox->Checked)
   {
      TagTempNewUpLimitEdit->Color = clInfoBk;
      TagTempNewUpLimitEdit->ReadOnly = false;
      TagTempNewUpLimitEdit->Font->Color = clBlue;

      TagTempNewLowLimitEdit->Color = clInfoBk;
      TagTempNewLowLimitEdit->ReadOnly = false;
      TagTempNewLowLimitEdit->Font->Color = clBlue;
   }
   else
   {
      TagTempNewUpLimitEdit->Color = clBtnFace;
      TagTempNewUpLimitEdit->ReadOnly = true;
      TagTempNewUpLimitEdit->Font->Color = clGray;

      TagTempNewLowLimitEdit->Color = clBtnFace;
      TagTempNewLowLimitEdit->ReadOnly = true;
      TagTempNewLowLimitEdit->Font->Color = clGray;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::TagTempChangeLowLimitCheckBoxClick(
      TObject *Sender)
{
   if (TagTempChangeLowLimitCheckBox->Checked)
   {
      TagTempNewLowLimitEdit->Color = clInfoBk;
      TagTempNewLowLimitEdit->ReadOnly = false;
      TagTempNewLowLimitEdit->Font->Color = clBlue;
   }
   else
   {
      TagTempNewLowLimitEdit->Color = clBtnFace;
      TagTempNewLowLimitEdit->ReadOnly = true;
      TagTempNewLowLimitEdit->Font->Color = clGray;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::TagTempTagIDRadioButtonClick(
      TObject *Sender)
{
   TagTempTagIDEdit->ReadOnly = false;
   TagTempTagIDEdit->Color = clWhite;
   TagTempTagIDEdit->Enabled = true;

   TagTempTagIDRangeComboBox->Color = clMenu;
   TagTempTagIDRangeComboBox->Enabled = false;
   TagTempTagIDRangeComboBox->Font->Color = clGray;

   TagTempTagRNLongRadioButton->Enabled = true;
   TagTempTagRNShortRadioButton->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::TagTempAnyTagIDRadioButtonClick(
      TObject *Sender)
{
   TagTempTagIDEdit->ReadOnly = true;
   TagTempTagIDEdit->Color = clMenu;
   TagTempTagIDEdit->Enabled = false;

   TagTempTagIDRangeComboBox->Color = clMenu;
   TagTempTagIDRangeComboBox->Enabled = false;
   TagTempTagIDRangeComboBox->Font->Color = clGray;

   TagTempTagRNLongRadioButton->Enabled = true;
   TagTempTagRNShortRadioButton->Enabled = true;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::DisplayTagTemperature(unsigned char status)
{
    tempDisplayed = true;
    AnsiString s;

    if ((status & 0x80) == 0x80)
    {
      if ((status & 0x04) == 0x04)  //0000 0100
      {
         TempStatusStaticText->Caption = "LOW";
         TempStatusStaticText->Font->Color = clBlue;
         TagTempTempValueEdit->Font->Color = clBlue;
      }
      else if ((status & 0x08) == 0x08)  //0000 1000
      {
         TempStatusStaticText->Caption = "HIGH";
         TempStatusStaticText->Font->Color = clRed;
         TagTempTempValueEdit->Font->Color = clRed;
      }
      else
      {
         TempStatusStaticText->Caption = "NORMAL";
         TempStatusStaticText->Font->Color = clGreen;
         TagTempTempValueEdit->Font->Color = clGreen;
      }
    }
    else
    {
       TempStatusStaticText->Caption = "NORMAL";
       TempStatusStaticText->Font->Color = clGreen;
       TagTempTempValueEdit->Font->Color = clGreen;
    }

    if (TagTempFdegRadioButton->Checked)
    {
       float temp;
       temp = ((tagTemperature/5.0)*9.0) + 32.0;
       temp -= tagTempCalibF;
       s = s.FormatFloat("##0.###", temp);
       TagTempTempValueEdit->Text = s;
    }
    else
    {
       if (tagTemperature < 0)
           s = s.FormatFloat("##0.###", tagTemperature + tagTempCalibC);
       else
           s = s.FormatFloat("##0.###", tagTemperature - tagTempCalibC);
       TagTempTempValueEdit->Text = s;
    }
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::TagTempLimitCdegRadioButtonClick(
      TObject *Sender)
{
   AnsiString s;

   if (TagTempCurrUpLimitEdit->Text.data() != NULL)
   {
      s = s.FormatFloat("##0.###", tagTempHiLimit - tagTempCalibC);
      TagTempCurrUpLimitEdit->Text = s;
      //s = s.FormatFloat("##0.###", tagTempHiLimit-tagTempCalibC);
      //TagTempCurrUpCalibLimitEdit->Text = s;
   }

   if (TagTempCurrLowLimitEdit->Text.data() != NULL)
   {
      s = s.FormatFloat("##0.###", tagTempLoLimit - tagTempCalibC);
      TagTempCurrLowLimitEdit->Text = s;
      //s = s.FormatFloat("##0.###", tagTempLoLimit-tagTempCalibC);
      //TagTempCurrLowCalibLimitEdit->Text = s;
   }

   if (tagTempCalibC == 0.0)
      s = "(0.00)";
   else if (tagTempCalibC > 0)
      s = s.FormatFloat("(+#0.00 C)", tagTempCalibC);
   else
      s = s.FormatFloat("(-#0.00 C)", -tagTempCalibC);
    TagTempCalibValueLabel->Caption = s;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::TagTempLimitFdegRadioButtonClick(
      TObject *Sender)
{
   float temp;
   AnsiString s;

   if (TagTempCurrUpLimitEdit->Text.data() != NULL)
   {
      s = TagTempCurrUpLimitEdit->Text;
      temp = atof(s.c_str());
      temp = ((temp/5.0)*9.0) + 32.0;
      //temp = ((tagTempHiLimit/5.0)*9.0) + 32.0;
      //temp -= tagTempCalibF;
      s = s.FormatFloat("##0.###", temp);
      TagTempCurrUpLimitEdit->Text = s;
      //temp += ((tagTempCalibC/5.0)*9.0);
      //s = s.FormatFloat("##0.###", temp);
      //TagTempCurrUpCalibLimitEdit->Text = s;
   }

   if (TagTempCurrLowLimitEdit->Text.data() != NULL)
   {
      s = TagTempCurrLowLimitEdit->Text;
      temp = atof(s.c_str());
      temp = ((temp/5.0)*9.0) + 32.0;
      //temp = ((tagTempLoLimit/5.0)*9.0) + 32.0;
      //temp -= tagTempCalibF;
      s = s.FormatFloat("##0.###", temp);
      TagTempCurrLowLimitEdit->Text = s;
      //temp += ((tagTempCalibC/5.0)*9.0);
      //s = s.FormatFloat("##0.###", temp);
      //TagTempCurrLowCalibLimitEdit->Text = s;
   }

   //float f = ((tagTempCalibC/5.0)*9.0);
   float f = tagTempCalibF;
   if (f == 0.0)
      s = "(0.00)";
   else if (f > 0)
      s = s.FormatFloat("(+#0.00 F)", f);
   else
      s = s.FormatFloat("(-#0.00 F)", -f);
    TagTempCalibValueLabel->Caption = s;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::TagTempRefreshBitBtnClick(TObject *Sender)
{
   UpdateTagTempScreen();
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::TagTempReadTempValueBitBtnClick(
      TObject *Sender)
{
   tempDisplayed = false;
   TagTempTempValueEdit->Text = "";
   TempStatusStaticText->Caption = "";
   readTemp = true;

   if(networkOn)
   {
      /*int rdr = atoi(TagTempReaderIDComboBox->Text.c_str());
      int index = GetIpAddressIndex(rdr);
      if (index >= 0)
      {
         WriteTCPIPComm(READ_TAG_TEMPERATURE, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
      }
      else
      {
         Application->MessageBox("Did not find IP address.",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return;
      }*/

      int rdr = atoi(TagTempReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(READ_TAG_TEMPERATURE, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
      {
         StaticText->Caption = "No matching socket for the reader.";
         return;
      }
   }
   else if (RS232On)
   {
      WriteRS232Comm(READ_TAG_TEMPERATURE, 0, NULL, 0);
   }

   EnableReaderStaticText->Enabled = false;
   DisableReaderStaticText->Enabled = false;
   QueryReaderStaticText->Enabled = false;
   AssignReaderStaticText->Enabled = false;
   ReaderVersionStaticText->Enabled = false;
   ConfigTxTimeStaticText->Enabled = false;
   RelayStaticText->Enabled = false;
   InputsStaticText->Enabled = false;
   //EnableRdrFGenStaticText->Enabled = false;
   ConfigFGenStaticText->Enabled = false;
   QueryFGenStaticText->Enabled = false;
   ConfigTagStaticText->Enabled = false;
   EnableTagStaticText->Enabled = false;
   DisableTagStaticText->Enabled = false;
   QueryTagStaticText->Enabled = false;
   FGenResetStaticText->Enabled = false;
   SmartFGenStaticText->Enabled = false;
   CallTagStaticText->Enabled = false;
   AssignTagRdrStaticText->Enabled = false;
   ConfigTagRNDStaticText->Enabled = false;
   WriteMemoryStaticText->Enabled = false;
   ReadMemoryStaticText->Enabled = false;
   TagTempStaticText->Enabled = false;
   TagTempReadTempValueBitBtn->Enabled = false;
   TagTempRefreshBitBtn->Enabled = false;
   TagTempBitBtn->Enabled = false;

   StaticText->Caption = "Please wait. Requesting tag temperature.";
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::TagTempCdegRadioButtonClick(
      TObject *Sender)
{
   AnsiString s;
   if (tagTemperature < 0)
       s = s.FormatFloat("##0.###", tagTemperature + tagTempCalibC);
   else
       s = s.FormatFloat("##0.###", tagTemperature - tagTempCalibC);
   TagTempTempValueEdit->Text = s;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::TagTempFdegRadioButtonClick(
      TObject *Sender)
{
   float temp;
   AnsiString s;

   temp = ((tagTemperature/5.0)*9.0) + 32.0;
   temp -= tagTempCalibF;
   s = s.FormatFloat("##0.###", temp);
   TagTempTempValueEdit->Text = s;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::TagTempPeriodRepTimeHourRadioButtonClick(
      TObject *Sender)
{
   if (!TagTempChangeReportCheckBox->Checked && mouseClicked)
   {
      mouseClicked = false;
      if (TagTempPeriodRepTimeHourRadioButton->Checked)
      {
         TagTempPeriodRepTimeHourRadioButton->Checked = false;
         TagTempPeriodRepTimeMinRadioButton->Checked = true;
      }
      else
      {
         TagTempPeriodRepTimeHourRadioButton->Checked = true;
         TagTempPeriodRepTimeMinRadioButton->Checked = false;
      }
   }
   else if (TagTempPeriodRepTimeHourRadioButton->Checked == false)
      TagTempPeriodRepTimeHourRadioButton->Checked = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::TagTempPeriodRepTimeMinRadioButtonClick(
      TObject *Sender)
{
   if (!TagTempChangeReportCheckBox->Checked && mouseClicked)
   {
      mouseClicked = false;
      if (TagTempPeriodRepTimeMinRadioButton->Checked)
      {
         TagTempPeriodRepTimeMinRadioButton->Checked = false;
         TagTempPeriodRepTimeHourRadioButton->Checked = true;
      }
      else
      {
         TagTempPeriodRepTimeMinRadioButton->Checked = true;
         TagTempPeriodRepTimeHourRadioButton->Checked = false;
      }
   }
   else if (TagTempPeriodRepTimeMinRadioButton->Checked == false)
      TagTempPeriodRepTimeMinRadioButton->Checked = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::TagTempPeriodRepTimeHourRadioButtonMouseDown(
      TObject *Sender, TMouseButton Button, TShiftState Shift, int X,
      int Y)
{
    mouseClicked = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::TagTempPeriodRepTimeMinRadioButtonMouseDown(
      TObject *Sender, TMouseButton Button, TShiftState Shift, int X,
      int Y)
{
   mouseClicked = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::TagTempRepLowLimitCheckBoxMouseDown(
      TObject *Sender, TMouseButton Button, TShiftState Shift, int X,
      int Y)
{
   mouseClicked = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::TagTempRepUpLimitCheckBoxMouseDown(
      TObject *Sender, TMouseButton Button, TShiftState Shift, int X,
      int Y)
{
   mouseClicked = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::TagTempRepPeriodCheckBoxMouseDown(
      TObject *Sender, TMouseButton Button, TShiftState Shift, int X,
      int Y)
{
   mouseClicked = true;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::TagTempDisplayListCheckBoxClick(
      TObject *Sender)
{
   if (TagTempDisplayListCheckBox->Checked)
   {
      TagTempListGroupBox->Visible = true;
      TagDetectedGroupBox->Visible = false;
   }
   else
   {
      TagDetectedGroupBox->Visible = true;
      TagTempListGroupBox->Visible = false;
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ClearTagTempListBitBtnClick(
      TObject *Sender)
{
   TagTempListView->Items->Clear();
   tagTempCount = 0;

   for (int i=0; i<MAX_TAG_DETECTED; i++)
   {
      tagTempArray[i].tagID = 0;
      tagTempArray[i].tagType = 6;
      tagTempArray[i].fGenID = 0xFF;
      tagTempArray[i].gID = false;
      tagTempArray[i].lastDetectTime = Now();
      tagTempArray[i].timeValue = 0;
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::TagTempListViewColumnClick(
      TObject *Sender, TListColumn *Column)
{
   columnToSort = Column->Index;
  ((TCustomListView *)Sender)->AlphaSort();
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::TagTempListViewCompare(TObject *Sender,
      TListItem *Item1, TListItem *Item2, int Data, int &Compare)
{
    int index;
    AnsiString selectedItem1;
    AnsiString selectedItem2;
    AnsiString s;
    TStrings* str;
    int n1, n2;
    float f1, f2;

    if (columnToSort == 1)  //tag ID
    {
         str = Item1->SubItems;
         selectedItem1 = GetItem(str, 0);

         str = Item2->SubItems;
         selectedItem2 = GetItem(str, 0);

         n1 = atoi(selectedItem1.c_str());
         n2 = atoi(selectedItem2.c_str());
         if (n1 == n2)
            Compare = 0;
         else if (n1 > n2)
            Compare = 1;
         else
           Compare = -1;
      }
      else if (columnToSort == 2) //temp
      {
         str = Item1->SubItems;
         selectedItem1 = GetItem(str, 1);

         str = Item2->SubItems;
         selectedItem2 = GetItem(str, 1);

         f1 = atof(selectedItem1.c_str());
         f2 = atof(selectedItem2.c_str());
         if (f1 == f2)
            Compare = 0;
         else if (f1 > f2)
            Compare = 1;
         else
           Compare = -1;
      }
      else if (columnToSort == 3) //time
      {
         str = Item1->SubItems;
         selectedItem1 = GetItem(str, 2);
         str = Item2->SubItems;
         selectedItem2 = GetItem(str, 2);
         Compare = CompareText(selectedItem1, selectedItem2);
      }
      else if (columnToSort == 4)  //status
      {
         str = Item1->SubItems;
         selectedItem1 = GetItem(str, 3);
         str = Item2->SubItems;
         selectedItem2 = GetItem(str, 3);
         Compare = CompareText(selectedItem1, selectedItem2);
      }
      else if (columnToSort == 5)  //Date
      {
         str = Item1->SubItems;
         selectedItem1 = GetItem(str, 4);
         str = Item2->SubItems;
         selectedItem2 = GetItem(str, 4);
         Compare = CompareText(selectedItem1, selectedItem2);
      }
      else if (columnToSort == 6)  //Date
      {
         str = Item1->SubItems;
         selectedItem1 = GetItem(str, 5);
         str = Item2->SubItems;
         selectedItem2 = GetItem(str, 5);
         Compare = CompareText(selectedItem1, selectedItem2);
      }
      else if (columnToSort == 7)  //type
      {
         str = Item1->SubItems;
         selectedItem1 = GetItem(str, 6);
         str = Item2->SubItems;
         selectedItem2 = GetItem(str, 6);
         Compare = CompareText(selectedItem1, selectedItem2);
      }
      else if (columnToSort == 8) //reader
      {
         str = Item1->SubItems;
         selectedItem1 = GetItem(str, 7);

         str = Item2->SubItems;
         selectedItem2 = GetItem(str, 7);

         f1 = atof(selectedItem1.c_str());
         f2 = atof(selectedItem2.c_str());
         if (f1 == f2)
            Compare = 0;
         else if (f1 > f2)
            Compare = 1;
         else
           Compare = -1;
      }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::TagTempListCdegRadioButtonClick(TObject *Sender)
{
   TListItem* item;
   AnsiString s;
   TStrings* ts;
   float f;
   AnsiString type;

   for (int i=0; i<TagTempListView->Items->Count; i++)
   {
      item = TagTempListView->Items->Item[i];
      ts = item->SubItems;
      s = ts->Text;
      s = GetItem(ts, 1);
      type = s.SubString(s.Length(), 1);
      f = atof(s.c_str());
      if (type == "F")
      {
         f -= 32.0;
         f = (f*5.0)/9.0;
         s = s.FormatFloat("##0.### C", f);
         ts->Delete(1);
         ts->Insert(1, s);
         s = ts->Text;
      }
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::TagTempListFdegRadioButtonClick(
      TObject *Sender)
{
   TListItem* item;
   AnsiString s;
   TStrings* ts;
   float f;
   AnsiString type;

   for (int i=0; i<TagTempListView->Items->Count; i++)
   {
      item = TagTempListView->Items->Item[i];
      ts = item->SubItems;
      s = ts->Text;
      s = GetItem(ts, 1);
      type = s.SubString(s.Length(), 1);
      f = atof(s.c_str());

      if (type == "C")
      {
         f = ((f/5.0)*9.0) + 32.0;
         s = s.FormatFloat("##0.### F", f);
         ts->Delete(1);
         ts->Insert(1, s);
         s = ts->Text;
      }

   }
}
//------------------------------------------------------------------------------



void __fastcall TProgStationForm::TagTempListViewCustomDrawItem(
      TCustomListView *Sender, TListItem *Item, TCustomDrawState State,
      bool &DefaultDraw)
{
   TStrings* str = Item->SubItems;
   AnsiString selectedItem = GetItem(str, 3);

   if (selectedItem == "High")
      TagTempListView->Canvas->Font->Color = clRed;
   else if (selectedItem == "Low")
     TagTempListView->Canvas->Font->Color = clBlue;
   else   //Norm
     TagTempListView->Canvas->Font->Color = clGreen;
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::FGenConfigAccessRadioButtonClick(
      TObject *Sender)
{
   /*if (!FGenConfigTagTypeModifyCheckBox->Checked)
   {
      if (mouseClicked)
      {
         mouseClicked = false;

         if (FGenConfigAccessRadioButton->Checked)
            FGenConfigAccessRadioButton->Checked = false;
         else
            FGenConfigAccessRadioButton->Checked = true;

         if (fgenTagtype == 1)
            FGenConfigAccessRadioButton->Checked = true;
         else if (fgenTagtype == 2)
            FGenConfigAssetRadioButton->Checked = true;
         else if (fgenTagtype == 3)
            FGenConfigInventoryRadioButton->Checked = true;
         else if (fgenTagtype == 4)
            FGenConfigAnyTypeRadioButton->Checked = true;

      }
   }*/
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::FGenConfigAccessRadioButtonMouseDown(
      TObject *Sender, TMouseButton Button, TShiftState Shift, int X,
      int Y)
{
   /*mouseClicked = true;
   if (FGenConfigAccessRadioButton->Checked)
      fgenTagtype = 1;
   else if (FGenConfigAssetRadioButton->Checked)
      fgenTagtype = 2;
   else if (FGenConfigInventoryRadioButton->Checked)
      fgenTagtype = 3;
   else
      fgenTagtype = 4;*/
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::FGenConfigAssetRadioButtonClick(
      TObject *Sender)
{
   /*if (!FGenConfigTagTypeModifyCheckBox->Checked)
   {
      if (mouseClicked)
      {
         mouseClicked = false;

         if (FGenConfigAssetRadioButton->Checked)
            FGenConfigAssetRadioButton->Checked = false;
         else
            FGenConfigAssetRadioButton->Checked = true;

         if (fgenTagtype == 1)
            FGenConfigAccessRadioButton->Checked = true;
         else if (fgenTagtype == 2)
            FGenConfigAssetRadioButton->Checked = true;
         else if (fgenTagtype == 3)
            FGenConfigInventoryRadioButton->Checked = true;
         else if (fgenTagtype == 4)
            FGenConfigAnyTypeRadioButton->Checked = true;

      }
   }*/
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::FGenConfigInventoryRadioButtonClick(
      TObject *Sender)
{
   /*if (!FGenConfigTagTypeModifyCheckBox->Checked)
   {
      if (mouseClicked)
      {
         mouseClicked = false;

         if (FGenConfigInventoryRadioButton->Checked)
            FGenConfigInventoryRadioButton->Checked = false;
         else
            FGenConfigInventoryRadioButton->Checked = true;

         if (fgenTagtype == 1)
            FGenConfigAccessRadioButton->Checked = true;
         else if (fgenTagtype == 2)
            FGenConfigAssetRadioButton->Checked = true;
         else if (fgenTagtype == 3)
            FGenConfigInventoryRadioButton->Checked = true;
         else if (fgenTagtype == 4)
            FGenConfigAnyTypeRadioButton->Checked = true;

      }
   }*/
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::FGenConfigAnyTypeRadioButtonClick(
      TObject *Sender)
{
   //unsigned short type = 0;

   /*if (!FGenConfigTagTypeModifyCheckBox->Checked)
   {
      if (mouseClicked)
      {
         mouseClicked = false;

         if (FGenConfigAnyTypeRadioButton->Checked)
            FGenConfigAnyTypeRadioButton->Checked = false;
         else
            FGenConfigAnyTypeRadioButton->Checked = true;

         if (fgenTagtype == 1)
            FGenConfigAccessRadioButton->Checked = true;
         else if (fgenTagtype == 2)
            FGenConfigAssetRadioButton->Checked = true;
         else if (fgenTagtype == 3)
            FGenConfigInventoryRadioButton->Checked = true;
         else if (fgenTagtype == 4)
            FGenConfigAnyTypeRadioButton->Checked = true;
      }*/
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::FGenConfigAssetRadioButtonMouseDown(
      TObject *Sender, TMouseButton Button, TShiftState Shift, int X,
      int Y)
{
   /*mouseClicked = true;
   if (FGenConfigAccessRadioButton->Checked)
      fgenTagtype = 1;
   else if (FGenConfigAssetRadioButton->Checked)
      fgenTagtype = 2;
   else if (FGenConfigInventoryRadioButton->Checked)
      fgenTagtype = 3;
   else
      fgenTagtype = 4;*/
}
//------------------------------------------------------------------------------

void __fastcall TProgStationForm::FGenConfigInventoryRadioButtonMouseDown(
      TObject *Sender, TMouseButton Button, TShiftState Shift, int X,
      int Y)
{
   /*mouseClicked = true;
   if (FGenConfigAccessRadioButton->Checked)
      fgenTagtype = 1;
   else if (FGenConfigAssetRadioButton->Checked)
      fgenTagtype = 2;
   else if (FGenConfigInventoryRadioButton->Checked)
      fgenTagtype = 3;
   else
      fgenTagtype = 4; */
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::FGenConfigAnyTypeRadioButtonMouseDown(
      TObject *Sender, TMouseButton Button, TShiftState Shift, int X,
      int Y)
{
   /*mouseClicked = true;
   if (FGenConfigAccessRadioButton->Checked)
      fgenTagtype = 1;
   else if (FGenConfigAssetRadioButton->Checked)
      fgenTagtype = 2;
   else if (FGenConfigInventoryRadioButton->Checked)
      fgenTagtype = 3;
   else
      fgenTagtype = 4; */
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::FGenConfigActivePIRCheckBoxClick(
      TObject *Sender)
{
   if (!FGenConfigTxTimeModifyCheckBox->Checked)
   {
      if (mouseClicked)
      {
         mouseClicked = false;
         if (FGenConfigActivePIRCheckBox->Checked)
            FGenConfigActivePIRCheckBox->Checked = false;
         else
             FGenConfigActivePIRCheckBox->Checked = true;
      }
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::FGenConfigActivePIRCheckBoxMouseDown(
      TObject *Sender, TMouseButton Button, TShiftState Shift, int X,
      int Y)
{
    mouseClicked = true;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::SaveTagTempCalibToTag()
{
   if (readerFgenButtonActivated)
   {
      ReaderFgenToolButton->Hint = "Set Programming Station To Field Generator Mode";
      readerFgenButtonActivated = false;
      if(networkOn)
         CloseNetworkConnection();
      else if (RS232On)
         ClosePort();
      EnableAllCommands(false);
      if (OpenSerial(comPort, lastBaudrate))
      {
         ProgStationForm->PortOpen = true;
         baudRate = curBaudrate = lastBaudrate;
         PlaySound("Ding.wav", NULL, SND_ASYNC );
      }
      EnableAllCommands(true);

      readerOffLine = true;
      readerOnLine = false;
      fieldGenOffLine = true;
      fieldGenOnLine = false;
   }

   tempDisplayed = false;

   //WriteRS232Comm(CALL_TAG, 0, NULL, 0);
   if(networkOn)
   {
      /*int rdr = atoi(ReadMemoryReaderIDComboBox->Text.c_str());
      int index = GetIpAddressIndex(rdr);

      if (index >= 0)
      {
         WriteTCPIPComm(WRITE_TAG_TEMP_CONFIG, 99, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
         StaticText->Caption = "Please wait. Configuring tag temperature status.";
      }*/

      int rdr = atoi(ReadMemoryReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(WRITE_TAG_TEMP_CONFIG, 99, NULL, index, 'S', NULL, 0, index);
      }
      else
      {
         StaticText->Caption = "No matching socket for the reader.";
         return;
      }
   }
   else if (RS232On)
   {
      WriteRS232Comm(WRITE_TAG_TEMP_CONFIG, 99, NULL, 0);
      StaticText->Caption = "Please wait. Configuring tag temperature status.";
   }

   //EnableTagBitBtn->Enabled = false;
   EnableReaderStaticText->Enabled = false;
   DisableReaderStaticText->Enabled = false;
   QueryReaderStaticText->Enabled = false;
   AssignReaderStaticText->Enabled = false;
   ReaderVersionStaticText->Enabled = false;
   ConfigTxTimeStaticText->Enabled = false;
   RelayStaticText->Enabled = false;
   //EnableRdrFGenStaticText->Enabled = false;
   ConfigFGenStaticText->Enabled = false;
   QueryFGenStaticText->Enabled = false;
   ConfigTagStaticText->Enabled = false;
   EnableTagStaticText->Enabled = false;
   DisableTagStaticText->Enabled = false;
   QueryTagStaticText->Enabled = false;
   CallTagStaticText->Enabled = false;
   AssignTagRdrStaticText->Enabled = false;
   ConfigTagRNDStaticText->Enabled = false;
   WriteMemoryStaticText->Enabled = false;
   ReadMemoryStaticText->Enabled = false;
   TagTempStaticText->Enabled = false;
   TagTempReadTempValueBitBtn->Enabled = false;
   TagTempRefreshBitBtn->Enabled = false;
   TagTempBitBtn->Enabled = false;
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::UpdateTagTempScreen()
{
   tempDisplayed = false;

   tagTempPeriodByte = 0x00;
   tagTempCtrlByte = 0x00;
   tagTempHiLimit = 0.0;
   tagTempLoLimit = 0.0;

   TagTempCurrUpLimitEdit->Text = "";
   TagTempCurrLowLimitEdit->Text = "";
   TagTempCurrUpCalibLimitEdit->Text = "";
   TagTempCurrLowCalibLimitEdit->Text = "";
   TagTempPeriodRepTimeEdit->Text = "";
   TagTempNumReadAveComboBox->Text = "";
   TagTempTempValueEdit->Text = "";
   TagTempRepLowLimitCheckBox->Checked = false;
   TagTempRepUpLimitCheckBox->Checked = false;
   TagTempRepPeriodCheckBox->Checked = false;
   TagTempPeriodRepTimeHourRadioButton->Checked = false;
   TagTempPeriodRepTimeMinRadioButton->Checked = false;
   TagTempLoggingCheckBox->Checked = false;
   TagTempWarpAroundCheckBox->Checked = false;

   if(networkOn)
   {
      /*int rdr = atoi(TagTempReaderIDComboBox->Text.c_str());
      int index = GetIpAddressIndex(rdr);
      if (index >= 0)
      {
          WriteTCPIPComm(READ_TAG_TEMP_CONFIG, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
      }
      else
      {
          Application->MessageBox("Did not find IP address.",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return;
      }*/

      int rdr = atoi(TagTempReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(READ_TAG_TEMP_CONFIG, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
      {
         StaticText->Caption = "No matching socket for the reader.";
         return;
      }
   }
   else if (RS232On)
   {
      WriteRS232Comm(READ_TAG_TEMP_CONFIG, 0, NULL, 0);
   }

   EnableReaderStaticText->Enabled = false;
   DisableReaderStaticText->Enabled = false;
   QueryReaderStaticText->Enabled = false;
   AssignReaderStaticText->Enabled = false;
   ReaderVersionStaticText->Enabled = false;
   ConfigTxTimeStaticText->Enabled = false;
   RelayStaticText->Enabled = false;
   InputsStaticText->Enabled = false;
   //EnableRdrFGenStaticText->Enabled = false;
   ConfigFGenStaticText->Enabled = false;
   QueryFGenStaticText->Enabled = false;
   ConfigTagStaticText->Enabled = false;
   EnableTagStaticText->Enabled = false;
   DisableTagStaticText->Enabled = false;
   QueryTagStaticText->Enabled = false;
   FGenResetStaticText->Enabled = false;
   SmartFGenStaticText->Enabled = false;
   CallTagStaticText->Enabled = false;
   AssignTagRdrStaticText->Enabled = false;
   ConfigTagRNDStaticText->Enabled = false;
   WriteMemoryStaticText->Enabled = false;
   ReadMemoryStaticText->Enabled = false;
   TagTempStaticText->Enabled = false;
   TagTempReadTempValueBitBtn->Enabled = false;
   TagTempRefreshBitBtn->Enabled = false;
   TagTempBitBtn->Enabled = false;

   StaticText->Caption = "Please wait. Requesting tag temperature status.";
}
//------------------------------------------------------------------------------
/*int __fastcall TProgStationForm::ScanNetwork(LTX_SOCKET sock, cbxentry ** cbxlist, unsigned long oem_id)
{
    unsigned char   reqt[18];
    unsigned char   buf[UDP_BUF_SIZE];
    int   i, len, n, nbytes, timeout;
    unsigned long   br = 0;
    LTX_INTERFACE_INFO   ifo[MAX_INTERFACES];
    struct sockaddr_in   peer;
    fd_set   rfds, efds;
    struct timeval   timev;
    cbxentry   *cbxlp1, *cbxlp2;

    memset(reqt, 0, sizeof(reqt));
    memset(buf, 0, sizeof(buf));

    reqt[3] = CBX_CONF_QUERY;

    // It's a good idea to bind this socket to a local port number
    peer.sin_family = AF_INET;
    peer.sin_addr.s_addr = INADDR_ANY;
    peer.sin_port = 0;
    if (bind(sock, (struct sockaddr *) &peer, sizeof(peer)))
    {
       //fprintf(stderr, "Error binding socket\n");
       Application->MessageBox("Programming Station", "Error binding socket", MB_OK);
       return(-1);
    }

    // Grab all the network interfaces
    memset(&ifo[0], 0, sizeof(ifo));
    if ((WSAIoctl(sock, SIO_GET_INTERFACE_LIST, NULL, 0, &ifo[0], sizeof(ifo), &br, NULL, NULL)) != 0)
    {
        //fprintf(stderr, "Get SIO_GET_INTERFACE_LIST error (%d)\n",
        Application->MessageBox("Programming Station", "Get SIO_GET_INTERFACE_LIST error", MB_OK);
        return(-3);
    }


    // Query each network
    for (i = 0; i < (int)(br / sizeof(LTX_INTERFACE_INFO)); i++)
    {
      if (interface_up(sock, &peer, &ifo[i]))
      {
         if ((n = sendto(sock, reqt, sizeof(reqt), 0,
             (struct sockaddr *) &peer, sizeof(struct sockaddr_in))) <= 0)
         {
             //fprintf(stderr, "sendto (%s) failed!\n",
             Application->MessageBox("Programming Station", "sendto failed", MB_OK);
         }
       }
    }

   // We've sent the queries, now see if anyone responded
   cbxlp1 = *cbxlist;
   n = 0;
   while(1)
   {
      FD_ZERO(&rfds);
      FD_ZERO(&efds);
      FD_SET(sock, &rfds);
      FD_SET(sock, &efds);
      timev.tv_sec = 3;	//three second timeout
      timev.tv_usec = 0;
      timeout = select(FD_SETSIZE, &rfds, (fd_set *) NULL, &efds, &timev);
      if (timeout == -1)
      {
         continue;
      }
      else if (timeout == 0)
      {
         break;
      }
      else if (FD_ISSET(sock, &efds))
      {
         //fprintf(stderr, "Bad news, exception on socket\n");
         Application->MessageBox("Programming Station", "Exception on socket", MB_OK);
         break;
      }
      else if (FD_ISSET(sock, &rfds))
      {
         memset(buf, 0, sizeof(buf));
         len = sizeof(struct sockaddr_in);
         if ((nbytes = recvfrom(sock, buf, sizeof(buf), 0,
             (struct sockaddr *) &peer, &len)) > 0)
         {
             if ( (oem_id == 0) || (!(memcmp(buf+4+OEM_ID_OFFSET, &oem_id, OEM_ID_SIZE))) )
             {
                if (cbxlp1 == (cbxentry *) NULL)
                {
                   if ((cbxlp1 = (cbxentry *) malloc(sizeof(cbxentry))) == (cbxentry *) NULL)
                      return(n);
                   memset(cbxlp1, 0, sizeof(cbxentry));
                   memcpy(&cbxlp1->peer, &peer, sizeof(struct sockaddr_in));
                   memcpy(&cbxlp1->record, buf+4, sizeof(cbxlp1->record));
                   if (n == 0)
                      *cbxlist = cbxlp2 = cbxlp1;
                   else
                   {
                      cbxlp2->next = cbxlp1;
                      cbxlp2 = cbxlp1;
                   }
                   cbxlp1 = cbxlp1->next;
                }
                n++;
             }
         }
      }
   }
   return(n);
}
*/
//------------------------------------------------------------------------------
/*long __fastcall TProgStationForm::interface_up(LTX_SOCKET sock, sockaddr_in *peerAddr, LTX_INTERFACE_INFO *ifo)
{
    peerAddr->sin_addr.s_addr =	ifo->iiAddress.AddressIn.sin_addr.s_addr;
    if ((ifo->iiAddress.AddressIn.sin_addr.S_un.S_addr != 0) &&
        ((ifo->iiFlags & IFF_LOOPBACK) == 0) &&
        ((ifo->iiFlags & (IFF_UP | IFF_BROADCAST)) == (IFF_UP | IFF_BROADCAST)) )
    {
       // The iiBroadcastAddress field is bogus, so do it manually
       peerAddr->sin_addr.s_addr = ifo->iiAddress.AddressIn.sin_addr.s_addr &  ifo->iiNetmask.AddressIn.sin_addr.s_addr;
       peerAddr->sin_addr.s_addr |= ~(ifo->iiNetmask.AddressIn.sin_addr.s_addr);
       peerAddr->sin_port = htons(COBOX_UDP_PORT);
       peerAddr->sin_family = AF_INET;
       return(1);
    }
    return(0);

}*/
//------------------------------------------------------------------------------
bool __fastcall TProgStationForm::GetAllReadersIPAddr()
{
   /*LTX_SOCKET sock;
   int i;
   unsigned long oem_id;
   cbxentry *cbxlp, *cbxlp1;
   WSADATA info;

   oem_id = htonl(strtoul("4", NULL, 0));

   // Clear the records
   for (i = 0; i < SETUP_RECORDS; i++)
      memset(&Setup[i], 0, SETUP_LENGTH);

   cbxlp = (cbxentry *) NULL;

   //  start up winsock
   if ((i = WSAStartup(MAKEWORD(1,1), &info)) < 0 )
   {
      //fprintf(stderr, "Error on WSAStartup(), error (%d)\n", i);
      Application->MessageBox("Programming Station", "Error on WSAStartup()", MB_OK);
      return (false);
   }

   //Create the SOCK_DGRAM socket
   if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
   {
      //fprintf(stderr, "Error opening socket (%d)\n", sock);
      Application->MessageBox("Programming Station", "Error opening socket", MB_OK);
      WSACleanup();
      return (false);
   }

   // Scan the network for devices
   if (ScanNetwork(sock, &cbxlp, oem_id) < 0)
   {
      closesocket(sock);
      WSACleanup();
      return (false);
   }

   cbxlp1 = cbxlp;
   AnsiString s;
   while ((cbxlp != (cbxentry *) NULL) && (cbxlp->peer.sin_addr.S_un.S_addr != 0) )
   {
      //printf("cobox at %s ", inet_ntoa(cbxlp->peer.sin_addr));
      comConfigDialog->Label20->Caption = s.sprintf("cobox at %s ", inet_ntoa(cbxlp->peer.sin_addr));
      for (i = 0; i < sizeof(cbxlp->record); i++)
      {
         ;
         //if ((i % 16) == 0) printf("\n");
         //printf("0x%02x ", cbxlp->record[i]);
      }
      //printf("\n");
      cbxlp = cbxlp->next;
   }

   // Free the records
   cbxlp = cbxlp1;
   while (cbxlp != (cbxentry *) NULL)
   {
      cbxlp = cbxlp->next;
      free(cbxlp1);
      cbxlp1 = cbxlp;
   }

   // Close up shop
   closesocket(sock);
   WSACleanup();

   return (true);
   */

   return (true);
}
//------------------------------------------------------------------------------
int __fastcall TProgStationForm::TCPDecrypt(char* eText, int len, char* plaintext, int method, int sIndex)
{
  int i;

  /*for (i = 0; i < len; i++)
  {
     if (pstatd == 0)
     {
        blockEncrypt(networkInfo[sIndex].initVectorDecrypt, shared_key, 0, networkInfo[sIndex].initVectorDecrypt, (method - 1));
        pstatd = 16;
     }

     plaintext[i] = networkInfo[sIndex].initVectorDecrypt[16 - pstatd] ^ eText[i];
     networkInfo[sIndex].initVectorDecrypt[16 - pstatd] = eText[i];
     pstatd--;
  }*/

 /* for (i = 0; i < len; i++)
  {
     if (pstatd == 0)
     {
        blockEncrypt(ivd, shared_key, 0, ivd, (method - 1));
        pstatd = 16;
     }

     plaintext[i] = ivd[16 - pstatd] ^ eText[i];
     ivd[16 - pstatd] = eText[i];
     pstatd--;
  } */

  return(len);
}
//------------------------------------------------------------------------------
int __fastcall TProgStationForm::TCPEncrypt(char *plaintext, int len, char *eText, int method, int sIndex)
{
   /*int i;

   for (i = 0; i < len; i++)
   {
      if (pstate == 0)
      {
         blockEncrypt(networkInfo[sIndex].initVectorEncrypt, shared_key, 0, networkInfo[sIndex].initVectorEncrypt, (method - 1));
         pstate = 16;
      }
      networkInfo[sIndex].initVectorEncrypt[16 - pstate] ^= plaintext[i];
      eText[i] = networkInfo[sIndex].initVectorEncrypt[16 - pstate];
      pstate--;
   }*/

   /*for (i = 0; i < len; i++)
   {
      if (pstate == 0)
      {
         blockEncrypt(ive, shared_key, 0, ive, (method - 1));
         pstate = 16;
      }
      ive[16 - pstate] ^= plaintext[i];
      eText[i] = ive[16 - pstate];
      pstate--;
   }*/

   return(len);
}
//------------------------------------------------------------------------------
int read_socket(SOCKET sock, char *rbuf, int len, struct sockaddr_in *from)
{
   int in, fromlen;

   fromlen = sizeof(struct sockaddr_in);
   if ((in = recvfrom(sock, rbuf, len, 0, (struct sockaddr *) from, &fromlen)) < 0)
	Application->MessageBox("recvfrom failed - encrypt", "Error", MB_OK);

   return(in);
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::EnableRelayCheckBoxMouseDown(
      TObject *Sender, TMouseButton Button, TShiftState Shift, int X,
      int Y)
{
   mouseClicked = true;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::DisableRelayCheckBoxMouseDown(
      TObject *Sender, TMouseButton Button, TShiftState Shift, int X,
      int Y)
{
   mouseClicked = true;
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::RelayListViewCustomDrawItem(
      TCustomListView *Sender, TListItem *Item, TCustomDrawState State,
      bool &DefaultDraw)
{
   /*TStrings* str = Item->SubItems;
   AnsiString selectedItem1 = GetItem(str, 2);
   AnsiString selectedItem2 = GetItem(str, 3);

   if ((selectedItem1 == "Enabled") || (selectedItem2 == "Enabled"))
      RelayListView->Canvas->Font->Color = clGreen;
   else if ((selectedItem1 == "Disabled") || (selectedItem2 == "Disabled"))
     RelayListView->Canvas->Font->Color = clRed;
   else
     RelayListView->Canvas->Font->Color = clBlack; */
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::RelayListViewCustomDrawSubItem(
      TCustomListView *Sender, TListItem *Item, int SubItem,
      TCustomDrawState State, bool &DefaultDraw)
{
   TStrings* str = Item->SubItems;
   AnsiString selectedItem1 = GetItem(str, 1);
   AnsiString selectedItem2 = GetItem(str, 2);

   if ((selectedItem1 == "Enabled") || (selectedItem2 == "Enabled"))
      RelayListView->Canvas->Font->Color = clGreen;
   else if ((selectedItem1 == "Disabled") || (selectedItem2 == "Disabled"))
     RelayListView->Canvas->Font->Color = clRed;
   else
     RelayListView->Canvas->Font->Color = clBlack;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::RelayClearBitBtnClick(TObject *Sender)
{
   RelayListView->Clear();
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::InputsBitBtnClick(TObject *Sender)
{
   InputsBitBtn->Font->Color = clRed;

   TxClearTagCtrls();
   RxClearTagCtrls();
   ProgammingMode = true;
   programming = false;
   StaticText->Caption = "";

   receivedResponse = false;
   /*if (readerFgenButtonActivated)
   {
      ReaderFgenToolButton->Hint = "Set Programming Station To Field Generator Mode";
      readerFgenButtonActivated = false;
      if(networkOn)
         CloseNetworkConnection();
      else if (RS232On)
         ClosePort();
      EnableAllCommands(false);
      if (OpenSerial(comPort, lastBaudrate))
      {
         ProgStationForm->PortOpen = true;
         baudRate = curBaudrate = lastBaudrate;
         PlaySound("Ding.wav", NULL, SND_ASYNC );
      }
      EnableAllCommands(true);
      readerOffLine = true;
      readerOnLine = false;
      fieldGenOffLine = true;
      fieldGenOnLine = false;
   }*/

   if(networkOn)
   {
      /*int rdr = atoi(InputReaderIDComboBox->Text.c_str());
      int index = GetIpAddressIndex(rdr);
      if (index >= 0)
      {
         WriteTCPIPComm(INPUT_STATUS, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
      }*/

      int rdr = atoi(InputReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(INPUT_STATUS, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(INPUT_STATUS, 0, NULL, 0);
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::InputClearBitBtnClick(TObject *Sender)
{
   InputListView->Clear();
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::InputListViewColumnClick(TObject *Sender,
      TListColumn *Column)
{
   columnToSort = Column->Index;
  ((TCustomListView *)Sender)->AlphaSort();
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::InputListViewCompare(TObject *Sender,
      TListItem *Item1, TListItem *Item2, int Data, int &Compare)
{
    int index;
    AnsiString selectedItem1;
    AnsiString selectedItem2;
    TStrings* str;
    int n1, n2;

    if (columnToSort == 1)
    {
       str = Item1->SubItems;
       selectedItem1 = GetItem(str, 0);

       str = Item2->SubItems;
       selectedItem2 = GetItem(str, 0);

       n1 = atoi(selectedItem1.c_str());
       n2 = atoi(selectedItem2.c_str());
       if (n1 == n2)
          Compare = 0;
       else if (n1 > n2)
          Compare = 1;
       else
          Compare = -1;
    }

}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::UpdateNewHostIDFields(int id)
{
  if (ResetReaderGroupBox->Visible) //1
       ResetHostIDEdit->Text = id;
   else if (EnableReaderGroupBox->Visible) //2
       EnableReaderHostIDEdit->Text = id;
   else if (DisableReaderGroupBox->Visible) //3
       DisableReaderHostIDEdit->Text = id;
   else if (QueryReaderGroupBox->Visible) //4
       QueryReaderHostIDEdit->Text = id;
   else if (AssignReaderGroupBox->Visible)  //5
       AssignReaderHostIDEdit->Text = id;
   else if (ReaderCodeVerGroupBox->Visible)  //6
       RdrCodeVerHostEdit->Text = id;
   else if (DownloadRdrGroupBox->Visible)
       DownloadRdrHostEdit->Text = id;
   else if (RelayGroupBox->Visible)   //7
       RelayHostIDEdit->Text = id;
   else if (ConfigFGenGroupBox->Visible)  //8
       FGenConfigHostIDEdit->Text = id;
   else if (QueryFGenGroupBox->Visible)  //9
       QueryFGenHostIDEdit->Text = id;
   else if (QuerySFGenGroupBox->Visible)  //9
       QuerySFGenHostIDEdit->Text = id;
   else if (AssignTagReaderGroupBox->Visible)  //10
       AssignTagRdrHostIDEdit->Text = id;
   else if (ConfigTagRandGroupBox->Visible) //11
       ConfigTagRNDHostIDEdit->Text = id;
   else if (ConfigTagGroupBox->Visible)  //12
       ConfigTagHostIDEdit->Text = id;
   else if (EnableTagGroupBox->Visible)  //13
       EnableTagHostIDEdit->Text = id;
   else if (DisableTagGroupBox->Visible)   //14
       DisableTagHostIDEdit->Text = id;
   else if (QueryTagGroupBox->Visible)  //15
       QueryTagHostIDEdit->Text = id;
   else if (CallTagGroupBox->Visible)   //16
       CallTagHostIDEdit->Text = id;
   else if (ConfigFGenGroupBox->Visible)
       FGenConfigHostIDEdit->Text = id;
   else if (FGenResetGroupBox->Visible)
       FGenResetHostIDEdit->Text = id;
   else if (SmartFGenGroupBox->Visible)
       SmartFGenHostIDEdit->Text = id;
   else if (WriteMemoryStaticText->Visible)
       WriteMemoryHostIDEdit->Text = id;
   //else if (EnableRdrFGenGroupBox->Visible)
       //EnableRdrFGenHostIDEdit->Text = id;
   else if (InputGroupBox->Visible)
       InputHostIDEdit->Text = id;
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::ReadMemoryBitBtnClick(TObject *Sender)
{
   if (!NewListItemCheckBox->Checked)
   {
      TxClearTagCtrls();
      RxClearTagCtrls();
      ProgammingMode = true;
      StaticText->Caption = "";
      DetectedMsg->Caption = "";
      TamperSWMsg->Caption = "";
      TagDetectedGroupBox->Caption = "Detected Tags";
      tagDetectCount = 0;
      type1Count = 0;
      type2Count = 0;
      type3Count = 0;
      type4Count = 0;
      type5Count = 0;
      type6Count = 0;
      typeFacCount = 0;
      ReportType1Label->Caption = "";
      ReportType2Label->Caption = "";
      ReportType3Label->Caption = "";
      ReportType4Label->Caption = "";
      ReportType5Label->Caption = "";
      ReportType6Label->Caption = "";
      ReportFACTLabel->Caption = "";
      ReportTotalLabel->Caption = "";
      ReportNDupLabel->Caption = "";
      DetectedTagListView->Items->Clear();
      for (int i=0; i<MAX_TAG_DETECTED; i++)
      {
          tagDetectedArray[i].tagID = 0;
          tagDetectedArray[i].tagType = 6;
          tagDetectedArray[i].cmd = 0;
          tagDetectedArray[i].fGenID = 0xFF;
          tagDetectedArray[i].gID = false;
          tagDetectedArray[i].lastDetectTime = Now();
      }
   }
   //StaticText->Caption = "";
   programming = true;
   progStr = "Please wait. ";

   tagTypeStr = ReadMemoryTagTypeComboBox->Text;
   progStr += "Reading ";
   progStr += ReadMemoryTagTypeComboBox->Text;
   progStr += " Tag";

   if ((ReadMemoryTagIDRangeRadioButton->Checked) && (ReadMemoryTagIDEdit->Text.data() == NULL))
   {
       Application->MessageBox("Error: Need Tag ID",
                               "Programming Station Information Dialog",
                               MB_OK | MB_ICONSTOP | MB_TOPMOST);
       ReadMemoryBitBtn->Enabled = true;
       return;
   }

   if ((ReadMemoryTagTypeComboBox->Text == "All Types") && (ReadMemoryAnyTagIDRadioButton->Checked))
    {
        int ret = Application->MessageBox ("Do you want to Read From ALL tags Memory?",
                                           "Programming Station Information Dialog",
                                           MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "All Tags";
        progStr = "Please wait. Reading From All Tags Memory";
    }
    else if (ReadMemoryTagTypeComboBox->Text == "All Types")
    {
       int ret = Application->MessageBox ("Do you want to Read From Any Tag Type Memory?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "All Types";
        progStr = "Please wait. Reading From All Tag Types Memory";
    }
    else if (ReadMemoryAnyTagIDRadioButton->Checked)
    {
       int ret = Application->MessageBox ("Do you want to Read From Any Tag ID Memory?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        progStr = "Please wait. Reading From Any Tag ID Memory";
    }
    else
       progStr = "Please Wait, reading tag data. ";

   StaticText->Caption = progStr;

   if (ReadTagLargeDataCheckBox->Checked)
   {
      ReadLargDataTimer->Enabled = true;
      numReadLargeData = 0;
      readLargeDataCounter = 0;
      displayElapsedTime = true;
      lastRPktID = 0;
      rPktID = 0;
      readBufIndex = 0;
      elapsedTime = 0;
      noResponseCounter = 0;
      startAddress = HexToInt(ReadMemoryNumByteEdit->Text.c_str(), ReadMemoryNumByteEdit->Text.Length());
      MaxReadLargeData = atoi(ReadMemoryNumByteEdit->Text.c_str());
   }
   else if (atoi(ReadMemoryNumByteEdit->Text.c_str()) > 12)
   {
      ::MessageBoxEx(::GetDesktopWindow(), ( LPCSTR )"Error: Max num bytes to read is 12.",
      ( LPCSTR )"Programming Station Information Dialog",
      MB_OK | MB_ICONSTOP | MB_TOPMOST  , LANG_ENGLISH );
      return;
   }

   ReadMemoryBitBtn->Font->Color = clRed;
   programming = true;

   /* if ((ReadMemoryAnyTagTypeRadioButton->Checked) && (ReadMemoryAnyTagIDRadioButton->Checked))
    {
        int ret = Application->MessageBox ("Do you want to Read From ALL tags Memory?",
                                           "Programming Station Information Dialog",
                                           MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "All Tags";
        progStr = "Please wait. Reading From All Tags Memory";
    }
    else if (ReadMemoryAnyTagTypeRadioButton->Checked)
    {
       int ret = Application->MessageBox ("Do you want to Read From Any Tag Type Memory?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "Any Type";
        progStr = "Please wait. Reading From Any Tag Type Memory";
    }
    else if (ReadMemoryAnyTagIDRadioButton->Checked)
    {
       int ret = Application->MessageBox ("Do you want to Read From Any Tag ID Memory?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        progStr = "Please wait. Reading From Any Tag ID Memory";
    }
    else
       progStr = "Please Wait, reading tag data. ";

   StaticText->Caption = progStr;
   */

   for (int i = 1; i < ReadMemoryStringGrid->ColCount; i++)
      for (int j = 1; j < ReadMemoryStringGrid->RowCount; j++)
         ReadMemoryStringGrid->Cells[i][j] = "";

   DisableTagStaticCommands();
   CMDEnableTimer->Enabled = true;
   ReadMemoryBitBtn->Enabled = false;

   if(networkOn)
   {
      /*int rdr = atoi(ReadMemoryReaderIDComboBox->Text.c_str());
      int index = GetIpAddressIndex(rdr);
      if (index >= 0)
      {
            WriteTCPIPComm(READ_TAG_MEMORY, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
      }*/

      int rdr = atoi(ReadMemoryReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(READ_TAG_MEMORY, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(READ_TAG_MEMORY, 0, NULL, 0);
   }

   if (DisplayDataCheckBox->Checked)
      {
         largeDataDlg = new TTagReadLargDataForm (this);
         largeDataDlg->ShowModal();
         delete largeDataDlg;
         largeDataDlg = NULL;
      }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::TagTempBitBtnClick(TObject *Sender)
{
   bool b;

   if (!NewListItemCheckBox->Checked)
   {
      TxClearTagCtrls();
      RxClearTagCtrls();
      ProgammingMode = true;
      StaticText->Caption = "";
      DetectedMsg->Caption = "";
      TamperSWMsg->Caption = "";
      TagDetectedGroupBox->Caption = "Detected Tags";
      tagDetectCount = 0;
      type1Count = 0;
      type2Count = 0;
      type3Count = 0;
      type4Count = 0;
      type5Count = 0;
      type6Count = 0;
      typeFacCount = 0;
      ReportType1Label->Caption = "";
      ReportType2Label->Caption = "";
      ReportType3Label->Caption = "";
      ReportType4Label->Caption = "";
      ReportType5Label->Caption = "";
      ReportType6Label->Caption = "";
      ReportFACTLabel->Caption = "";
      ReportTotalLabel->Caption = "";
      ReportNDupLabel->Caption = "";
      DetectedTagListView->Items->Clear();
      for (int i=0; i<MAX_TAG_DETECTED; i++)
      {
          tagDetectedArray[i].tagID = 0;
          tagDetectedArray[i].tagType = 6;
          tagDetectedArray[i].cmd = 0;
          tagDetectedArray[i].fGenID = 0xFF;
          tagDetectedArray[i].gID = false;
          tagDetectedArray[i].lastDetectTime = Now();
      }
   }
   //StaticText->Caption = "";
   programming = true;
   progStr = "Please wait. ";

   tagTypeStr = WriteMemoryTagTypeComboBox->Text;
   progStr += "configuring temp. for ";
   progStr += WriteMemoryTagTypeComboBox->Text;
   progStr += " Tag";


   if ((ConfigTagIDRangeRadioButton->Checked) && (ConfigTagTagIDEdit->Text.data() == NULL))
   {
       Application->MessageBox("Error: Need Tag ID",
                               "Programming Station Information Dialog",
                               MB_OK | MB_ICONSTOP | MB_TOPMOST);
       ConfigTagBitBtn->Enabled = true;
       return;
   }

   if ((TagTempTagTypeComboBox->Text == "All Types") && (TagTempAnyTagIDRadioButton->Checked))
    {
        int ret = Application->MessageBox ("Do you want to Configure ALL tags?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "All Tags";
        progStr = "Please wait. Configuring All Tags";
    }
    else if (TagTempTagTypeComboBox->Text == "All Types")
    {
       int ret = Application->MessageBox ("Do you want to Configure All Tag Types?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "All Types";
        progStr = "Please wait. Configuring All Tag Types";
    }
    else if (TagTempAnyTagIDRadioButton->Checked)
    {
       int ret = Application->MessageBox ("Do you want to Configure Any Tag ID?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        progStr = "Please wait. Configuring Any Tag ID";
    }
    else
       progStr = "Please wait, configuring tag temperature. ";

   StaticText->Caption = progStr;

   TagTempBitBtn->Font->Color = clRed;
   programming = true;

   DisableTagStaticCommands();
   CMDEnableTimer->Enabled = true;
   TagTempBitBtn->Enabled = false;

   if(networkOn)
   {
      /*int rdr = atoi(TagTempReaderIDComboBox->Text.c_str());
      int index = GetIpAddressIndex(rdr);

      if (index < 0)
      {
         Application->MessageBox("Did not find IP address.",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return;
      }*/

      int rdr = atoi(TagTempReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index < 0)
      {
         StaticText->Caption = "No matching socket for the reader.";
         return;
      }

      if (TagTempChangeUpLimitCheckBox->Checked ||
          TagTempChangeLowLimitCheckBox->Checked ||
          TagTempChangeReportCheckBox->Checked)
      {
         int ret = Application->MessageBox ("Do you want to Modify Tag Temperature setting?",
                                            "Programming Station Information Dialog",
                                            MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
         if (ret == IDNO)
            return;

         if (index >= 0)
         {
            //WriteTCPIPComm(WRITE_TAG_TEMP_CONFIG, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
            if (!WriteAWSocket(WRITE_TAG_TEMP_CONFIG, 0, NULL, index, 'S', NULL, 0, index))
               return;
            StaticText->Caption = "Please wait. Configuring tag temperature status.";
         }
      }
      else
      {
          //WriteTCPIPComm(READ_TAG_TEMP_CONFIG, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
          if (!WriteAWSocket(READ_TAG_TEMP_CONFIG, 0, NULL, index, 'S', NULL, 0, index))
             return;
          StaticText->Caption = "Please wait. Requesting tag temperature status.";
      }
   }
   else if (RS232On)
   {
      if (TagTempChangeUpLimitCheckBox->Checked ||
          TagTempChangeLowLimitCheckBox->Checked ||
          TagTempChangeReportCheckBox->Checked)
      {
         int ret = Application->MessageBox ("Do you want to Modify Tag Temperature setting?",
                                            "Programming Station Information Dialog",
                                            MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
         if (ret == IDNO)
            return;



         if(!WriteRS232Comm(WRITE_TAG_TEMP_CONFIG, 0, NULL, 0))
            return;
         StaticText->Caption = "Please wait. Configuring tag temperature status.";
      }
      else
      {
         if (!WriteRS232Comm(READ_TAG_TEMP_CONFIG, 0, NULL, 0))
            return;
         StaticText->Caption = "Please wait. Requesting tag temperature status.";
      }
   }

   //EnableTagBitBtn->Enabled = false;
   EnableReaderStaticText->Enabled = false;
   DisableReaderStaticText->Enabled = false;
   QueryReaderStaticText->Enabled = false;
   AssignReaderStaticText->Enabled = false;
   ReaderVersionStaticText->Enabled = false;
   ConfigTxTimeStaticText->Enabled = false;
   RelayStaticText->Enabled = false;
   //EnableRdrFGenStaticText->Enabled = false;
   ConfigFGenStaticText->Enabled = false;
   QueryFGenStaticText->Enabled = false;
   ConfigTagStaticText->Enabled = false;
   EnableTagStaticText->Enabled = false;
   DisableTagStaticText->Enabled = false;
   QueryTagStaticText->Enabled = false;
   CallTagStaticText->Enabled = false;
   AssignTagRdrStaticText->Enabled = false;
   ConfigTagRNDStaticText->Enabled = false;
   WriteMemoryStaticText->Enabled = false;
   ReadMemoryStaticText->Enabled = false;
   TagTempStaticText->Enabled = false;
   TagTempReadTempValueBitBtn->Enabled = false;
   TagTempRefreshBitBtn->Enabled = false;
   TagTempBitBtn->Enabled = false;
   first = true;
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::SmartFGenBitBtnClick(TObject *Sender)
{
   SmartFGenBitBtn->Font->Color = clRed;

   if ((SmartFGenTagTypeComboBox->Text == "All Types") && (SmartFGenAnyTagIDRadioButton->Checked))
    {
        int ret = Application->MessageBox ("Do you want to Call ALL tags?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "All Tags";
        progStr = "Please wait. Calling All Tags";
    }
    else if (SmartFGenTagTypeComboBox->Text == "All Types")
    {
       int ret = Application->MessageBox ("Do you want to Call All Tag Types?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "All Types";
        progStr = "Please wait. Calling All Tag Types";
    }
    else if (SmartFGenAnyTagIDRadioButton->Checked)
    {
       int ret = Application->MessageBox ("Do you want to Call Any Tag ID?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        progStr = "Please wait. Calling Any Tag ID";
    }
    else
       progStr = "Please wait. Calling the Tag";

    StaticText->Caption = progStr;

   if (NewListItemCheckBox->Checked == false)
   {
      tagDetectCount = 0;
      type1Count = 0;
      type2Count = 0;
      type3Count = 0;
      type4Count = 0;
      type5Count = 0;
      type6Count = 0;
      typeFacCount = 0;
      ReportType1Label->Caption = "";
      ReportType2Label->Caption = "";
      ReportType3Label->Caption = "";
      ReportType4Label->Caption = "";
      ReportType5Label->Caption = "";
      ReportType6Label->Caption = "";
      ReportFACTLabel->Caption = "";
      ReportTotalLabel->Caption = "";
      ReportNDupLabel->Caption = "";
      DetectedTagListView->Items->Clear();
      for (int i=0; i<MAX_TAG_DETECTED; i++)
      {
          tagDetectedArray[i].tagID = 0;
          tagDetectedArray[i].tagType = 6;
          tagDetectedArray[i].cmd = 0;
          tagDetectedArray[i].fGenID = 0xFF;
          tagDetectedArray[i].gID = false;
          tagDetectedArray[i].lastDetectTime = Now();
      }
   }

   TxClearTagCtrls();
   RxClearTagCtrls();
   ProgammingMode = true;
   programming = false;

   receivedResponse = false;
   /*if (readerFgenButtonActivated)
   {
      ReaderFgenToolButton->Hint = "Set Programming Station To Field Generator Mode";
      readerFgenButtonActivated = false;
      if(networkOn)
         CloseNetworkConnection();
      else if (RS232On)
         ClosePort();
      EnableAllCommands(false);
      if (OpenSerial(comPort, lastBaudrate))
      {
         ProgStationForm->PortOpen = true;
         baudRate = curBaudrate = lastBaudrate;
         PlaySound("Ding.wav", NULL, SND_ASYNC );
      }
      EnableAllCommands(true);
      readerOffLine = true;
      readerOnLine = false;
      fieldGenOffLine = true;
      fieldGenOnLine = false;
   }*/

   /*QueryTagBitBtn->Enabled = false;
   EnableReaderStaticText->Enabled = false;
   DisableReaderStaticText->Enabled = false;
   QueryReaderStaticText->Enabled = false;
   AssignReaderStaticText->Enabled = false;
   ReaderVersionStaticText->Enabled = false;
   ConfigTxTimeStaticText->Enabled = false;
   RelayStaticText->Enabled = false;
   EnableRdrFGenStaticText->Enabled = false;
   ConfigFGenStaticText->Enabled = false;
   QueryFGenStaticText->Enabled = false;
   FGenResetStaticText->Enabled = false;
   SmartFGenStaticText->Enabled = false;
   QuerySFGenStaticText->Enabled = false;
   ConfigSFGenStaticText->Enabled = false;
   ConfigTagStaticText->Enabled = false;
   EnableTagStaticText->Enabled = false;
   DisableTagStaticText->Enabled = false;
   QueryTagStaticText->Enabled = false;
   CallTagStaticText->Enabled = false;
   AssignTagRdrStaticText->Enabled = false;
   ConfigTagRNDStaticText->Enabled = false;
   WriteMemoryStaticText->Enabled = false;
   ReadMemoryStaticText->Enabled = false;
   TagTempStaticText->Enabled = false;
   InputsStaticText->Enabled = false;*/

   CMDEnableTimer->Enabled = true;
   DisableSmartFGenStaticCommands();
   SmartFGenBitBtn->Enabled = false;

   if(networkOn)
   {
      /*int rdr = atoi(SmartFGenReaderIDComboBox->Text.c_str());
      int index = GetIpAddressIndex(rdr);
      if (index >= 0)
      {
         WriteTCPIPComm(CALL_TAG_SMART_FGEN, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
      }
      else
      {
         Application->MessageBox("Did not find IP address.",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return;
      }*/

      int rdr = atoi(SmartFGenReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(CALL_TAG_SMART_FGEN, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(CALL_TAG_SMART_FGEN, 0, NULL, 0);
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::SmartFGenNewDPotEditChange(
      TObject *Sender)
{
   int a =  atoi(SmartFGenNewDPotEdit->Text.c_str());
   if ((a > 20) || (a < 0))
   {
       Application->MessageBox("ERROR: DPot value outside the range .",
                               "Programming Station Information Dialog", MB_OK );
       SmartFGenNewDPotEdit->Text = "";
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::SmartFGenBroadcastAllCheckBoxClick(
      TObject *Sender)
{
   if (SmartFGenBroadcastAllCheckBox->Checked)
   {
      SmartFGenIDComboBox->Enabled = false;
      SmartFGenIDComboBox->Color = clMenu;
   }
   else
   {
      SmartFGenIDComboBox->Enabled = true;
      SmartFGenIDComboBox->Color = clWhite;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::SmartFGenTagIDRadioButtonClick(
      TObject *Sender)
{
   SmartFGenTagIDEdit->Color = clWhite;
   SmartFGenTagIDEdit->ReadOnly = false;
   SmartFGenTagIDEdit->Font->Color = clBlue;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::SmartFGenAnyTagIDRadioButtonClick(
      TObject *Sender)
{
   SmartFGenTagIDEdit->Color = clMenu;
   SmartFGenTagIDEdit->ReadOnly = true;
   SmartFGenTagIDEdit->Font->Color = clGray;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagModifyRNCheckBoxClick(
      TObject *Sender)
{
   if (ConfigTagModifyRNCheckBox->Checked)
   {
      ConfigTagRNLongRadioButton->Enabled = true;
      ConfigTagRNShortRadioButton->Enabled = true;
   }
   else
   {
      ConfigTagRNLongRadioButton->Enabled = false;
      ConfigTagRNShortRadioButton->Enabled = false;
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ConfigTagGetConfigBitBtnClick(
      TObject *Sender)
{
    ConfigTagBitBtn->Font->Color = clRed;

    TxClearTagCtrls();
    RxClearTagCtrls();
    TagDetectedGroupBox->Caption = "Detected Tags";
    ProgammingMode = true;

    if (NewListItemCheckBox->Checked == false)
    {
       //Clear List and all its params ------------
       DetectedTagListView->Items->Clear();

       for (int i=0; i<MAX_TAG_DETECTED; i++)
       {
          tagDetectedArray[i].tagID = 0;
          tagDetectedArray[i].tagType = 6;
          tagDetectedArray[i].cmd = 0;
          tagDetectedArray[i].fGenID = 0xFF;
          tagDetectedArray[i].gID = false;
          tagDetectedArray[i].lastDetectTime = Now();
       }

       tagDetectCount = 0;
       type1Count = 0;
       type2Count = 0;
       type3Count = 0;
       type4Count = 0;
       type5Count = 0;
       type6Count = 0;
       typeFacCount = 0;
       ReportType1Label->Caption = "";
       ReportType2Label->Caption = "";
       ReportType3Label->Caption = "";
       ReportType4Label->Caption = "";
       ReportType5Label->Caption = "";
       ReportType6Label->Caption = "";
       ReportFACTLabel->Caption = "";
       ReportTotalLabel->Caption = "";
       ReportNDupLabel->Caption = "";

    }

    programming = true;
    /*progStr = "Please wait. ";
    if (AccessCtrlRadioButton->Checked)
    {
         tagTypeStr = "Access";
         progStr += "Configuring Access Tag ";
    }
    else if (AssetCtrlRadioButton->Checked)
    {
        tagTypeStr = "Asset";
         progStr += "Configuring Asset Tag ";
    }
    else if (InvetRadioButton->Checked)
    {
         tagTypeStr = "Inventory ";
         progStr += "Configuring Inventory Tag ";
    }
    else if (CarRadioButton->Checked)
    {
         tagTypeStr = "Car";
         progStr += "Configuring Car Tag ";
    }
    else if (AnyTagRadioButton->Checked)
    {
         tagTypeStr = "Any Type";
         progStr += "Configuring All Tag Types ";
    }
    else
    {
         progStr += "Configuring Tag ";
    }*/

    //StaticText->Caption = progStr;
    receivedResponse = false;
    if (readerFgenButtonActivated)
   {
      ReaderFgenToolButton->Hint = "Set Programming Station To Field Generator Mode";
      readerFgenButtonActivated = false;
      if(networkOn)
         CloseNetworkConnection();
      else if (RS232On)
         ClosePort();
      EnableAllCommands(false);
      if (OpenSerial(comPort, lastBaudrate))
      {
         ProgStationForm->PortOpen = true;
         baudRate = curBaudrate = lastBaudrate;
         PlaySound("Ding.wav", NULL, SND_ASYNC );
      }
      EnableAllCommands(true);

      readerOffLine = true;
      readerOnLine = false;
      fieldGenOffLine = true;
      fieldGenOnLine = false;
   }

   QueryTagBitBtn->Enabled = false;
   EnableReaderStaticText->Enabled = false;
   DisableReaderStaticText->Enabled = false;
   QueryReaderStaticText->Enabled = false;
   AssignReaderStaticText->Enabled = false;
   ReaderVersionStaticText->Enabled = false;
   ConfigTxTimeStaticText->Enabled = false;
   RelayStaticText->Enabled = false;
   //EnableRdrFGenStaticText->Enabled = false;
   ConfigFGenStaticText->Enabled = false;
   QueryFGenStaticText->Enabled = false;
   SmartFGenBitBtn->Enabled = false;
   FGenResetBitBtn->Enabled = false;
   FGenResetStaticText->Enabled = false;
   SmartFGenStaticText->Enabled = false;
   ConfigTagStaticText->Enabled = false;
   EnableTagStaticText->Enabled = false;
   DisableTagStaticText->Enabled = false;
   QueryTagStaticText->Enabled = false;
   CallTagStaticText->Enabled = false;
   AssignTagRdrStaticText->Enabled = false;
   ConfigTagRNDStaticText->Enabled = false;
   WriteMemoryStaticText->Enabled = false;
   ReadMemoryStaticText->Enabled = false;
   TagTempStaticText->Enabled = false;
   InputsStaticText->Enabled = false;

   ConfigTagDurationComboBox->Text = "";
   ConfigTagTIFComboBox->Text = "";
   ConfigTagGCComboBox->Text = "";

   StaticText->Caption = "Please wait, trying to get the tag configuration";

   if(networkOn)
   {
      /*int rdr = atoi(ConfigTagReaderIDComboBox->Text.c_str());
      int index = GetIpAddressIndex(rdr);
      if (index >= 0)
         WriteTCPIPComm(READ_CONFIG_TAG_MEMORY, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
      */

      int rdr = atoi(ConfigTagReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(READ_CONFIG_TAG_MEMORY, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(READ_CONFIG_TAG_MEMORY, 0, NULL, 0);
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagModifyTamperCheckBoxClick(
      TObject *Sender)
{
   if (ConfigTagModifyTamperCheckBox->State == cbChecked)
   {
      ConfigTagNoReportRadioButton->Enabled = true;
      ConfigTagReportStatusRadioButton->Enabled = true;
      ConfigTagReportHistoryRadioButton->Enabled = true;

      //ConfigTagNoReportRadioButton->Checked = true;
   }
   else
   {
      ConfigTagNoReportRadioButton->Enabled = false;
      ConfigTagReportStatusRadioButton->Enabled = false;
      ConfigTagReportHistoryRadioButton->Enabled = false;

      //ConfigTagNoReportRadioButton->Checked = false;
      //ConfigTagReportStatusRadioButton->Checked = false;
      //ConfigTagReportHistoryRadioButton->Checked = false;
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::FGenResetClearBitBtnClick(
      TObject *Sender)
{
   numSFgenIDList = 0;
   FGenResetListView->Items->Clear();
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::QueryFGenSmartFGenBroadcastCheckBoxClick(
      TObject *Sender)
{
   if (QueryFGenSmartFGenBroadcastCheckBox->Checked)
   {
     QueryFGenSmartFGenIDComboBox->Enabled = false;
     QueryFGenSmartFGenIDComboBox->Color = clMenu;
     QuerySFGenSpecificRdrRadioButton->Enabled = true;
     QuerySFGenAnyRdrRadioButton->Enabled = true;
   }
   else
   {
     QueryFGenSmartFGenIDComboBox->Enabled = true;
     QueryFGenSmartFGenIDComboBox->Color = clWhite;
     QuerySFGenSpecificRdrRadioButton->Enabled = false;
     QuerySFGenAnyRdrRadioButton->Enabled = false;
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::EnableAllStaticTextCommands()
{
   ResetReaderStaticText->Enabled = true;
   EnableReaderStaticText->Enabled = true;
   DisableReaderStaticText->Enabled = true;
   QueryReaderStaticText->Enabled = true;
   AssignReaderStaticText->Enabled = true;
   ReaderVersionStaticText->Enabled = true;
   ConfigFGenStaticText->Enabled = true;
   QueryFGenStaticText->Enabled = true;
   FGenResetStaticText->Enabled = true;
   QuerySFGenStaticText->Enabled = true;
   ConfigSFGenStaticText->Enabled = true;
   SmartFGenStaticText->Enabled = true;
   ConfigTagStaticText->Enabled = true;
   EnableTagStaticText->Enabled = true;
   DisableTagStaticText->Enabled = true;
   QueryTagStaticText->Enabled = true;
   CallTagStaticText->Enabled = true;
   AssignTagRdrStaticText->Enabled = true;
   ConfigTagRNDStaticText->Enabled = true;
   WriteMemoryStaticText->Enabled = true;
   ReadMemoryStaticText->Enabled = true;
   //EnableRdrFGenStaticText->Enabled = true;
   RelayStaticText->Enabled = true;
   InputsStaticText->Enabled = true;
   TagTempStaticText->Enabled = true;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::DisableAllStaticTextCommands()
{
   ResetReaderStaticText->Enabled = false;
   EnableReaderStaticText->Enabled = false;
   DisableReaderStaticText->Enabled = false;
   QueryReaderStaticText->Enabled = false;
   AssignReaderStaticText->Enabled = false;
   ReaderVersionStaticText->Enabled = false;
   ConfigFGenStaticText->Enabled = false;
   QueryFGenStaticText->Enabled = false;
   FGenResetStaticText->Enabled = false;
   QuerySFGenStaticText->Enabled = false;
   ConfigSFGenStaticText->Enabled = false;
   SmartFGenStaticText->Enabled = false;
   ConfigTagStaticText->Enabled = false;
   EnableTagStaticText->Enabled = false;
   DisableTagStaticText->Enabled = false;
   QueryTagStaticText->Enabled = false;
   CallTagStaticText->Enabled = false;
   AssignTagRdrStaticText->Enabled = false;
   ConfigTagRNDStaticText->Enabled = false;
   WriteMemoryStaticText->Enabled = false;
   ReadMemoryStaticText->Enabled = false;
   //EnableRdrFGenStaticText->Enabled = false;
   RelayStaticText->Enabled = false;
   InputsStaticText->Enabled = false;
   TagTempStaticText->Enabled = false;
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::GetProcRevDateBitBtnClick(
      TObject *Sender)
{
   //QueryFGenBitBtn->Font->Color = clRed;
   if (!QuerySFGenKeepRevListCheckBox->Checked)
      QuerySFGenProcListView->Items->Clear();

   TxClearTagCtrls();
   RxClearTagCtrls();
   //QueryFGenListView->Items->Clear();
   StaticText->Caption = "";
   receivedResponse = false;

   //if(QueryFGenFgRadioButton->Checked)
   //{
      /*if (!readerFgenButtonActivated)
      {
         ReaderFgenToolButton->Hint = "Programming Station Is In Field Generator Mode";
         readerFgenButtonActivated = true;
         if(networkOn)
            CloseNetworkConnection();
         else if (RS232On)
            ClosePort();
         lastBaudrate = baudRate;
         baudRate = 9600;
         EnableAllCommands(false);
         if (OpenSerial(comPort, baudRate))
         {
            ProgStationForm->PortOpen = true;
            PlaySound("Ding.wav", NULL, SND_ASYNC );
         }
         EnableAllCommands(true);

         readerOffLine = true;
         readerOnLine = false;
         fieldGenOffLine = true;
         fieldGenOnLine = false;
      }*/

      //WriteRS232Comm(QUERY_FIELD_GEN, 0, NULL, 0);
   /*
   } //if std field gen
   else  //smart field gen
   {
       if (readerFgenButtonActivated)
       {
          ReaderFgenToolButton->Hint = "Set Programming Station To Field Generator Mode";
          readerFgenButtonActivated = false;

          if(networkOn)
            CloseNetworkConnection();
         else if (RS232On)
            ClosePort();

         EnableAllCommands(false);
         if (OpenSerial(comPort, lastBaudrate))
         {
            ProgStationForm->PortOpen = true;
            baudRate = curBaudrate = lastBaudrate;
            PlaySound("Ding.wav", NULL, SND_ASYNC );
         }
         EnableAllCommands(true);
         readerOffLine = true;
         readerOnLine = false;
         fieldGenOffLine = true;
         fieldGenOnLine = false;
      }
      */

      QueryTagBitBtn->Enabled = false;
      EnableReaderStaticText->Enabled = false;
      DisableReaderStaticText->Enabled = false;
      QueryReaderStaticText->Enabled = false;
      AssignReaderStaticText->Enabled = false;
      ReaderVersionStaticText->Enabled = false;
      ConfigTxTimeStaticText->Enabled = false;
      RelayStaticText->Enabled = false;
      //EnableRdrFGenStaticText->Enabled = false;
      ConfigFGenStaticText->Enabled = false;
      QueryFGenStaticText->Enabled = false;
      FGenResetStaticText->Enabled = false;
      SmartFGenStaticText->Enabled = false;
      ConfigTagStaticText->Enabled = false;
      EnableTagStaticText->Enabled = false;
      DisableTagStaticText->Enabled = false;
      QueryTagStaticText->Enabled = false;
      CallTagStaticText->Enabled = false;
      AssignTagRdrStaticText->Enabled = false;
      ConfigTagRNDStaticText->Enabled = false;
      WriteMemoryStaticText->Enabled = false;
      ReadMemoryStaticText->Enabled = false;
      TagTempStaticText->Enabled = false;
      InputsStaticText->Enabled = false;

      QueryFGenBitBtn->Enabled = false;
      GetProcRevDateBitBtn->Enabled = false;

      if(networkOn)
      {
         int rdr = atoi(QueryFGenSmartFGenRdrIDComboBox->Text.c_str());
         int index = GetSocketIndex(rdr);
         if (index >= 0)
         {
            WriteAWSocket(QUERY_PROC_SMART_FIELD_GEN, 0, NULL, index, 'S', NULL, 0, index);
         }
         else
         {
            StaticText->Caption = "No matching socket for the reader.";
            return;
         }
      }
      else if (RS232On)
      {
         WriteRS232Comm(QUERY_PROC_SMART_FIELD_GEN, 0, NULL, 0);
      }
   //}
}
//---------------------------------------------------------------------------
AnsiString __fastcall TProgStationForm::GetMonth(unsigned short m)
{
   AnsiString month;

   switch (m)
   {
      case 1:
         month = "Jan";
      break;

      case 2:
         month = "Feb";
      break;

      case 3:
         month = "Mar";
      break;

      case 4:
         month = "Apr";
      break;

      case 5:
         month = "May";
      break;

      case 6:
         month = "Jun";
      break;

      case 7:
         month = "Jul";
      break;

      case 8:
         month = "Aug";
      break;

      case 9:
         month = "Sep";
      break;

      case 10:
         month = "Oct";
      break;

      case 11:
         month = "Nov";
      break;

      case 12:
         month = "Dec";
      break;
   }

   return (month);
}
void __fastcall TProgStationForm::QueryFGenClearRevListBitBtnClick(
      TObject *Sender)
{
   QueryFGenProcListView->Items->Clear();
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::FGenConfigStandFgenRadioButtonClick(
      TObject *Sender)
{
   FGenConfigFieldGenIDEdit->Visible = true;
   FGenConfigSmartFieldGenIDComboBox->Visible = false;
   FGenConfigSmartFGenReaderIDComboBox->Enabled = false;
   FGenConfigSmartFGenReaderIDComboBox->Color = clMenu;
   FGenConfigPotentiModifyCheckBox->Enabled = false;
   FGenConfigPotBitBtn->Enabled = false;
   FGenConfigPotentiModifyCheckBox->Checked = false;
   ConfigFGenGroupBox->Caption = "Configure Standard Field Generator";
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::FGenConfigSmartFgenRadioButtonClick(
      TObject *Sender)
{
   FGenConfigFieldGenIDEdit->Visible = false;
   FGenConfigSmartFieldGenIDComboBox->Visible = true;
   FGenConfigSmartFGenReaderIDComboBox->Enabled = true;
   FGenConfigSmartFGenReaderIDComboBox->Color = clWhite;
   FGenConfigPotentiModifyCheckBox->Enabled = true;
   FGenConfigPotBitBtn->Enabled = true;
   ConfigFGenGroupBox->Caption = "Configure Smart Field Generator";
}
//------------------------------------------------------------------------------

void __fastcall TProgStationForm::FGenConfigMDCheckBoxClick(
      TObject *Sender)
{
   if (FGenConfigMDCheckBox->Checked)
   {
      FGenConfigMDEnableCheckBox->Enabled = true;
      FGenConfigMDActiveHiRadioButton->Enabled = true;
      FGenConfigMDActiveLoRadioButton->Enabled = true;
      FGenConfigTxTimeModifyCheckBox->Checked = true;
      FGenConfigEnableISCheckBox->Enabled = true;
      //if (stdFGenType == 0x01)
         //FGenConfigEnableISCheckBox->Enabled = true;
      //else
         //FGenConfigEnableISCheckBox->Enabled = false;
      FGenConfigMDCheckBox->Font->Color = clRed;

   }
   else
   {
      FGenConfigMDEnableCheckBox->Enabled = false;
      FGenConfigMDActiveHiRadioButton->Enabled = false;
      FGenConfigMDActiveLoRadioButton->Enabled = false;
      FGenConfigEnableISCheckBox->Enabled = false;
      FGenConfigMDCheckBox->Font->Color = clOlive;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::FGenConfigPotentiModifyCheckBoxClick(
      TObject *Sender)
{
   if (FGenConfigPotentiModifyCheckBox->Checked)
   {
       FGenConfigPotentiComboBox->Enabled = true;
       FGenConfigPotentiComboBox->Color = clWhite;
       FGenConfigFSLabel->Enabled = true;
       FGenConfigPotentiModifyCheckBox->Font->Color = clRed;
   }
   else
   {
      FGenConfigPotentiComboBox->Enabled = false;
      FGenConfigPotentiComboBox->Color = clMenu;
      FGenConfigFSLabel->Enabled = false;
      FGenConfigPotentiModifyCheckBox->Font->Color = clOlive;
   }
}
//------------------------------------------------------------------------------
unsigned short __fastcall TProgStationForm::GetSFGenConfigCount()
{
    unsigned short count = 0;

    if (SFGenConfigAssignedReaderIDModifyCheckBox->Checked)
       count += 1;
    if (SFGenConfigFGenIDModifyCheckBox->Checked)
       count += 1;
    if (SFGenConfigTagTypeModifyCheckBox->Checked ||
        SFGenConfigRaRnModifyCheckBox->Checked)
       count += 1;
    if (SFGenConfigTagIDModifyCheckBox->Checked)
       count += 1;
    if (SFGenConfigTxTimeModifyCheckBox->Checked || SFGenConfigMDCheckBox->Checked)
       count += 1;
    if (SFGenConfigWaitTimeModifyCheckBox->Checked)
       count += 1;

    return (count);
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::FGenConfigPotBitBtnClick(TObject *Sender)
{
    if(networkOn)
    {
       /*int rdr = atoi(FGenConfigSmartFGenReaderIDComboBox->Text.c_str());
       int index = GetIpAddressIndex(rdr);
       if (index >= 0)
       {
            WriteTCPIPComm(ABS_DPOT_SMART_FGEN, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
       }*/

       int rdr = atoi(FGenConfigSmartFGenReaderIDComboBox->Text.c_str());
       int index = GetSocketIndex(rdr);
       if (index >= 0)
       {
          WriteAWSocket(ABS_DPOT_SMART_FGEN, 0, NULL, index, 'S', NULL, 0, index);
       }
       else
       {
          StaticText->Caption = "No matching socket for the reader.";
          return;
       }
    }
    else if (RS232On)
    {
       WriteRS232Comm(ABS_DPOT_SMART_FGEN, 0, NULL, 0);
    }

    EnableReaderStaticText->Enabled = false;
    DisableReaderStaticText->Enabled = false;
    QueryReaderStaticText->Enabled = false;
    AssignReaderStaticText->Enabled = false;
    ReaderVersionStaticText->Enabled = false;
    ConfigTxTimeStaticText->Enabled = false;
    RelayStaticText->Enabled = false;
    //EnableRdrFGenStaticText->Enabled = false;
    ConfigFGenStaticText->Enabled = false;
    ConfigSFGenStaticText->Enabled = false;
    QueryFGenStaticText->Enabled = false;
    QuerySFGenStaticText->Enabled = false;
    FGenResetStaticText->Enabled = false;
    SmartFGenStaticText->Enabled = false;
    ConfigTagStaticText->Enabled = false;
    EnableTagStaticText->Enabled = false;
    DisableTagStaticText->Enabled = false;
    QueryTagStaticText->Enabled = false;
    CallTagStaticText->Enabled = false;
    AssignTagRdrStaticText->Enabled = false;
    ConfigTagRNDStaticText->Enabled = false;
    WriteMemoryStaticText->Enabled = false;
    ReadMemoryStaticText->Enabled = false;
    TagTempStaticText->Enabled = false;
    InputsStaticText->Enabled = false;
}
//------------------------------------------------------------------------------

void __fastcall TProgStationForm::SmartFGenPotentioUpDownClick(
      TObject *Sender, TUDBtnType Button)
{
   /*if(networkOn)
   {
      int rdr = atoi(SmartFGenReaderIDComboBox->Text.c_str());
      int index = GetIpAddressIndex(rdr);
      if (index >= 0)
      {
         if (Button == btNext)
            WriteTCPIPComm(INC_DPOT_SMART_FGEN, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
         else
            WriteTCPIPComm(DEC_DPOT_SMART_FGEN, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
      }
      else
      {
         Application->MessageBox("Did not find IP address.",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return;
      }
   }
   else if (RS232On)
   {

      if (Button == btNext)
         WriteRS232Comm(INC_DPOT_SMART_FGEN, 0, NULL, 0);
      else
         WriteRS232Comm(DEC_DPOT_SMART_FGEN, 0, NULL, 0);
   } */
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::SmartFGenGetDPotBitBtnClick(
      TObject *Sender)
{
   SmartFGenDPotValueLabel->Caption = "";
   SmartFGenNewDPotEdit->Text = "";
   StaticText->Caption = "";

   if(networkOn)
   {
      /*int rdr = atoi(SmartFGenReaderIDComboBox->Text.c_str());
      int index = GetIpAddressIndex(rdr);
      if (index >= 0)
      {
         WriteTCPIPComm(GET_DPOT_SMART_FGEN, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
      }
      else
      {
         Application->MessageBox("Did not find IP address.",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return;
      }*/

      int rdr = atoi(SmartFGenReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
          WriteAWSocket(GET_DPOT_SMART_FGEN, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
      {
          StaticText->Caption = "No matching socket for the reader.";
          return;
      }
   }
   else if (RS232On)
   {
      WriteRS232Comm(GET_DPOT_SMART_FGEN, 0, NULL, 0);
   }
}
//---------------------------------------------------------------------------


void __fastcall TProgStationForm::SmartFGenPotentioUpDownChangingEx(
      TObject *Sender, bool &AllowChange, short NewValue,
      TUpDownDirection Direction)
{
   if(networkOn)
   {
      /*int rdr = atoi(SmartFGenReaderIDComboBox->Text.c_str());
      int index = GetIpAddressIndex(rdr);
      if (index >= 0)
      {
         if (Direction == updUp)
            WriteTCPIPComm(INC_DPOT_SMART_FGEN, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
         else if (Direction == updDown)
            WriteTCPIPComm(DEC_DPOT_SMART_FGEN, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
         else
            return;
      }
      else
      {
         Application->MessageBox("Did not find IP address.",
                                 "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         return;
      }*/

      int rdr = atoi(SmartFGenReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         if (Direction == updUp)
            WriteAWSocket(INC_DPOT_SMART_FGEN, 0, NULL, index, 'S', NULL, 0, index);
         else if (Direction == updDown)
            WriteAWSocket(DEC_DPOT_SMART_FGEN, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
      {
          StaticText->Caption = "No matching socket for the reader.";
          return;
      }
   }
   else if (RS232On)
   {

      if (Direction == updUp)
         WriteRS232Comm(INC_DPOT_SMART_FGEN, 0, NULL, 0);
      else if (Direction == updDown)
         WriteRS232Comm(DEC_DPOT_SMART_FGEN, 0, NULL, 0);
      else
         return;
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::PollTimerTimer(TObject *Sender)
{
   if (numSockPoll <= 0)
   {
     return;
   }


   if (numSockPoll == 1)
   {
       if (sockPollQue[0].txFlag)
       {
          if (WriteSockets(0))   //poll
          {
            sockPollQue[0].txFlag = false;
            for (int i=0; i<sockPollQue[0].txLen; i++)
              sockPollQue[0].XBuf[i] = '\0';
            sockPollQue[0].txLen = 0;
          }
       }

       return;
   }

   ClientSocket->Active = false;
   ClientSocket->Address = sockPollQue[sockQueIndex].ip;
   ClientSocket->Tag = sockQueIndex;
   ClientSocket->Active = true;


   //more than one active socket transmit in the connect routine
   /*if (sockPollQue[sockQueIndex].txFlag)
   {
      //ClientSocket->Active = true;
      if (WriteSockets(sockQueIndex))   //poll
      {
         sockPollQue[sockQueIndex].txFlag = false;
         for (int i=0; i<sockPollQue[sockQueIndex].txLen; i++)
           sockPollQue[sockQueIndex].XBuf[i] = '\0';
         sockPollQue[sockQueIndex].txLen = 0;
      }
   }
   //else
      //ClientSocket->Active = true; */

   //ClientSocket->Active = true;

   temp = "Connect ";
   temp += sockPollQue[sockQueIndex].ip;
   sockQueIndex += 1;
   if (sockQueIndex >= numSockPoll)
      sockQueIndex = 0;

}

//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ClientSocketError(TObject *Sender,
      TCustomWinSocket *Socket, TErrorEvent ErrorEvent, int &ErrorCode)
{
   AnsiString s;
   AnsiString ip;
   int index;

   if (ErrorEvent == eeConnect)
   {
      index = ((TComponent *)Sender)->Tag; // - MAX_DESCRIPTOR;
      if (index >= 0)
      {
      sockConnectQue[((TComponent *)Sender)->Tag].numRetry += 1;

      if (ProgStationForm->sockConnectQue[ProgStationForm->sockConnectQueIndex].numRetry >= ProgStationForm->maxConnectRetry)
         ProgStationForm->numSelectedSockConnect -= 1;

      if (ProgStationForm->numSelectedSockConnect <= 0)
      {
         if (comConfigDialog)
         {
            comConfigDialog->ConnectTimer->Enabled = false;
            ProgStationForm->numSelectedSockConnect = 0;
         }
      }

      ip = sockConnectQue[index].ip;
      if ((ip.data() != NULL) && comConfigDialog)
      {
         s = "IP = ";
         s += ip;
         s += " failed to connect.";
         comConfigDialog->Msg->Caption = s;
      }
      }//if index >= 0
   }

   ErrorCode = 0;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ClientSocketConnect(TObject *Sender,
      TCustomWinSocket *Socket)
{
   AnsiString ip;
   int indx;

   if (ConnectingSockets)
   {

   AnsiString s;
   indx = ((TComponent *)Sender)->Tag; // - MAX_DESCRIPTOR;
   if (indx < 0)
      return;
   ip = sockConnectQue[indx].ip;

   if (ip.data() != NULL)
   {
      if (comConfigDialog)
      {
        s = "IP = ";
        s += ip;
        s += " connected.";
        comConfigDialog->Msg->Caption = s;
      }
   //update the listview
   //indx = GetIpAddressInlistView(ip);
   if (indx >= 0)
   {
      //strcpy([indx].netStatus, "Active");
      //listViewInfo[indx].selected = false;
      if (updateIpList)
        comConfigDialog->UpdateIPListView();
   }
   else
   {
        comConfigDialog->AddIpToList(ip, true);
   }

   //update the sockConnectque
   indx = GetSockConnectQueIndex(ip);
   if (indx >= 0)
   {
      if (sockConnectQue[indx].connect == false)
         numSockConnected += 1;

      sockConnectQue[indx].connect = true;
   }

   //put the connected socket in the que if does not exist
   indx = GetSockPollQueIndex(ip);
   if (indx < 0)
   {
      sockPollQue[numSockPoll].ip = ip;
      numSockPoll += 1;
   }
   }
   } //null
   else
   {
      ip = sockConnectQue[((TComponent *)Sender)->Tag].ip;

      if (ip.data() != NULL)
      {

         indx = GetSockPollQueIndex(ip);
         if (indx >= 0)
         {
            if (sockPollQue[indx].txFlag)
            {
               if (WriteSockets(indx)) //connect
               {
                  sockPollQue[indx].txFlag = false;
                  for (int i=0; i<sockPollQue[indx].txLen; i++)
                     sockPollQue[indx].XBuf[i] = '\0';
                  sockPollQue[indx].txLen = 0;
               }
            }
          }
        }
   }
}

void __fastcall TProgStationForm::ClientSocketRead(TObject *Sender,
      TCustomWinSocket *Socket)
{
   char buf[255];
   int bytes = 0;
   AnsiString ip;
   int index;
   int reader;
   int host;

   int n = Socket->ReceiveLength();
   //AnsiString str = "n = ";
   //str += n;
   //Label2->Caption = str;
   while (n > 32)
   {
      bytes = Socket->ReceiveBuf((char *)buf, 255);
      //str = "Bytes Read = ";
      //str += bytes;
      //Label3->Caption = str;
      n -= bytes;
      //str = "n = ";
      //str += n;
      //Label2->Caption = str;
   }

   if (n > 0)
   {
      bytes = Socket->ReceiveBuf((char *)recvBuf, n);
      if (displayRx)
      {
         pktCounter++;
         DisplayRecPackets(recvBuf, n, false, false, sockPollQue[((TComponent *)Sender)->Tag].ip);
      }

      if (recvBuf[1] == POWER_UP)
      {
         //if ((((TComponent *)Sender)->Tag - MAX_DESCRIPTOR) > 0)
             //ip = sockConnectQue[((TComponent *)Sender)->Tag].ip;
         //else
             ip = sockPollQue[((TComponent *)Sender)->Tag].ip;

         if (ip.data() != NULL)
         {
            index = GetSockPollQueIndex(ip);
            if (index >= 0)
            {
               if ((recvBuf[3] & 0x38) == 0x30)  //exteded reader
               {
                  reader = (unsigned int)(unsigned char)recvBuf[4]*pow(2, 8)+(unsigned int)(unsigned char)recvBuf[5];
                  host = (unsigned char)recvBuf[6];
                  sockPollQue[index].reader = reader;
                  sockPollQue[index].host = host;
               }
               else
               {
                  reader = (unsigned char)recvBuf[4];
                  host = (unsigned char)recvBuf[5];
                  sockPollQue[index].reader = reader;
                  sockPollQue[index].host = host;
               }

               if (ip.data() != NULL)
               {
                 index = GetIpAddressIndex(ip);
                 if (index >= 0)
                 {
                    strcpy(listViewInfo[index].rdrStatus, "Online");
                    listViewInfo[index].reader = reader;
                    listViewInfo[index].host = host;
                    //listViewInfo[index].selected = false;
                    if (comConfigDialog)
                       comConfigDialog->UpdateIPListView();
                 }
              }
           }//if index > 0
         }//if ip == null
      }//if power-up
      ProgStationForm->PacketParser(bytes, 0);
   }
}
//---------------------------------------------------------------------------
bool __fastcall TProgStationForm::WriteSockets(int index)
{
    int k = ClientSocket->Socket->SendBuf((unsigned char*)sockPollQue[index].XBuf, sockPollQue[index].txLen);

    if (displayTx)
    {
       pktCounter++;
       DisplayTransmitPackets(sockPollQue[index].XBuf, sockPollQue[index].txLen, sockPollQue[index].ip);
    }

    if ((fileHandle != NULL) && recording)
    {
       txDebugStr = BuildTxRecordPktStr(sockPollQue[index].XBuf, sockPollQue[index].txLen);
       txDebugStr += "\n";
       fwrite(txDebugStr.c_str(), txDebugStr.Length(), 1, fileHandle);
    }

   if (k == sockPollQue[index].txLen)
      return (true);
   else
      return (false);
}
//------------------------------------------------------------------------------
bool __fastcall TProgStationForm::ConnectSocket(AnsiString ip)
{
   bool found = false;
   int index;

   for (int i=0; i<MAX_DESCRIPTOR; i++)
   {
      if (AWSockets[i])
      {
         if (AWSockets[i]->AWClientSocket->Address == ip)
         {
            found = true;
            index = i;
            break;
         }
      }
   }

   if (found)
   {
      if (AWSockets[index]->connected)
         AWSockets[index]->AWClientSocket->Active = false;

      AWSockets[index]->AWClientSocket->Active = true;
   }
   else
   {
      for (int i=0; i<MAX_DESCRIPTOR; i++)
      {
         if (AWSockets[i] == NULL)
         {
            AWSockets[i] = new TTAWSocket(this);
            Application->CreateForm(__classid(TTAWSocket), &AWSockets[i]);
            AWSockets[i]->Visible = false;
            AWSockets[i]->AWClientSocket->Address = ip;
            AWSockets[i]->AWClientSocket->Active = true;
            break;
         }
      }
   }

   return (found);
}
//------------------------------------------------------------------------------
bool __fastcall TProgStationForm::DisconnectSocket(AnsiString ip)
{
   bool found = false;
   int index;

   for (int i=0; i<MAX_DESCRIPTOR; i++)
   {
      if (AWSockets[i])
      {
         if (AWSockets[i]->AWClientSocket->Address == ip)
         {
            found = true;
            index = i;
            break;
         }
      }
   }

   if (found)
   {
      if (AWSockets[index]->connected)
      {
         AWSockets[index]->AWClientSocket->Active = false;
         AWSockets[index]->connected = false;
      }
   }
   else
      return (false);

   return (true);
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::DisconnectAllSockets()
{
   bool found = false;
   int index;

   for (int i=0; i<MAX_DESCRIPTOR; i++)
   {
      if (AWSockets[i])
      {
         if ((AWSockets[i]->AWClientSocket->Address != NULL) &&
              AWSockets[i]->connected)
         {
            AWSockets[i]->AWClientSocket->Active = false;
            AWSockets[i]->connected = false;
         }
      }
   }
}
//------------------------------------------------------------------------------
int __fastcall TProgStationForm::GetSocketIndex(AnsiString ip)
{
   for (int i=0; i<MAX_DESCRIPTOR; i++)
   {
      if (AWSockets[i]->AWClientSocket->Address == ip)
         return (i);
   }

   return (-1);
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::AssignReaderNewRdrCheckBoxClick(
      TObject *Sender)
{
   if (AssignReaderNewRdrCheckBox->State == cbUnchecked)
   {
      AssignReaderNewIDEdit->Color = clMenu;
      AssignReaderNewIDEdit->Font->Color = clGray;
      AssignReaderNewIDEdit->ReadOnly = true;
   }
   else
   {
      AssignReaderNewIDEdit->Color = clWhite;
      AssignReaderNewIDEdit->Font->Color = clNavy;
      AssignReaderNewIDEdit->ReadOnly = false;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::AssignReaderNewHostCheckBoxClick(
      TObject *Sender)
{
   if (AssignReaderNewHostCheckBox->State == cbUnchecked)
   {
      AssignReaderNewHostIDEdit->Color = clMenu;
      AssignReaderNewHostIDEdit->Font->Color = clGray;
      AssignReaderNewHostIDEdit->ReadOnly = true;
   }
   else
   {
      AssignReaderNewHostIDEdit->Color = clWhite;
      AssignReaderNewHostIDEdit->Font->Color = clNavy;
      AssignReaderNewHostIDEdit->ReadOnly = false;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::AssignReaderNoChangeCheckBoxClick(
      TObject *Sender)
{
   if (AssignReaderNoChangeCheckBox->State == cbUnchecked)
   {
      //AssinReaderTypeLabel->Enabled = false;
      AssignReaderTypeComboBox->Enabled = false;
      AssignReaderBroadcastCheckBox->Enabled = false;
      AssignReaderEnableCheckBox->Enabled = false;
      AssignReaderRSSICheckBox->Enabled = false;
   }
   else
   {
      //AssinReaderTypeLabel->Enabled = true;
      AssignReaderTypeComboBox->Enabled = true;
      AssignReaderBroadcastCheckBox->Enabled = true;
      AssignReaderEnableCheckBox->Enabled = true;
      AssignReaderRSSICheckBox->Enabled = true;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ReaderCMDRadioButtonClick(
      TObject *Sender)
{
   ReaderCMDPanel->Visible = true;
   SmartFGenCMDPanel->Visible = false;
   TagCMDPanel->Visible = false;
   FGenCMDPanel->Visible = false;

   ReaderCMDRadioButton->Font->Color = clRed;
   TagCMDRadioButton->Font->Color = clBlue;
   SFGenCMDRadioButton->Font->Color = clBlue;
   FGenCMDRadioButton->Font->Color = clBlue;

   if (readerFgenButtonActivated)
   {
      ReaderFgenToolButton->Hint = "Set Programming Station To Field Generator Mode";
      if (readerFgenButtonActivated)
      {
          readerFgenButtonActivated = false;
          MainStatusBar->Panels->Items[1]->Text = "Reader Offline";
      }

      if (RS232On)
         ClosePort();

      EnableAllCommands(false);
      if (OpenSerial(comPort, lastBaudrate))
      {
         ProgStationForm->PortOpen = true;
         baudRate = curBaudrate = lastBaudrate;
         PlaySound("Ding.wav", NULL, SND_ASYNC );
      }
      EnableAllCommands(true);
      readerOffLine = true;
      readerOnLine = false;
      fieldGenOffLine = true;
      fieldGenOnLine = false;
   }

   if (!ResetReaderGroupBox->Visible)
   {
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = true;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ShowReaderStaticCommands();
   EnableReaderStaticCommands();
   HideAllCommandBtns();
   ResetReaderStaticText->Visible = false;
   ResetDeviceBitBtn->Visible = true;

   /*ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   DownloadRdrBitBtn->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   DownloadRdrBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;*/

   ResetListView->Items->Clear();
   if (lastReaderID > 0)
      ResetReaderIDComboBox->Text = lastReaderID;
   for (unsigned int i=0; i<numReaderIDList; i++)
   {
      if (ResetReaderIDComboBox->Items->IndexOf(readerIDList[i]) == -1 )
         ResetReaderIDComboBox->Items->Add(readerIDList[i]);
   }

   if (allHostID)
   {
      if (lastHostID > 0)
         ResetHostIDEdit->Text = lastHostID;
   }
   else
      ResetHostIDEdit->Text = sysHostID;

   //Reset Device  0x01
   TxClearTagCtrls();
   RxClearTagCtrls();

   waitingForRespone = false;
   waitResetRdrACK = false;

}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::FGenCMDRadioButtonClick(TObject *Sender)
{
   ReaderCMDPanel->Visible = false;
   SmartFGenCMDPanel->Visible = false;
   TagCMDPanel->Visible = false;
   FGenCMDPanel->Visible = true;

   ReaderCMDRadioButton->Font->Color = clBlue;
   TagCMDRadioButton->Font->Color = clBlue;
   SFGenCMDRadioButton->Font->Color = clBlue;
   FGenCMDRadioButton->Font->Color = clRed;

   ReaderFgenToolButton->Hint = "Programming Station Is In Field Generator Mode";
   readerFgenButtonActivated = true;
   if(networkOn)
      CloseNetworkConnection();
   else if (RS232On)
      ClosePort();
   lastBaudrate = baudRate;
   baudRate = 9600;
   EnableAllCommands(false);
   if (OpenSerial(comPort, baudRate))
   {
            ProgStationForm->PortOpen = true;
            PlaySound("Ding.wav", NULL, SND_ASYNC );
   }
   EnableAllCommands(true);

   readerOffLine = true;
   readerOnLine = false;
   fieldGenOffLine = true;
   fieldGenOnLine = false;

   if (!QueryFGenGroupBox->Visible)
   {
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = true;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      //GeneralGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ShowStdFGenStaticCommands();
   EnableStdFGenStaticCommands();
   HideAllCommandBtns();
   QueryFGenStaticText->Visible = false;
   QueryFGenBitBtn->Visible = true;

   /*ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;*/

   if (allHostID)   //Host
   {
      if (lastHostID > 0)
         QueryFGenHostIDEdit->Text = lastHostID;
   }
   else
      QueryFGenHostIDEdit->Text = sysHostID;

   QueryFGenSmartFGenRdrIDComboBox->Items->Clear();  //reader smart Fgen
   for (unsigned int i=0; i<numReaderIDList; i++)
      QueryFGenSmartFGenRdrIDComboBox->Items->Add(readerIDList[i]);
   if (lastReaderID <= 0)
      QueryFGenSmartFGenRdrIDComboBox->Text = "";
   else
      QueryFGenSmartFGenRdrIDComboBox->Text = lastReaderID;

   QueryFGenSmartFGenIDComboBox->Items->Clear();  //FGen smart
   for (unsigned int i=0; i<numSFgenIDList; i++)
      QueryFGenSmartFGenIDComboBox->Items->Add(fgenIDList[i]);
   if (lastSmartFieldGenID <= 0)
      QueryFGenSmartFGenIDComboBox->Text = "";
   else
      QueryFGenSmartFGenIDComboBox->Text = lastSmartFieldGenID;

   if (lastFieldGenID <= 0)   //Fgen
      QueryFGenIDEdit->Text = "";
   else
      QueryFGenIDEdit->Text = lastFieldGenID;

   TxClearTagCtrls();
   RxClearTagCtrls();
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::SFGenCMDRadioButtonClick(TObject *Sender)
{
   ReaderCMDPanel->Visible = false;
   SmartFGenCMDPanel->Visible = true;
   TagCMDPanel->Visible = false;
   FGenCMDPanel->Visible = false;

   ReaderCMDRadioButton->Font->Color = clBlue;
   TagCMDRadioButton->Font->Color = clBlue;
   SFGenCMDRadioButton->Font->Color = clRed;
   FGenCMDRadioButton->Font->Color = clBlue;

   if (!FGenResetGroupBox->Visible)
   {
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = true;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ShowSmartFGenStaticCommands();
   EnableSmartFGenStaticCommands();
   HideAllCommandBtns();
   FGenResetStaticText->Visible = false;
   FGenResetBitBtn->Visible = true;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   SmartFGenBitBtn->Font->Color = clPurple;
   FGenResetBitBtn->Font->Color = clPurple;
   DownloadSFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   if (allHostID)
   {
      if (lastHostID > 0)
         FGenResetHostIDEdit->Text = lastHostID;
   }
   else
      FGenResetHostIDEdit->Text = sysHostID;

   if (lastFieldGenID <= 0)
      FGenResetIDComboBox->Text = "";
   else
      FGenResetIDComboBox->Text = lastFieldGenID;

   FGenResetReaderIDComboBox->Items->Clear();
   for (unsigned int i=0; i<numReaderIDList; i++)
      FGenResetReaderIDComboBox->Items->Add(readerIDList[i]);

   if (lastReaderID <= 0)
      FGenResetReaderIDComboBox->Text = "";
   else
      FGenResetReaderIDComboBox->Text = lastReaderID;

   TxClearTagCtrls();
   RxClearTagCtrls();

   if (readerFgenButtonActivated)
   {
      ReaderFgenToolButton->Hint = "Set Programming Station To Field Generator Mode";
      readerFgenButtonActivated = false;

      if (RS232On)
         ClosePort();

      EnableAllCommands(false);
      if (OpenSerial(comPort, lastBaudrate))
      {
         ProgStationForm->PortOpen = true;
         baudRate = curBaudrate = lastBaudrate;
         PlaySound("Ding.wav", NULL, SND_ASYNC );
      }
      EnableAllCommands(true);
      readerOffLine = true;
      readerOnLine = false;
      fieldGenOffLine = true;
      fieldGenOnLine = false;
   }

   FGenResetBitBtn->Enabled = true;
   FGenResetBitBtn->Visible = true;
   FGenResetStaticText->Visible = false;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::TagCMDRadioButtonClick(TObject *Sender)
{
   ReaderCMDPanel->Visible = false;
   SmartFGenCMDPanel->Visible = false;
   TagCMDPanel->Visible = true;
   FGenCMDPanel->Visible = false;

   ReaderCMDRadioButton->Font->Color = clBlue;
   TagCMDRadioButton->Font->Color = clRed;
   SFGenCMDRadioButton->Font->Color = clBlue;
   FGenCMDRadioButton->Font->Color = clBlue;

   if (!EnableTagGroupBox->Visible)
   {
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      //GeneralGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = true;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ShowTagStaticCommands();
   EnableTagStaticCommands();
   HideAllCommandBtns();
   EnableTagStaticText->Visible = false;
   EnableTagBitBtn->Visible = true;

   /*ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;*/

   //if (lastHostID <= 0)
      //EnableTagHostIDEdit->Text = "";
   //else
      //EnableTagHostIDEdit->Text = lastHostID;
   if (allHostID)
   {
      if (lastHostID > 0)
         EnableTagHostIDEdit->Text = lastHostID;
   }
   else
      EnableTagHostIDEdit->Text = sysHostID;

   EnableTagIDComboBox->Items->Clear();
   for (unsigned int i=0; i<numReaderIDList; i++)
      EnableTagIDComboBox->Items->Add(readerIDList[i]);

   if (lastReaderID <= 0)
      EnableTagIDComboBox->Text = "";
   else
      EnableTagIDComboBox->Text = lastReaderID;

   EnableTagRNShortRadioButton->Checked = true;

   TxClearTagCtrls();
   RxClearTagCtrls();

   if (readerFgenButtonActivated)
   {
      ReaderFgenToolButton->Hint = "Set Programming Station To Field Generator Mode";
      readerFgenButtonActivated = false;

      if (RS232On)
         ClosePort();

      EnableAllCommands(false);
      if (OpenSerial(comPort, lastBaudrate))
      {
         ProgStationForm->PortOpen = true;
         baudRate = curBaudrate = lastBaudrate;
         PlaySound("Ding.wav", NULL, SND_ASYNC );
      }
      EnableAllCommands(true);
      readerOffLine = true;
      readerOnLine = false;
      fieldGenOffLine = true;
      fieldGenOnLine = false;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::QuerySFGenStaticTextClick(
      TObject *Sender)
{
   if (!QuerySFGenGroupBox->Visible)
   {
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = true;
      DownloadSFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      //GeneralGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = false;
   SmartFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   //EnableFGenStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   DownloadSFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = true;
   FGenResetBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   QuerySFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   if (allHostID)   //Host
   {
      if (lastHostID > 0)
         QuerySFGenHostIDEdit->Text = lastHostID;
   }
   else
      QuerySFGenHostIDEdit->Text = sysHostID;

   QueryFGenSmartFGenRdrIDComboBox->Items->Clear();  //reader smart Fgen
   for (unsigned int i=0; i<numReaderIDList; i++)
      QueryFGenSmartFGenRdrIDComboBox->Items->Add(readerIDList[i]);
   if (lastReaderID <= 0)
      QueryFGenSmartFGenRdrIDComboBox->Text = "";
   else
      QueryFGenSmartFGenRdrIDComboBox->Text = lastReaderID;

   QueryFGenSmartFGenIDComboBox->Items->Clear();  //FGen smart
   for (unsigned int i=0; i<numSFgenIDList; i++)
      QueryFGenSmartFGenIDComboBox->Items->Add(fgenIDList[i]);
   if (lastSmartFieldGenID <= 0)
      QueryFGenSmartFGenIDComboBox->Text = "";
   else
      QueryFGenSmartFGenIDComboBox->Text = lastSmartFieldGenID;

   TxClearTagCtrls();
   RxClearTagCtrls();
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::QuerySFGenBitBtnClick(TObject *Sender)
{
   QuerySFGenBitBtn->Font->Color = clRed;
   if (!QuerySFGenCheckBox->Checked)
      QuerySFGenListView->Items->Clear();

   TxClearTagCtrls();
   RxClearTagCtrls();

   StaticText->Caption = "";
   receivedResponse = false;


   /*if (readerFgenButtonActivated)
   {
          ReaderFgenToolButton->Hint = "Set Programming Station To Field Generator Mode";
          readerFgenButtonActivated = false;

          if(networkOn)
            CloseNetworkConnection();
         else if (RS232On)
            ClosePort();

         EnableAllCommands(false);
         if (OpenSerial(comPort, lastBaudrate))
         {
            ProgStationForm->PortOpen = true;
            baudRate = curBaudrate = lastBaudrate;
            PlaySound("Ding.wav", NULL, SND_ASYNC );
         }
         EnableAllCommands(true);
         readerOffLine = true;
         readerOnLine = false;
         fieldGenOffLine = true;
         fieldGenOnLine = false;
   }*/

      //QueryTagBitBtn->Enabled = false;
      /*EnableReaderStaticText->Enabled = false;
      DisableReaderStaticText->Enabled = false;
      QueryReaderStaticText->Enabled = false;
      AssignReaderStaticText->Enabled = false;
      ReaderVersionStaticText->Enabled = false;
      ConfigTxTimeStaticText->Enabled = false;
      RelayStaticText->Enabled = false;
      EnableRdrFGenStaticText->Enabled = false;
      ConfigFGenStaticText->Enabled = false;
      QueryFGenStaticText->Enabled = false;
      QuerySFGenStaticText->Enabled = false;
      ConfigSFGenStaticText->Enabled = false;
      FGenResetStaticText->Enabled = false;
      SmartFGenStaticText->Enabled = false;
      ConfigTagStaticText->Enabled = false;
      EnableTagStaticText->Enabled = false;
      DisableTagStaticText->Enabled = false;
      QueryTagStaticText->Enabled = false;
      CallTagStaticText->Enabled = false;
      AssignTagRdrStaticText->Enabled = false;
      ConfigTagRNDStaticText->Enabled = false;
      WriteMemoryStaticText->Enabled = false;
      ReadMemoryStaticText->Enabled = false;
      TagTempStaticText->Enabled = false;
      InputsStaticText->Enabled = false;*/

      numSFgenIDList = 0;
      //QueryFGenListView->Items->Clear();

      CMDEnableTimer->Enabled = true;
      DisableSmartFGenStaticCommands();
      QuerySFGenBitBtn->Enabled = false;

      //if (lastReaderID > 0)
         //QueryFGenSmartFGenRdrIDComboBox->Text = lastReaderID;
      for (unsigned int i=0; i<numReaderIDList; i++)
      {
         if (QueryFGenSmartFGenRdrIDComboBox->Items->IndexOf(readerIDList[i]) == -1 )
            QueryFGenSmartFGenRdrIDComboBox->Items->Add(readerIDList[i]);
      }

      if (allHostID)
      {
         if (lastHostID > 0)
            QuerySFGenHostIDEdit->Text = lastHostID;
      }
      else
         QuerySFGenHostIDEdit->Text = sysHostID;

      if(networkOn)
      {
         /*int rdr = atoi(QueryFGenSmartFGenRdrIDComboBox->Text.c_str());
         int index = GetIpAddressIndex(rdr);
         if (index >= 0)
         {
            WriteTCPIPComm(QUERY_SMART_FIELD_GEN, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
         }*/

         int rdr = atoi(QueryFGenSmartFGenRdrIDComboBox->Text.c_str());
         int index = GetSocketIndex(rdr);
         if (index >= 0)
         {
            WriteAWSocket(QUERY_SMART_FIELD_GEN, 0, NULL, index, 'S', NULL, 0, index);
         }
         else
            StaticText->Caption = "No matching socket for the reader.";
      }
      else if (RS232On)
      {
         WriteRS232Comm(QUERY_SMART_FIELD_GEN, 0, NULL, 0);
      }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigSFGenStaticTextClick(
      TObject *Sender)
{
    if (!ConfigSFGenGroupBox->Visible)
    {
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = true;
      EnableFGenGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      DownloadSFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      //GeneralGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = false;
   QueryFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = true;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   DownloadSFGenBitBtn->Visible = false;
   //ConfigSFGenBitBtn->Visible = false;
   FGenResetBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   ConfigSFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   SFGenConfigWaitTimeSecClicked = false;
   SFGenConfigWaitTimeMinClicked = false;
   SFGenConfigWaitTimeHourClicked = false;

   SFGenConfigTxTimeComboBox->Items->Clear();
   for (int i=1; i<=60; i++)
      SFGenConfigTxTimeComboBox->Items->Add(i);
   SFGenConfigTxTimeComboBox->Text = "";

   /////////////////////////////////
   if (allHostID)   //Host
   {
      if (lastHostID > 0)
         SFGenConfigHostIDEdit->Text = lastHostID;
   }
   else
      SFGenConfigHostIDEdit->Text = sysHostID;

   FGenConfigSmartFGenReaderIDComboBox->Items->Clear();  //reader smart Fgen
   for (unsigned int i=0; i<numReaderIDList; i++)
      FGenConfigSmartFGenReaderIDComboBox->Items->Add(readerIDList[i]);
   if (lastReaderID <= 0)
      FGenConfigSmartFGenReaderIDComboBox->Text = "";
   else
      FGenConfigSmartFGenReaderIDComboBox->Text = lastReaderID;

   FGenConfigSmartFieldGenIDComboBox->Items->Clear();  //FGen smart
   for (unsigned int i=0; i<numSFgenIDList; i++)
      FGenConfigSmartFieldGenIDComboBox->Items->Add(fgenIDList[i]);
   if (lastSmartFieldGenID <= 0)
      FGenConfigSmartFieldGenIDComboBox->Text = "";
   else
      FGenConfigSmartFieldGenIDComboBox->Text = lastSmartFieldGenID;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigSFGenBitBtnClick(TObject *Sender)
{
   ConfigSFGenBitBtn->Font->Color = clRed;

   /*QueryTagBitBtn->Enabled = false;
   EnableReaderStaticText->Enabled = false;
   DisableReaderStaticText->Enabled = false;
   QueryReaderStaticText->Enabled = false;
   AssignReaderStaticText->Enabled = false;
   ReaderVersionStaticText->Enabled = false;
   ConfigTxTimeStaticText->Enabled = false;
   RelayStaticText->Enabled = false;
   EnableRdrFGenStaticText->Enabled = false;
   ConfigFGenStaticText->Enabled = false;
   ConfigSFGenStaticText->Enabled = false;
   QueryFGenStaticText->Enabled = false;
   FGenResetStaticText->Enabled = false;
   SmartFGenStaticText->Enabled = false;
   QuerySFGenStaticText->Enabled = false;
   ConfigSFGenStaticText->Enabled = false;
   ConfigTagStaticText->Enabled = false;
   EnableTagStaticText->Enabled = false;
   DisableTagStaticText->Enabled = false;
   QueryTagStaticText->Enabled = false;
   CallTagStaticText->Enabled = false;
   AssignTagRdrStaticText->Enabled = false;
   ConfigTagRNDStaticText->Enabled = false;
   WriteMemoryStaticText->Enabled = false;
   ReadMemoryStaticText->Enabled = false;
   TagTempStaticText->Enabled = false;
   InputsStaticText->Enabled = false;*/

   TxClearTagCtrls();
   RxClearTagCtrls();
   StaticText->Caption = "";
   receivedResponse = false;
   StaticText->Caption = progStr;

   /*if (readerFgenButtonActivated)
   {
         ReaderFgenToolButton->Hint = "Set Programming Station To Field Generator Mode";
         readerFgenButtonActivated = false;
         if(networkOn)
            CloseNetworkConnection();
         else if (RS232On)
            ClosePort();
         EnableAllCommands(false);
         if (OpenSerial(comPort, lastBaudrate))
         {
            ProgStationForm->PortOpen = true;
            baudRate = curBaudrate = lastBaudrate;
            PlaySound("Ding.wav", NULL, SND_ASYNC );
         }
         EnableAllCommands(true);

         readerOffLine = true;
         readerOnLine = false;
         fieldGenOffLine = true;
         fieldGenOnLine = false;
   }*/

   CMDEnableTimer->Enabled = true;
   DisableSmartFGenStaticCommands();
   ConfigSFGenBitBtn->Enabled = false;


   if(networkOn)
   {
         /*int rdr = atoi(FGenConfigSmartFGenReaderIDComboBox->Text.c_str());
         int index = GetIpAddressIndex(rdr);
         if (index >= 0)
         {
            WriteTCPIPComm(CONFIG_SMART_FIELD_GEN, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
         }*/

         int rdr = atoi(FGenConfigSmartFGenReaderIDComboBox->Text.c_str());
         int index = GetSocketIndex(rdr);
         if (index >= 0)
         {
            WriteAWSocket(CONFIG_SMART_FIELD_GEN, 0, NULL, index, 'S', NULL, 0, index);
         }
         else
            StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(CONFIG_SMART_FIELD_GEN, 0, NULL, 0);
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::SFGenConfigAssignedReaderIDModifyCheckBoxClick(
      TObject *Sender)
{
   if (SFGenConfigAssignedReaderIDModifyCheckBox->Checked)
    {
       SFGenConfigAssignedReaderIDEdit->ReadOnly = false;
       SFGenConfigAssignedReaderIDEdit->Color = clWhite;
       SFGenConfigAssignedReaderIDEdit->Font->Color = clBlue;
       SFGenConfigAssignedReaderIDModifyCheckBox->Font->Color = clRed;
    }
    else
    {
       SFGenConfigAssignedReaderIDEdit->ReadOnly = true;
       SFGenConfigAssignedReaderIDEdit->Color = clMenu;
       //SFGenConfigAssignedReaderIDEdit->Font->Color = clGray;
       SFGenConfigAssignedReaderIDModifyCheckBox->Font->Color = clOlive;
       //FGenConfigReaderIDEdit->Text = "";
    }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::SFGenConfigFGenIDModifyCheckBoxClick(
      TObject *Sender)
{
   if (SFGenConfigFGenIDModifyCheckBox->Checked)
    {
       SFGenConfigFGenIDEdit->ReadOnly = false;
       SFGenConfigFGenIDEdit->Color = clWhite;
       SFGenConfigFGenIDEdit->Font->Color = clBlue;
       SFGenConfigFGenIDModifyCheckBox->Font->Color = clRed;
    }
    else
    {
       SFGenConfigFGenIDEdit->ReadOnly = true;
       SFGenConfigFGenIDEdit->Color = clMenu;
       //SFGenConfigFGenIDEdit->Font->Color = clGray;
       SFGenConfigFGenIDModifyCheckBox->Font->Color = clOlive;
    }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::SFGenConfigTagTypeModifyCheckBoxClick(
      TObject *Sender)
{
   if (SFGenConfigTagTypeModifyCheckBox->Checked)
    {
       //FGenConfigAccessRadioButton->Enabled = true;
       //FGenConfigAssetRadioButton->Enabled = true;
       //FGenConfigInventoryRadioButton->Enabled = true;
       //FGenConfigAnyTypeRadioButton->Enabled = true;
       //FGenConfigRaRnModifyCheckBox->Checked = true;
       SFGenConfigTagTypeModifyCheckBox->Font->Color = clRed;
    }
    else
    {
       //FGenConfigAccessRadioButton->Enabled = false;
       //FGenConfigAssetRadioButton->Enabled = false;
       //FGenConfigInventoryRadioButton->Enabled = false;
       //FGenConfigAnyTypeRadioButton->Enabled = false;
       //FGenConfigRaRnModifyCheckBox->Checked = false;
       SFGenConfigTagTypeModifyCheckBox->Font->Color = clOlive;
    }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::SFGenConfigTagIDModifyCheckBoxClick(
      TObject *Sender)
{
   if (SFGenConfigTagIDModifyCheckBox->Checked)
    {
       //FGenConfigTagIDRadioButton->Enabled = true;
       //FGenConfigAnyTagIDRadioButton->Enabled = true;
       if (SFGenConfigTagIDRadioButton->Checked)
       {
          SFGenConfigTagIDEdit->ReadOnly = false;
          SFGenConfigTagIDEdit->Color = clWhite;
          SFGenConfigTagIDEdit->Font->Color = clBlue;
          SFGenConfigTagIDModifyCheckBox->Font->Color = clRed;
       }
       else
       {
          SFGenConfigTagIDEdit->ReadOnly = true;
          SFGenConfigTagIDEdit->Color = clMenu;
          //SFGenConfigTagIDEdit->Font->Color = clGray;
          SFGenConfigTagIDModifyCheckBox->Font->Color = clOlive;
       }
    }
    else
    {
       //FGenConfigTagIDRadioButton->Enabled = false;
       //FGenConfigAnyTagIDRadioButton->Enabled = false;

       SFGenConfigTagIDEdit->ReadOnly = true;
       SFGenConfigTagIDEdit->Color = clMenu;
       SFGenConfigTagIDEdit->Font->Color = clGray;
       SFGenConfigTagIDEdit->Text = "";
    }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::SFGenConfigRaRnModifyCheckBoxClick(
      TObject *Sender)
{
   if (SFGenConfigRaRnModifyCheckBox->Checked)
   {
      //FGenConfigRNShortRadioButton->Enabled = true;
      //FGenConfigRALongRadioButton->Enabled = true;
      SFGenConfigTagTypeModifyCheckBox->Checked = true;
      SFGenConfigRaRnModifyCheckBox->Font->Color = clRed;
   }
   else
   {
      //FGenConfigRNShortRadioButton->Enabled = false;
      //FGenConfigRALongRadioButton->Enabled = false;
      SFGenConfigRaRnModifyCheckBox->Font->Color = clOlive;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::SFGenConfigTxTimeModifyCheckBoxClick(
      TObject *Sender)
{
   if (SFGenConfigTxTimeModifyCheckBox->Checked)
    {
       //FGenConfigDefaultTimeCheckBox->Checked = false;
       //FGenConfigActivePIRCheckBox->Enabled = true;
       //FGenConfigMonitorPIRCheckBox->Enabled = true;
       SFGenConfigTxTimeComboBox->Enabled = true;
       SFGenConfigTxTimeComboBox->Color = clWhite;
       SFGenConfigMDCheckBox->Checked = true;
       SFGenConfigTxTimeModifyCheckBox->Font->Color = clRed;
    }
    else
    {
       //FGenConfigActivePIRCheckBox->Enabled = false;
       //FGenConfigTxTimeComboBox->Enabled = false;
       //FGenConfigMonitorPIRCheckBox->Enabled = false;
       SFGenConfigTxTimeModifyCheckBox->Font->Color = clOlive;
       //SFGenConfigTxTimeComboBox->Text = "";
       SFGenConfigTxTimeComboBox->Color = clMenu;
       SFGenConfigMDCheckBox->Checked = false;
    }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::SFGenConfigWaitTimeModifyCheckBoxClick(
      TObject *Sender)
{
   if (SFGenConfigWaitTimeModifyCheckBox->Checked)
    {
       //FGenConfigDefaultTimeCheckBox->Checked = false;
       //FGenConfigWaitTimeSecRadioButton->Enabled = true;
       //FGenConfigWaitTimeMinRadioButton->Enabled = true;
       //FGenConfigWaitTimeHourRadioButton->Enabled = true;
       //FGenConfigWaitTimeAllRadioButton->Enabled = true;
       SFGenConfigWaitTimeComboBox->Enabled = true;
       SFGenConfigWaitTimeComboBox->Color = clWhite;
       SFGenConfigWaitTimeModifyCheckBox->Font->Color = clRed;

       SFGenConfigWaitTimeComboBox->Items->Clear();
       if (SFGenConfigWaitTimeSecRadioButton->Checked ||
           SFGenConfigWaitTimeMinRadioButton->Checked)
       {
           for (int i=0; i<=60; i++)
             SFGenConfigWaitTimeComboBox->Items->Add(i);
       }
       else
       {
          for (int i=0; i<=24; i++)
            SFGenConfigWaitTimeComboBox->Items->Add(i);
       }

       //SFGenConfigWaitTimeComboBox->Text = "";
    }
    else
    {
       //FGenConfigWaitTimeSecRadioButton->Enabled = false;
       //FGenConfigWaitTimeMinRadioButton->Enabled = false;
       //FGenConfigWaitTimeHourRadioButton->Enabled = false;
       //FGenConfigWaitTimeAllRadioButton->Enabled = false;
       SFGenConfigWaitTimeComboBox->Enabled = false;
       //SFGenConfigTxTimeComboBox->Text = "";
       SFGenConfigWaitTimeComboBox->Color = clMenu;
       SFGenConfigWaitTimeModifyCheckBox->Font->Color = clOlive;
    }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::SFGenConfigMDCheckBoxClick(
      TObject *Sender)
{
   if (SFGenConfigMDCheckBox->Checked)
   {
      //FGenConfigMDEnableCheckBox->Enabled = true;
      //FGenConfigMDActiveHiRadioButton->Enabled = true;
      //FGenConfigMDActiveLoRadioButton->Enabled = true;
      SFGenConfigTxTimeModifyCheckBox->Checked = true;
      SFGenConfigMDCheckBox->Font->Color = clRed;
   }
   else
   {
      //FGenConfigMDEnableCheckBox->Enabled = false;
      //FGenConfigMDActiveHiRadioButton->Enabled = false;
      //FGenConfigMDActiveLoRadioButton->Enabled = false;
      SFGenConfigMDCheckBox->Font->Color = clOlive;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigSFGenUpdateBitBtnClick(
      TObject *Sender)
{
   mouseClicked = false;

   if(networkOn)
   {
         /*int rdr = atoi(FGenConfigSmartFGenReaderIDComboBox->Text.c_str());
         int index = GetIpAddressIndex(rdr);
         if (index >= 0)
         {
            //EnableAllCommands(false);
            WriteTCPIPComm(QUERY_SMART_FIELD_GEN, 0, NULL, 0, networkInfo[index].activeSock, networkInfo[index].peerSock, index);
         }*/

       int rdr = atoi(FGenConfigSmartFGenReaderIDComboBox->Text.c_str());
       int index = GetSocketIndex(rdr);
       if (index >= 0)
       {
          WriteAWSocket(QUERY_SMART_FIELD_GEN, 0, NULL, index, 'S', NULL, 0, index);
       }
       else
          StaticText->Caption = "No matching socket for the reader.";
      }
      else if (RS232On)
      {
          //EnableAllCommands(false);
          WriteRS232Comm(QUERY_SMART_FIELD_GEN, 0, NULL, 0);
      }


   //FGenConfigReaderIDEdit->Text = "";
   SFGenConfigFGenIDEdit->Text = "";

   SFGenConfigRNShortRadioButton->Checked = false;
   SFGenConfigRALongRadioButton->Checked = false;

   //SFGenConfigAccessRadioButton->Checked = false;
   //SFGenConfigAssetRadioButton->Checked = false;
   //SFGenConfigInventoryRadioButton->Checked = false;
   //SFGenConfigAnyTypeRadioButton->Checked = false;

   SFGenConfigTagIDEdit->Text = "";
   SFGenConfigTagIDRadioButton->Checked = false;
   SFGenConfigAnyTagIDRadioButton->Checked = false;

   SFGenConfigTxTimeComboBox->Text = "";
   //FGenConfigActivePIRCheckBox->Checked = false;

   SFGenConfigWaitTimeComboBox->Text = "";
   SFGenConfigWaitTimeSecRadioButton->Checked = false;
   SFGenConfigWaitTimeMinRadioButton->Checked = false;
   SFGenConfigWaitTimeHourRadioButton->Checked = false;
   //FGenConfigWaitTimeAllRadioButton->Checked = false;

   SFGenConfigAssignedReaderIDEdit->Text = "";

   FGenConfigPotentiComboBox->Text = "";

   SFGenConfigFGenIDModifyCheckBox->Checked = false;
   SFGenConfigRaRnModifyCheckBox->Checked = false;
   SFGenConfigTagIDModifyCheckBox->Checked = false;
   SFGenConfigTagTypeModifyCheckBox->Checked = false;
   SFGenConfigTxTimeModifyCheckBox->Checked = false;
   SFGenConfigWaitTimeModifyCheckBox->Checked = false;
   FGenConfigPotentiModifyCheckBox->Checked = false;
   SFGenConfigAssignedReaderIDModifyCheckBox->Checked = false;
   SFGenConfigMDCheckBox->Checked = false;

   SFGenConfigMDEnableCheckBox->Checked = false;
   SFGenConfigMDActiveHiRadioButton->Checked = false;
   SFGenConfigMDActiveLoRadioButton->Checked = false;

}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ResetCMDReaderBitBtnClick(
      TObject *Sender)
{
                                                  //READER
                                                 //=============
   ResetReaderStaticText->Enabled = true;        //Reset Reader
   ResetDeviceBitBtn->Enabled = true;

   EnableReaderStaticText->Enabled = true;       //Enable Reader
   EnableReaderBitBtn->Enabled = true;

   DisableReaderStaticText->Enabled = true;      //Disable Reader
   DisableReaderBitBtn->Enabled = true;

   QueryReaderStaticText->Enabled = true;        //Query Reader
   QueryReaderBitBtn->Enabled = true;

   AssignReaderStaticText->Enabled = true;       //Config Reader
   AssignReaderBitBtn->Enabled = true;

   ReaderVersionStaticText->Enabled = true;      //Get Version Reader
   ReaderVersion->Enabled = true;

   //EnableRdrFGenStaticText->Enabled = true;      //Enable Transmitter
   EnableFGenBitBtn->Enabled = true;

   RelayStaticText->Enabled = true;              //Output Realay
   RelayBitBtn->Enabled = true;

   InputsStaticText->Enabled = true;             //Input Status
   InputsBitBtn->Enabled = true;

   SetFStrengthStaticText->Enabled = true;       //Set Field Strength
   SetFStrengthBitBtn->Enabled = true;

   //DownloadRdrStaticText->Enabled = true;        //Download
   DownloadRdrBitBtn->Enabled = true;

                                                 //STD FIELD GEN
                                                 //===============
   QueryFGenStaticText->Enabled = true;          //Query
   QueryFGenBitBtn->Enabled = true;

   ConfigFGenStaticText->Enabled = true;         //Configure
   ConfigFGenBitBtn->Enabled = true;

                                                 //SMART FIELD GEN
                                                 //================
   FGenResetStaticText->Enabled = true;          //Reset
   FGenResetBitBtn->Enabled = true;

   QuerySFGenStaticText->Enabled = true;         //Query
   QuerySFGenBitBtn->Enabled = true;

   ConfigSFGenStaticText->Enabled = true;        //Configure
   ConfigSFGenBitBtn->Enabled = true;

   SmartFGenStaticText->Enabled = true;          //Call
   SmartFGenBitBtn->Enabled = true;

   ////DownloadSmartFGenStaticText->Enabled = true;  //Download
   DownloadSFGenBitBtn->Enabled = true;

                                                //TAG
                                                //================
   EnableTagStaticText->Enabled = true;         //Enable
   EnableTagBitBtn->Enabled = true;

   DisableTagStaticText->Enabled = true;        //Disable
   DisableTagBitBtn->Enabled = true;

   ConfigTagStaticText->Enabled = true;         //Config
   ConfigTagBitBtn->Enabled = true;

   QueryTagStaticText->Enabled = true;          //Query
   QueryTagBitBtn->Enabled = true;

   CallTagStaticText->Enabled = true;           //Cal
   CallTagBitBtn->Enabled = true;

   AssignTagRdrStaticText->Enabled = true;      //Assign reader
   AssignTagRdrBitBtn->Enabled = true;

   ConfigTagRNDStaticText->Enabled = true;      //Config RND
   ConfigTagRNDBitBtn->Enabled = true;

   ReadMemoryStaticText->Enabled = true;        //Read Memory
   ReadMemoryBitBtn->Enabled = true;

   WriteMemoryStaticText->Enabled = true;       //Write Memory
   WriteMemoryBitBtn->Enabled = true;

   TagTempStaticText->Enabled = true;           //Config Temp
   TagTempBitBtn->Enabled = true;
   TagTempReadTempValueBitBtn->Enabled = true;  //get Config Temp button
   TagTempRefreshBitBtn->Enabled = true;        //Refresh temp button
   TagTempBitBtn->Enabled = true;               //Get temp button

   ConfigTagLEDStaticText->Enabled = true;      //Tag LED
   ConfigTagLEDBitBtn->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::CMDEnableTimerTimer(TObject *Sender)
{
   CMDEnableTimer->Enabled = false;
                                                 //READER
                                                 //=============
   ResetReaderStaticText->Enabled = true;        //Reset Reader
   ResetDeviceBitBtn->Enabled = true;

   EnableReaderStaticText->Enabled = true;       //Enable Reader
   EnableReaderBitBtn->Enabled = true;

   DisableReaderStaticText->Enabled = true;      //Disable Reader
   DisableReaderBitBtn->Enabled = true;

   QueryReaderStaticText->Enabled = true;        //Query Reader
   QueryReaderBitBtn->Enabled = true;

   AssignReaderStaticText->Enabled = true;       //Config Reader
   AssignReaderBitBtn->Enabled = true;

   ReaderVersionStaticText->Enabled = true;      //Get Version Reader
   ReaderVersion->Enabled = true;

   //EnableRdrFGenStaticText->Enabled = true;      //Enable Transmitter
   //EnableFGenBitBtn->Enabled = true;

   RelayStaticText->Enabled = true;              //Output Realay
   RelayBitBtn->Enabled = true;

   InputsStaticText->Enabled = true;             //Input Status
   InputsBitBtn->Enabled = true;

   SetFStrengthStaticText->Enabled = true;       //Set Field Strength
   SetFStrengthBitBtn->Enabled = true;

   //DownloadRdrStaticText->Enabled = true;        //Download
   DownloadRdrBitBtn->Enabled = true;

                                                 //STD FIELD GEN
                                                 //===============
   QueryFGenStaticText->Enabled = true;          //Query
   QueryFGenBitBtn->Enabled = true;

   ConfigFGenStaticText->Enabled = true;         //Configure
   ConfigFGenBitBtn->Enabled = true;

                                                 //SMART FIELD GEN
                                                 //================
   FGenResetStaticText->Enabled = true;          //Reset
   FGenResetBitBtn->Enabled = true;

   QuerySFGenStaticText->Enabled = true;         //Query
   QuerySFGenBitBtn->Enabled = true;

   ConfigSFGenStaticText->Enabled = true;        //Configure
   ConfigSFGenBitBtn->Enabled = true;

   SmartFGenStaticText->Enabled = true;          //Call
   SmartFGenBitBtn->Enabled = true;

   ////DownloadSmartFGenStaticText->Enabled = true;  //Download
   DownloadSFGenBitBtn->Enabled = true;

                                                //TAG
                                                //================
   EnableTagStaticText->Enabled = true;         //Enable
   EnableTagBitBtn->Enabled = true;

   DisableTagStaticText->Enabled = true;        //Disable
   DisableTagBitBtn->Enabled = true;

   ConfigTagStaticText->Enabled = true;         //Config
   ConfigTagBitBtn->Enabled = true;

   QueryTagStaticText->Enabled = true;          //Query
   QueryTagBitBtn->Enabled = true;

   CallTagStaticText->Enabled = true;           //Cal
   CallTagBitBtn->Enabled = true;

   AssignTagRdrStaticText->Enabled = true;      //Assign reader
   AssignTagRdrBitBtn->Enabled = true;

   ConfigTagRNDStaticText->Enabled = true;      //Config RND
   ConfigTagRNDBitBtn->Enabled = true;

   ReadMemoryStaticText->Enabled = true;        //Read Memory
   ReadMemoryBitBtn->Enabled = true;

   WriteMemoryStaticText->Enabled = true;       //Write Memory
   WriteMemoryBitBtn->Enabled = true;

   TagTempStaticText->Enabled = true;           //Config Temp
   TagTempBitBtn->Enabled = true;
   TagTempReadTempValueBitBtn->Enabled = true;  //get Config Temp button
   TagTempRefreshBitBtn->Enabled = true;        //Refresh temp button
   TagTempBitBtn->Enabled = true;               //Get temp button

   ConfigTagLEDStaticText->Enabled = true;      //Tag LED
   ConfigTagLEDBitBtn->Enabled = true;

}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::EnableAllBitbtnCommands()
{
                                                  //READER
                                                 //=============
   //ResetReaderStaticText->Enabled = true;        //Reset Reader
   ResetDeviceBitBtn->Enabled = true;

   //EnableReaderStaticText->Enabled = true;       //Enable Reader
   EnableReaderBitBtn->Enabled = true;

   //DisableReaderStaticText->Enabled = true;      //Disable Reader
   DisableReaderBitBtn->Enabled = true;

   //QueryReaderStaticText->Enabled = true;        //Query Reader
   QueryReaderBitBtn->Enabled = true;

   //AssignReaderStaticText->Enabled = true;       //Config Reader
   AssignReaderBitBtn->Enabled = true;

   //ReaderVersionStaticText->Enabled = true;      //Get Version Reader
   ReaderVersion->Enabled = true;

   //EnableRdrFGenStaticText->Enabled = true;      //Enable Transmitter
   //EnableFGenBitBtn->Enabled = true;

   //RelayStaticText->Enabled = true;              //Output Realay
   RelayBitBtn->Enabled = true;

   //InputsStaticText->Enabled = true;             //Input Status
   InputsBitBtn->Enabled = true;

   //SetFStrengthStaticText->Enabled = true;       //Set Field Strength
   SetFStrengthBitBtn->Enabled = true;

   //DownloadRdrStaticText->Enabled = true;        //Download
   DownloadRdrBitBtn->Enabled = true;

                                                 //STD FIELD GEN
                                                 //===============
   //QueryFGenStaticText->Enabled = true;          //Query
   QueryFGenBitBtn->Enabled = true;

   //ConfigFGenStaticText->Enabled = true;         //Configure
   ConfigFGenBitBtn->Enabled = true;

                                                 //SMART FIELD GEN
                                                 //================
   //FGenResetStaticText->Enabled = true;          //Reset
   FGenResetBitBtn->Enabled = true;

   //QuerySFGenStaticText->Enabled = true;         //Query
   QuerySFGenBitBtn->Enabled = true;

   //ConfigSFGenStaticText->Enabled = true;        //Configure
   ConfigSFGenBitBtn->Enabled = true;

   //SmartFGenStaticText->Enabled = true;          //Call
   SmartFGenBitBtn->Enabled = true;

   //DownloadSmartFGenStaticText->Enabled = true;  //Download    //no change
   DownloadSFGenBitBtn->Enabled = true;

                                                //TAG
                                                //================
   //EnableTagStaticText->Enabled = true;         //Enable
   EnableTagBitBtn->Enabled = true;

   //DisableTagStaticText->Enabled = true;        //Disable
   DisableTagBitBtn->Enabled = true;

   //ConfigTagStaticText->Enabled = true;         //Config
   ConfigTagBitBtn->Enabled = true;

   //QueryTagStaticText->Enabled = true;          //Query
   QueryTagBitBtn->Enabled = true;

   //CallTagStaticText->Enabled = true;           //Cal
   CallTagBitBtn->Enabled = true;

   //AssignTagRdrStaticText->Enabled = true;      //Assign reader
   AssignTagRdrBitBtn->Enabled = true;

   //ConfigTagRNDStaticText->Enabled = true;      //Config RND
   ConfigTagRNDBitBtn->Enabled = true;

   //ReadMemoryStaticText->Enabled = true;        //Read Memory
   ReadMemoryBitBtn->Enabled = true;

   //WriteMemoryStaticText->Enabled = true;       //Write Memory
   WriteMemoryBitBtn->Enabled = true;

   //TagTempStaticText->Enabled = true;           //Config Temp
   TagTempBitBtn->Enabled = true;
   TagTempReadTempValueBitBtn->Enabled = true;  //get Config Temp button
   TagTempRefreshBitBtn->Enabled = true;        //Refresh temp button
   TagTempBitBtn->Enabled = true;               //Get temp button

   //ConfigTagLEDStaticText->Enabled = true;      //Tag LED
   ConfigTagLEDBitBtn->Enabled = true;
}

void __fastcall TProgStationForm::ResetCMDFGenBitBtnClick(TObject *Sender)
{
   ResetReaderStaticText->Enabled = true;
   EnableReaderStaticText->Enabled = true;
   DisableReaderStaticText->Enabled = true;
   QueryReaderStaticText->Enabled = true;
   AssignReaderStaticText->Enabled = true;
   ReaderVersionStaticText->Enabled = true;
   //EnableRdrFGenStaticText->Enabled = true;
   //ConfigTxTimeStaticText->Enabled = true;
   RelayStaticText->Enabled = true;
   InputsStaticText->Enabled = true;
   ConfigFGenStaticText->Enabled = true;
   QueryFGenStaticText->Enabled = true;
   FGenResetStaticText->Enabled = true;
   SmartFGenStaticText->Enabled = true;
   QuerySFGenStaticText->Enabled = true;
   ConfigSFGenStaticText->Enabled = true;
   //EnableFGenStaticText->Enabled = true;
   ConfigTagStaticText->Enabled = true;
   EnableTagStaticText->Enabled = true;
   DisableTagStaticText->Enabled = true;
   QueryTagStaticText->Enabled = true;
   CallTagStaticText->Enabled = true;
   AssignTagRdrStaticText->Enabled = true;
   ConfigTagRNDStaticText->Enabled = true;
   ReadMemoryStaticText->Enabled = true;
   WriteMemoryStaticText->Enabled = true;
   EnableTagStaticText->Enabled = true;
   TagTempReadTempValueBitBtn->Enabled = true;
   TagTempRefreshBitBtn->Enabled = true;
   TagTempBitBtn->Enabled = true;
   TagTempStaticText->Enabled = true;

   GetProcRevDateBitBtn->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ResetCMDSFGenBitBtnClick(TObject *Sender)
{
                                                  //READER
                                                 //=============
   ResetReaderStaticText->Enabled = true;        //Reset Reader
   ResetDeviceBitBtn->Enabled = true;

   EnableReaderStaticText->Enabled = true;       //Enable Reader
   EnableReaderBitBtn->Enabled = true;

   DisableReaderStaticText->Enabled = true;      //Disable Reader
   DisableReaderBitBtn->Enabled = true;

   QueryReaderStaticText->Enabled = true;        //Query Reader
   QueryReaderBitBtn->Enabled = true;

   AssignReaderStaticText->Enabled = true;       //Config Reader
   AssignReaderBitBtn->Enabled = true;

   ReaderVersionStaticText->Enabled = true;      //Get Version Reader
   ReaderVersion->Enabled = true;

   //EnableRdrFGenStaticText->Enabled = true;      //Enable Transmitter
   //EnableFGenBitBtn->Enabled = true;

   RelayStaticText->Enabled = true;              //Output Realay
   RelayBitBtn->Enabled = true;

   InputsStaticText->Enabled = true;             //Input Status
   InputsBitBtn->Enabled = true;

   SetFStrengthStaticText->Enabled = true;       //Set Field Strength
   SetFStrengthBitBtn->Enabled = true;

   //DownloadRdrStaticText->Enabled = true;        //Download
   DownloadRdrBitBtn->Enabled = true;

                                                 //STD FIELD GEN
                                                 //===============
   QueryFGenStaticText->Enabled = true;          //Query
   QueryFGenBitBtn->Enabled = true;

   ConfigFGenStaticText->Enabled = true;         //Configure
   ConfigFGenBitBtn->Enabled = true;

                                                 //SMART FIELD GEN
                                                 //================
   FGenResetStaticText->Enabled = true;          //Reset
   FGenResetBitBtn->Enabled = true;

   QuerySFGenStaticText->Enabled = true;         //Query
   QuerySFGenBitBtn->Enabled = true;

   ConfigSFGenStaticText->Enabled = true;        //Configure
   ConfigSFGenBitBtn->Enabled = true;

   SmartFGenStaticText->Enabled = true;          //Call
   SmartFGenBitBtn->Enabled = true;

   ////DownloadSmartFGenStaticText->Enabled = true;  //Download
   DownloadSFGenBitBtn->Enabled = true;

                                                //TAG
                                                //================
   EnableTagStaticText->Enabled = true;         //Enable
   EnableTagBitBtn->Enabled = true;

   DisableTagStaticText->Enabled = true;        //Disable
   DisableTagBitBtn->Enabled = true;

   ConfigTagStaticText->Enabled = true;         //Config
   ConfigTagBitBtn->Enabled = true;

   QueryTagStaticText->Enabled = true;          //Query
   QueryTagBitBtn->Enabled = true;

   CallTagStaticText->Enabled = true;           //Cal
   CallTagBitBtn->Enabled = true;

   AssignTagRdrStaticText->Enabled = true;      //Assign reader
   AssignTagRdrBitBtn->Enabled = true;

   ConfigTagRNDStaticText->Enabled = true;      //Config RND
   ConfigTagRNDBitBtn->Enabled = true;

   ReadMemoryStaticText->Enabled = true;        //Read Memory
   ReadMemoryBitBtn->Enabled = true;

   WriteMemoryStaticText->Enabled = true;       //Write Memory
   WriteMemoryBitBtn->Enabled = true;

   TagTempStaticText->Enabled = true;           //Config Temp
   TagTempBitBtn->Enabled = true;
   TagTempReadTempValueBitBtn->Enabled = true;  //get Config Temp button
   TagTempRefreshBitBtn->Enabled = true;        //Refresh temp button
   TagTempBitBtn->Enabled = true;               //Get temp button

   ConfigTagLEDStaticText->Enabled = true;      //Tag LED
   ConfigTagLEDBitBtn->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ResetCMDTagBitBtnClick(TObject *Sender)
{
   ResetReaderStaticText->Enabled = true;
   EnableReaderStaticText->Enabled = true;
   DisableReaderStaticText->Enabled = true;
   QueryReaderStaticText->Enabled = true;
   AssignReaderStaticText->Enabled = true;
   ReaderVersionStaticText->Enabled = true;
   //EnableRdrFGenStaticText->Enabled = true;
   //ConfigTxTimeStaticText->Enabled = true;
   RelayStaticText->Enabled = true;
   InputsStaticText->Enabled = true;
   ConfigFGenStaticText->Enabled = true;
   QueryFGenStaticText->Enabled = true;
   FGenResetStaticText->Enabled = true;
   SmartFGenStaticText->Enabled = true;
   QuerySFGenStaticText->Enabled = true;
   ConfigSFGenStaticText->Enabled = true;
   //EnableFGenStaticText->Enabled = true;
   ConfigTagStaticText->Enabled = true;
   EnableTagStaticText->Enabled = true;
   DisableTagStaticText->Enabled = true;
   QueryTagStaticText->Enabled = true;
   CallTagStaticText->Enabled = true;
   AssignTagRdrStaticText->Enabled = true;
   ConfigTagRNDStaticText->Enabled = true;
   ReadMemoryStaticText->Enabled = true;
   WriteMemoryStaticText->Enabled = true;
   EnableTagStaticText->Enabled = true;
   TagTempReadTempValueBitBtn->Enabled = true;
   TagTempRefreshBitBtn->Enabled = true;
   TagTempBitBtn->Enabled = true;
   TagTempStaticText->Enabled = true;

   GetProcRevDateBitBtn->Enabled = true;
}
//------------------------------------------------------------------------------

void __fastcall TProgStationForm::TagTempListViewDblClick(TObject *Sender)
{
   TListItem* item = TagTempListView->Selected;
   TStrings* str;
   AnsiString selectedTypeStr;
   unsigned short selectedTypeInt;
   int index;
   int p;

   if (item)
   {
      str = item->SubItems;
      AnsiString s = str->Text;
      selectedType = GetItem(str, 6);  //s.SubString(1,3);
      selectedId = GetItem(str, 1);   //s.SubString(6, s.Length()-7);

      if ((index=GetIndexTagTypeAbr(selectedType)) < 0)
         return;

      //ConfigTagTypeComboBox->ItemIndex = index+1;

      /*if (selectedType == "ACC")
      {
         selectedTypeStr = "Access";
         selectedTypeInt = 1;
      }
      else if (selectedType == "AST")
      {
         selectedTypeStr = "Asset";
         selectedTypeInt = 3;
      }
      else if (selectedType == "INV")
      {
         selectedTypeStr = "Inventory";
         selectedTypeInt = 2;
      }
      else
      {
         selectedTypeStr = "";
         selectedTypeInt = 0;
      } */

      if (selectedType == "ACC")
         AccessCtrlRadioButton->Checked = true;
      else if (selectedType == "AST")
         AssetCtrlRadioButton->Checked = true;
      else if (selectedType == "INV")
         InvetRadioButton->Checked = true;

      if (TagTempGroupBox->Visible)
      {
         if ((p=GetTagTypeComboBoxIndex(selectedType)) >= 0)
             TagTempTagTypeComboBox->ItemIndex = p;

         /*if (selectedType == "ACC")
            TagTempAccRadioButton->Checked = true;
         else if (selectedType == "AST")
            TagTempAssRadioButton->Checked = true;
         else if (selectedType == "INV")
            TagTempInvRadioButton->Checked = true;
         else
            TagTempAnyTagTypeRadioButton->Checked = true;*/

         TagTempTagIDRadioButton->Checked = true;
         TagTempTagIDEdit->Text = selectedId;
      }
   }//item
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::QuerySFGenClearRevListBitBtnClick(
      TObject *Sender)
{
   QuerySFGenProcListView->Items->Clear();
}
//------------------------------------------------------------------------------

void __fastcall TProgStationForm::QuerySFGenSmartFGenBroadcastCheckBoxClick(
      TObject *Sender)
{
   if (QuerySFGenSmartFGenBroadcastCheckBox->Checked)
   {
     QueryFGenSmartFGenIDComboBox->Enabled = false;
     QueryFGenSmartFGenIDComboBox->Color = clMenu;
     QuerySFGenSpecificRdrRadioButton->Enabled = true;
     QuerySFGenAnyRdrRadioButton->Enabled = true;
   }
   else
   {
     QueryFGenSmartFGenIDComboBox->Enabled = true;
     QueryFGenSmartFGenIDComboBox->Color = clWhite;
     QuerySFGenSpecificRdrRadioButton->Enabled = false;
     QuerySFGenAnyRdrRadioButton->Enabled = false;
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::FGenConfigWaitTimeComboBoxClick(
      TObject *Sender)
{
    /*FGenConfigWaitTimeComboBox->Items->Clear();
    if (FGenConfigWaitTimeSecRadioButton->Checked ||
        FGenConfigWaitTimeMinRadioButton->Checked)
    {
      for (int i=1; i<=60; i++)
         FGenConfigWaitTimeComboBox->Items->Add(i);
    }
    else
    {
       for (int i=1; i<=24; i++)
         FGenConfigWaitTimeComboBox->Items->Add(i);
    }

    FGenConfigWaitTimeComboBox->Text = "";*/
}
//---------------------------------------------------------------------------



void __fastcall TProgStationForm::SFGenConfigWaitTimeSecRadioButtonClick(
      TObject *Sender)
{
   if (SFGenConfigWaitTimeSecClicked)
   {
      SFGenConfigWaitTimeSecClicked = false;
      SFGenConfigWaitTimeComboBox->Items->Clear();
      for (int i=0; i<=60; i++)
         SFGenConfigWaitTimeComboBox->Items->Add(i);
      SFGenConfigWaitTimeComboBox->Text = "";
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::SFGenConfigWaitTimeMinRadioButtonClick(
      TObject *Sender)
{
   if (SFGenConfigWaitTimeMinClicked)
   {
      SFGenConfigWaitTimeMinClicked = false;
      SFGenConfigWaitTimeComboBox->Items->Clear();
      for (int i=0; i<=60; i++)
         SFGenConfigWaitTimeComboBox->Items->Add(i);
      SFGenConfigWaitTimeComboBox->Text = "";
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::SFGenConfigWaitTimeHourRadioButtonClick(
      TObject *Sender)
{
   if (SFGenConfigWaitTimeHourClicked)
   {
      SFGenConfigWaitTimeHourClicked = false;
      SFGenConfigWaitTimeComboBox->Items->Clear();
      for (int i=0; i<=24; i++)
         SFGenConfigWaitTimeComboBox->Items->Add(i);
      SFGenConfigWaitTimeComboBox->Text = "";
   }
}
//---------------------------------------------------------------------------


void __fastcall TProgStationForm::SFGenConfigWaitTimeSecRadioButtonMouseDown(
      TObject *Sender, TMouseButton Button, TShiftState Shift, int X,
      int Y)
{
   SFGenConfigWaitTimeSecClicked = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::SFGenConfigWaitTimeMinRadioButtonMouseDown(
      TObject *Sender, TMouseButton Button, TShiftState Shift, int X,
      int Y)
{
    SFGenConfigWaitTimeMinClicked = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::SFGenConfigWaitTimeHourRadioButtonMouseDown(
      TObject *Sender, TMouseButton Button, TShiftState Shift, int X,
      int Y)
{
   SFGenConfigWaitTimeHourClicked = true;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::QuerySFGenClearBitBtnClick(
      TObject *Sender)
{
    QuerySFGenListView->Items->Clear();
    numSFgenIDList = 0;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::SetFStrengthStaticTextClick(
      TObject *Sender)
{
    if (!SetFStrengthGroupBox->Visible)
    {
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = true;
      DownloadRdrStaticText->Visible = true;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      //InputsGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = false;
   //ConfigTxTimeStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = true;
   DownloadRdrBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   FGenResetBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   DownloadRdrBitBtn->Font->Color = clNavy;
   SetFStrengthBitBtn->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clNavy;
   InputsBitBtn->Font->Color = clNavy;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   //if (lastHostID <= 0)
      //EnableFGenHostIDEdit->Text = "";
   //else
      //EnableFGenHostIDEdit->Text = lastHostID;
   if (allHostID)
   {
      if (lastHostID > 0)
         ReaderFStrengthHostEdit->Text = lastHostID;
   }
   else
      ReaderFStrengthHostEdit->Text = sysHostID;

   ReaderFStrengthReaderComboBox->Items->Clear();
   for (unsigned int i=0; i<numReaderIDList; i++)
      ReaderFStrengthReaderComboBox->Items->Add(readerIDList[i]);

   if (lastReaderID <= 0)
      ReaderFStrengthReaderComboBox->Text = "";
   else
      ReaderFStrengthReaderComboBox->Text = lastReaderID;

   TxClearTagCtrls();
   RxClearTagCtrls();

   if(networkOn)
   {
      int rdr = atoi(AssignReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(GET_READER_CONFIG, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(GET_READER_CONFIG, 0, NULL, 0);
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ReaderINCDECTxFieldCheckBoxClick(
      TObject *Sender)
{
   if ((ReaderINCDECTxFieldCheckBox->State == cbChecked) && clicked)
   {
      if (ReaderSetABSTxFieldCheckBox->Checked)
        ReaderSetABSTxFieldCheckBox->Checked = false;
      ReaderModifyTXFComboBox->Color = clMenu;
      ReaderModifyTXFComboBox->Enabled = false;

      //ReaderFStrengthEdit->Color = clWhite;
      //ReaderFStrengthEdit->ReadOnly = false;
      //ReaderFStrengthEdit->Enabled = true;
      //ReaderFStrengthUpDown->Enabled = true;
      //ReaderFStrengthUpDown->Update();

      SetFStrengthBitBtn->Enabled = false;
      ReaderShortRangeRadioButton->Enabled = false;
      ReaderLongRangeRadioButton->Enabled = false;

      ReaderIncreaseTXBitBtn->Enabled = true;
      ReaderDecreaseTXBitBtn->Enabled = true;
   }
   else
   {
      //ReaderFStrengthEdit->Color = clMenu;
      //ReaderFStrengthEdit->ReadOnly = true;
      //ReaderFStrengthEdit->Enabled = false;

      SetFStrengthBitBtn->Enabled = true;
      ReaderShortRangeRadioButton->Enabled = true;
      ReaderLongRangeRadioButton->Enabled = true;

      ReaderIncreaseTXBitBtn->Enabled = false;
      ReaderDecreaseTXBitBtn->Enabled = false;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ReaderSetABSTxFieldCheckBoxClick(
      TObject *Sender)
{
   if ((ReaderSetABSTxFieldCheckBox->State == cbChecked) && mouseClicked)
   {
      if (ReaderINCDECTxFieldCheckBox->Checked)
         ReaderINCDECTxFieldCheckBox->Checked = false;
      ReaderModifyTXFComboBox->Color = clWhite;
      ReaderModifyTXFComboBox->Enabled = true;

      //ReaderFStrengthEdit->Color = clMenu;
      //ReaderFStrengthEdit->ReadOnly = true;
      //ReaderFStrengthEdit->Enabled = false;

      SetFStrengthBitBtn->Enabled = true;
      ReaderLongRangeRadioButton->Enabled = true;
      ReaderShortRangeRadioButton->Enabled = true;

      ReaderIncreaseTXBitBtn->Enabled = false;
      ReaderDecreaseTXBitBtn->Enabled = false;
   }
   else
   {
      ReaderModifyTXFComboBox->Color = clMenu;
      ReaderModifyTXFComboBox->Enabled = false;
      ReaderLongRangeRadioButton->Enabled = true;
      ReaderShortRangeRadioButton->Enabled = true;

      ReaderIncreaseTXBitBtn->Enabled = false;
      ReaderDecreaseTXBitBtn->Enabled = false;
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ReaderSetABSTxFieldCheckBoxMouseDown(
      TObject *Sender, TMouseButton Button, TShiftState Shift, int X,
      int Y)
{
    mouseClicked = true;  //ABS
    clicked = false; //INC
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ReaderINCDECTxFieldCheckBoxMouseDown(
      TObject *Sender, TMouseButton Button, TShiftState Shift, int X,
      int Y)
{
   mouseClicked = false;  //ABS
   clicked = true; //INC
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::SetFStrengthBitBtnClick(TObject *Sender)
{
   SetFStrengthBitBtn->Font->Color = clRed;
   //QueryReaderListView->Items->Clear();

   TxClearTagCtrls();
   RxClearTagCtrls();
   ProgammingMode = true;
   programming = false;

   numReaderIDList = 0;

   receivedResponse = false;

   if(networkOn)
   {
      if (ReaderFStrengthBroadcastCheckBox->State == cbChecked)
         WriteAWSocket(QUERY_READER, 0, "G", 0, 'B', NULL, 0, 0);
      else
      {
         int rdr = atoi(ReaderFStrengthReaderComboBox->Text.c_str());
         int index = GetSocketIndex(rdr);
         if (index >= 0)
         {
            if (ReaderSetABSTxFieldCheckBox->Checked)
               WriteAWSocket(SET_READER_DPOT, 0, "A", 0, 'S', NULL, 0, index);
            else
               WriteAWSocket(SET_READER_DPOT, 0, "R", 0, 'S', NULL, 0, index);
         }
         else
            StaticText->Caption = "No matching socket for the reader.";
      }
   }
   else if (RS232On)
   {
      if (ReaderSetABSTxFieldCheckBox->Checked)
         WriteRS232Comm(SET_READER_DPOT, 0, "A", 0);  //absolute
      else
         WriteRS232Comm(SET_READER_DPOT, 0, "R", 0);  //range
   }
}
//-----------------------------------------------------------------------------
void __fastcall TProgStationForm::ReaderGetFStrengthBitBtnClick(
      TObject *Sender)
{
   if(networkOn)
   {
      int rdr = atoi(ReaderFStrengthReaderComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(GET_READER_CONFIG, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(GET_READER_CONFIG, 0, NULL, 0);
   }
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::ReaderFStrengthUpDownChangingEx(
      TObject *Sender, bool &AllowChange, short NewValue,
      TUpDownDirection Direction)
{
   /*StaticText->Caption = "";

   if(networkOn)
   {
      int rdr = atoi(SmartFGenReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         if (Direction == updUp)
            WriteAWSocket(SET_READER_DPOT, 0, "I", index, 'S', NULL, 0, index);
         else if (Direction == updDown)
            WriteAWSocket(SET_READER_DPOT, 0, "D", index, 'S', NULL, 0, index);
      }
      else
      {
          StaticText->Caption = "No matching socket for the reader.";
          return;
      }
   }
   else if (RS232On)
   {

      if (Direction == updUp)
         WriteRS232Comm(SET_READER_DPOT, 0, "I", 0);
      else if (Direction == updDown)
         WriteRS232Comm(SET_READER_DPOT, 0, "D", 0);
      else
         return;
   }*/
}
//---------------------------------------------------------------------------


void __fastcall TProgStationForm::ReaderIncreaseTXBitBtnClick(
      TObject *Sender)
{
   StaticText->Caption = "";

   if(networkOn)
   {
      int rdr = atoi(ReaderFStrengthReaderComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(SET_READER_DPOT, 0, "I", index, 'S', NULL, 0, index);
      }
      else
      {
          StaticText->Caption = "No matching socket for the reader.";
          return;
      }
   }
   else if (RS232On)
   {
      WriteRS232Comm(SET_READER_DPOT, 0, "I", 0);
   }
   else
      return;

}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ReaderDecreaseTXBitBtnClick(
      TObject *Sender)
{
   StaticText->Caption = "";

   if(networkOn)
   {
      int rdr = atoi(ReaderFStrengthReaderComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(SET_READER_DPOT, 0, "D", index, 'S', NULL, 0, index);
      }
      else
      {
          StaticText->Caption = "No matching socket for the reader.";
          return;
      }
   }
   else if (RS232On)
   {
      WriteRS232Comm(SET_READER_DPOT, 0, "D", 0);
   }
   else
      return;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::FormClick(TObject *Sender)
{
   FGenConfigWaitTimeComboBox->Items->Clear();
   for (int i=1; i<=24; i++)
      FGenConfigWaitTimeComboBox->Items->Add(i);
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::FGenConfigWaitTimeHourRadioButtonMouseDown(
      TObject *Sender, TMouseButton Button, TShiftState Shift, int X,
      int Y)
{
   FGenConfigWaitTimeHourClicked = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::FGenConfigWaitTimeMinRadioButtonMouseDown(
      TObject *Sender, TMouseButton Button, TShiftState Shift, int X,
      int Y)
{
   FGenConfigWaitTimeMinClicked = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::FGenConfigWaitTimeSecRadioButtonMouseDown(
      TObject *Sender, TMouseButton Button, TShiftState Shift, int X,
      int Y)
{
   FGenConfigWaitTimeSecClicked = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagLEDStaticTextClick(
      TObject *Sender)
{
    if (!ConfigTagLEDGroupBox->Visible)
    {
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      //GeneralGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = true;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = false;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   FGenResetBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = true;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clNavy;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   if (allHostID)
   {
      if (lastHostID > 0)
         ConfigTagLEDHostIDEdit->Text = lastHostID;
   }
   else
      ConfigTagLEDHostIDEdit->Text = sysHostID;

   ConfigTagLEDReaderIDComboBox->Items->Clear();
   for (unsigned int i=0; i<numReaderIDList; i++)
      ConfigTagLEDReaderIDComboBox->Items->Add(readerIDList[i]);

   if (lastReaderID <= 0)
      ConfigTagLEDReaderIDComboBox->Text = "";
   else
      ConfigTagLEDReaderIDComboBox->Text = lastReaderID;

   TxClearTagCtrls();
   RxClearTagCtrls();
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagLEDBitBtnClick(TObject *Sender)
{
   if (!NewListItemCheckBox->Checked)
   {
      TxClearTagCtrls();
      RxClearTagCtrls();
      ProgammingMode = true;
      StaticText->Caption = "";
      DetectedMsg->Caption = "";
      TamperSWMsg->Caption = "";
      TagDetectedGroupBox->Caption = "Detected Tags";
      tagDetectCount = 0;
      type1Count = 0;
      type2Count = 0;
      type3Count = 0;
      type4Count = 0;
      type5Count = 0;
      type6Count = 0;
      typeFacCount = 0;
      ReportType1Label->Caption = "";
      ReportType2Label->Caption = "";
      ReportType3Label->Caption = "";
      ReportType4Label->Caption = "";
      ReportType5Label->Caption = "";
      ReportType6Label->Caption = "";
      ReportFACTLabel->Caption = "";
      ReportTotalLabel->Caption = "";
      ReportNDupLabel->Caption = "";
      DetectedTagListView->Items->Clear();
      for (int i=0; i<MAX_TAG_DETECTED; i++)
      {
          tagDetectedArray[i].tagID = 0;
          tagDetectedArray[i].tagType = 6;
          tagDetectedArray[i].cmd = 0;
          tagDetectedArray[i].fGenID = 0xFF;
          tagDetectedArray[i].gID = false;
          tagDetectedArray[i].lastDetectTime = Now();
      }
   }
   //StaticText->Caption = "";
   programming = true;
   if (ConfigLEDRadioButton->Checked)
      progStr = "Please wait. Setting LED for ";
   else
      progStr = "Please wait. Setting Speaker for ";

   tagTypeStr = ConfigTagLEDTagTypeComboBox->Text;
   progStr += ConfigTagLEDTagTypeComboBox->Text;
   progStr += " Tag";

   /*if (ConfigTagLEDAccRadioButton->Checked)
   {
      tagTypeStr = "Access";
      if (ConfigLEDRadioButton->Checked)
         progStr += "Setting LED for Access Tag";
      else
         progStr += "Setting Speaker for Access Tag";
   }
   else if (ConfigTagLEDAssRadioButton->Checked)
   {
      tagTypeStr = "Asset";
      if (ConfigLEDRadioButton->Checked)
         progStr += "Setting LED for Asset Tag";
      else
         progStr += "Setting Speaker for Asset Tag";
   }
   else if (ConfigTagLEDInvRadioButton->Checked)
   {
      tagTypeStr = "Inventory";
      if (ConfigLEDRadioButton->Checked)
         progStr += "Setting LED for Inventory Tag";
      else
         progStr += "Setting Speaker for Inventory Tag";
   }*/

   if ((ConfigTagLEDTagIDRangeRadioButton->Checked) && (ConfigTagLEDTagIDEdit->Text.data() == NULL))
   {
       Application->MessageBox("Error: Need Tag ID",
                               "Programming Station Information Dialog",
                               MB_OK | MB_ICONSTOP | MB_TOPMOST);
       ConfigTagLEDBitBtn->Enabled = true;
       return;
   }

   if ((ConfigTagLEDTagTypeComboBox->Text == "All Types") && (ConfigTagLEDAnyTagIDRadioButton->Checked))
    {
        int ret = Application->MessageBox ("Do you want to Configure ALL tags?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "All Tags";
        progStr = "Please wait. Configuring All Tags";
    }
    else if (ConfigTagLEDTagTypeComboBox->Text == "All Types")
    {
       int ret = Application->MessageBox ("Do you want to Configure All Tag Types?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "All Types";
        progStr = "Please wait. Configuring All Tag Types";
    }
    else if (ConfigTagLEDAnyTagIDRadioButton->Checked)
    {
       int ret = Application->MessageBox ("Do you want to Configure Any Tag ID?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        progStr = "Please wait. Configuring Any Tag ID";
    }

   DisableTagStaticCommands();
   CMDEnableTimer->Enabled = true;
   ConfigTagLEDBitBtn->Enabled = false;

   ConfigTagLEDBitBtn->Font->Color = clRed;
   programming = true;

   StaticText->Caption = progStr;

   if(networkOn)
   {
      int rdr = atoi(ConfigTagLEDReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         if (ConfigLEDRadioButton->Checked)
             WriteAWSocket(SET_CONFIG_TAG_LED, 0, NULL, index, 'S', NULL, 0, index);
         else

             WriteAWSocket(SET_CONFIG_TAG_SPEAKER, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      if (ConfigLEDRadioButton->Checked)
         WriteRS232Comm(SET_CONFIG_TAG_LED, 0, NULL, 0);
      else
         WriteRS232Comm(SET_CONFIG_TAG_SPEAKER, 0, NULL, 0);
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagLEDNumCycleComboBoxChange(
      TObject *Sender)
{
    AnsiString s = ConfigTagLEDNumCyclesEdit->Text;
    int n = atoi(s.c_str());
    if ((n < 1) || (n > 100))
    {
       Application->MessageBox("Value should be within 1 - 100", "Programming Station", MB_OK);
       ConfigTagLEDNumCyclesEdit->Text = "";
    }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagLEDTagIDRadioButtonClick(TObject *Sender)
{
   ConfigTagLEDTagIDEdit->ReadOnly = false;
   ConfigTagLEDTagIDEdit->Color = clWhite;
   ConfigTagLEDTagIDEdit->Enabled = true;

   ConfigTagLEDTagIDRangeComboBox->Font->Color = clGray;
   ConfigTagLEDTagIDRangeComboBox->Color = clMenu;
   ConfigTagLEDTagIDRangeComboBox->Enabled = false;

   ConfigTagLEDRNLongRadioButton->Enabled = true;
   ConfigTagLEDRNShortRadioButton->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagLEDAnyTagIDRadioButtonClick(
      TObject *Sender)
{
   ConfigTagLEDTagIDEdit->ReadOnly = true;
   ConfigTagLEDTagIDEdit->Color = clMenu;
   ConfigTagLEDTagIDEdit->Enabled = false;

   ConfigTagLEDTagIDRangeComboBox->Font->Color = clGray;
   ConfigTagLEDTagIDRangeComboBox->Color = clMenu;
   ConfigTagLEDTagIDRangeComboBox->Enabled = false;

   ConfigTagLEDRNLongRadioButton->Enabled = true;
   ConfigTagLEDRNShortRadioButton->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagLEDGetBitBtnClick(
      TObject *Sender)
{
   programming = true;
   /*progStr = "Please wait. ";
   if (ConfigTagLEDAccRadioButton->Checked)
   {
      tagTypeStr = "Access";
      progStr += "Getting LED Configuration for Access Tag";
   }
   else if (ConfigTagLEDAssRadioButton->Checked)
   {
      tagTypeStr = "Asset";
      progStr += "Getting LED Configuration for Asset Tag";
   }
   else if (ConfigTagLEDInvRadioButton->Checked)
   {
      tagTypeStr = "Inventory";
      progStr += "Getting LED Configuration for Inventory Tag";
   }

   if (CallTagAnyTagIDRadioButton->Checked)
      progStr += "s";
   else
      progStr += " ";
   */

   if (!NewListItemCheckBox->Checked)
   {
      TxClearTagCtrls();
      RxClearTagCtrls();
      ProgammingMode = true;
      StaticText->Caption = "";
      DetectedMsg->Caption = "";
      TamperSWMsg->Caption = "";
      TagDetectedGroupBox->Caption = "Detected Tags";
      tagDetectCount = 0;
      type1Count = 0;
      type2Count = 0;
      type3Count = 0;
      type4Count = 0;
      type5Count = 0;
      type6Count = 0;
      typeFacCount = 0;
      ReportType1Label->Caption = "";
      ReportType2Label->Caption = "";
      ReportType3Label->Caption = "";
      ReportType4Label->Caption = "";
      ReportType5Label->Caption = "";
      ReportType6Label->Caption = "";
      ReportFACTLabel->Caption = "";
      ReportTotalLabel->Caption = "";
      ReportNDupLabel->Caption = "";
      DetectedTagListView->Items->Clear();
      for (int i=0; i<MAX_TAG_DETECTED; i++)
      {
          tagDetectedArray[i].tagID = 0;
          tagDetectedArray[i].tagType = 6;
          tagDetectedArray[i].cmd = 0;
          tagDetectedArray[i].fGenID = 0xFF;
          tagDetectedArray[i].gID = false;
          tagDetectedArray[i].lastDetectTime = Now();
      }
   }
   //StaticText->Caption = "";
   programming = true;
   if (ConfigLEDRadioButton->Checked)
      progStr = "Please wait. Getting LED for ";
   else
      progStr = "Please wait. Getting Speaker for ";

   tagTypeStr = ConfigTagLEDTagTypeComboBox->Text;
   progStr += ConfigTagLEDTagTypeComboBox->Text;
   progStr += " Tag";


   ConfigTagLEDNumCyclesEdit->Text = "";

   /*QueryTagBitBtn->Enabled = false;
   EnableReaderStaticText->Enabled = false;
   DisableReaderStaticText->Enabled = false;
   QueryReaderStaticText->Enabled = false;
   AssignReaderStaticText->Enabled = false;
   ReaderVersionStaticText->Enabled = false;
   ConfigTxTimeStaticText->Enabled = false;
   RelayStaticText->Enabled = false;
   EnableRdrFGenStaticText->Enabled = false;
   ConfigFGenStaticText->Enabled = false;
   QueryFGenStaticText->Enabled = false;
   SmartFGenStaticText->Enabled = false;
   FGenResetStaticText->Enabled = false;
   ConfigTagStaticText->Enabled = false;
   EnableTagStaticText->Enabled = false;
   DisableTagStaticText->Enabled = false;
   QueryTagStaticText->Enabled = false;
   CallTagStaticText->Enabled = false;
   AssignTagRdrStaticText->Enabled = false;
   ConfigTagRNDStaticText->Enabled = false;
   WriteMemoryStaticText->Enabled = false;
   ReadMemoryStaticText->Enabled = false;
   TagTempStaticText->Enabled = false;
   InputsStaticText->Enabled = false;
   ConfigTagLEDStaticText->Enabled = false;
   ConfigTagLEDGetBitBtn->Enabled = false;*/

   StaticText->Caption = progStr;
   ConfigTagLEDNumCyclesEdit->Text = "";

   if (!ConfigTagLEDKeepListCheckBox->Checked)
        ConfigTagLEDListView->Items->Clear();
   else
   {
      ledListCount = ConfigTagLEDListView->Items->Count;
      ConfigTagLEDListView->Invalidate();
   }

   if(networkOn)
   {
      int rdr = atoi(ConfigTagLEDReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(GET_CONFIG_TAG_LED, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(GET_CONFIG_TAG_LED, 0, NULL, 0);
   }
}
//---------------------------------------------------------------------------



void __fastcall TProgStationForm::ConfigTagLEDEnableCheckBoxMouseDown(
      TObject *Sender, TMouseButton Button, TShiftState Shift, int X,
      int Y)
{
    mouseClicked = true;
}
//---------------------------------------------------------------------------


void __fastcall TProgStationForm::ConfigTagLEDBroadcastRdrCheckBoxClick(
      TObject *Sender)
{
   if (ConfigTagLEDBroadcastRdrCheckBox->State == cbChecked)
   {
      ConfigTagLEDReaderIDComboBox->Color = clMenu;
      ConfigTagLEDReaderIDComboBox->Enabled = false;
   }
   else
   {
      ConfigTagLEDReaderIDComboBox->Enabled = true;
      ConfigTagLEDReaderIDComboBox->Color = clWhite;
   }

}
void __fastcall TProgStationForm::DownloadRdrStaticTextClick(
      TObject *Sender)
{
   if (!DownloadRdrGroupBox->Visible)
    {
      EncryptGroupBox->Visible = false;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      //InputsGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = true;
      ConfigReaderTxTimeGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   DownloadRdrStaticText->Visible = false;
   //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = true;
   //ConfigTxTimeStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   DownloadRdrBitBtn->Visible = true;
   //EnableFGenBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   FGenResetBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   DownloadRdrBitBtn->Font->Color = clNavy;
   SetFStrengthBitBtn->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clNavy;
   InputsBitBtn->Font->Color = clNavy;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   //if (lastHostID <= 0)
      //EnableFGenHostIDEdit->Text = "";
   //else
      //EnableFGenHostIDEdit->Text = lastHostID;
   if (allHostID)
   {
      if (lastHostID > 0)
         DownloadRdrHostEdit->Text = lastHostID;
   }
   else
      DownloadRdrHostEdit->Text = sysHostID;

   DownloadRdrReaderComboBox->Items->Clear();
   for (unsigned int i=0; i<numReaderIDList; i++)
      DownloadRdrReaderComboBox->Items->Add(readerIDList[i]);

   if (lastReaderID <= 0)
      DownloadRdrReaderComboBox->Text = "";
   else
      DownloadRdrReaderComboBox->Text = lastReaderID;

   //if (DownloadRdrOpenDialog->FileName.data() != NULL)
      //DownloadRdrFileNameEdit->Text = DownloadRdrOpenDialog->FileName;

   TxClearTagCtrls();
   RxClearTagCtrls();

   if (DownloadRdrProcessCRadioButton->Checked)
      DownloadRdrOpenDialog->Filter = "awi501_C.BIN|*.BIM";
   if (DownloadRdrProcessDRadioButton->Checked)
      DownloadRdrOpenDialog->Filter = "awi501_D.BIN|*.BIN";
   else
      DownloadRdrOpenDialog->Filter = "awi501_E.BIN|*.BIN";

   //Do boot query
   //DataCodeVerLabel->Caption = "";
   //ProgCodeVerLabel->Caption = "";
   //HostCodeVerLabel->Caption = "";

   DownloadRdrPCVerLabel->Caption = "";
   DownloadRdrPCDateLabel->Caption = "";

   DownloadRdrPDVerLabel->Caption = "";
   DownloadRdrPDDateLabel->Caption = "";

   DownloadRdrPEVerLabel->Caption = "";
   DownloadRdrPEDateLabel->Caption = "";

   TxClearTagCtrls();
   RxClearTagCtrls();
   StaticText->Caption = "";
   receivedResponse = false;

   if(networkOn)
   {
      int rdr = atoi(DownloadRdrReaderComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(BOOT_QUERY, 0, NULL, 0, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(BOOT_QUERY, 0, NULL, 0);
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::DownloadRdrGetFileBitBtnClick(
      TObject *Sender)
{
    if (DownloadRdrProcessCRadioButton->Checked)
      DownloadRdrOpenDialog->Filter = "awi501_C.BIN|*.BIN";
    else if (DownloadRdrProcessDRadioButton->Checked)
      DownloadRdrOpenDialog->Filter = "awi501_D.BIN|*.BIN";
    else
      DownloadRdrOpenDialog->Filter = "awi501_E.BIN|*.BIN";

    DownloadRdrOpenDialog->Execute();
    DownloadRdrFileNameEdit->Text = DownloadRdrOpenDialog->FileName;
}
//---------------------------------------------------------------------------
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@                                                                           @@
@@                           BootLoad Stuff                                  @@
@@                                                                           @@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
//  startBootLoader()
//     1  open_hex_file() ............... OK
//        1.1  imbed_the_proc() ......... OK
//     2  build_diag_string()
//     3  UpdateData()
//     4  fill_image_buf()
//     5  send_a_bload_cmd()
//
//
//   1 - open_hex_file()
//       1.1  imbed_the_proc()
//
//
//   2 - build_diag_string()
//
//
//   3 - UpdateData()  //microsoft API
//
//
//   4 - fill_image_buf()
//       4.1 str2byte()
//
//
//   5 - send_a_bload_cmd()
//       5.1  convert_image2_packet()
//       5.2  add2_send_queue()
//       5.3  convert_record2_packet()
//
/*------------------------------------------------------------------------------
	The boot_loader command thing.
	18 Jan 03: now using MPLAB 6.10 which prosuces a slightlly diffrerent hex
	file, one that starts with a ":020000040000FA" or ":02 0000 04 00 00 FA".
	The "04" is usually "00" in a normal data record.  This is some kind of
	beginning type, and I added code to skip this, but stay here till one is
	found (a normal record), and is converted and sent.

      The variable "bootload-state" follows the end of the process thusly:
	  bls = 0:  boot-loading in progress
	  bls = 1:  last boot-load command sent to processor "?"
	  bls = 2:  got the ACK from the reader for the last boot-load command sent
	  bls = 3:  sent a reset to the reader
	  bls = 4:  got the ACK from the reader for the reset
	  bls = 5:  got the PU packet from the reader after the reset (and it's ACK)
	  bls = 6:  sent the host ACK of the PU packet from the reader
	  bls = 7:  sent the boot-query to the reader
	  bls = 8:  got the ACK from the reader of the boot-query, done
------------------------------------------------------------------------------*/

void __fastcall TProgStationForm:: StartBootLoader(void)
{
    UINT i;
    char st[] = "<<< Booting \"?\" >>>";
    char buf[100];

    //open_hex_file();
    currIndex = 0;

    if (bload_proc == 0)
       StaticText->Caption = "Erasing Process 'C'";
    if (bload_proc == 1)
       StaticText->Caption = "Erasing Process 'D'";
    if (bload_proc == 2)
       StaticText->Caption = "Erasing Process 'E'";
    for( i = 0; i < IMAGE_BFR_LEN; i++ )
       prog_image[ i ] = PROG_LOC_ERASED;
    //change_proc_display( SW_HIDE );

    //--------------------------------------------------------------
    // hide the begin button, and some others
    //--------------------------------------------------------------
    //GetDlgItem( IDC_BEGIN_BTN ) -> ShowWindow( SW_HIDE );
    //GetDlgItem( IDC_REAL_CB )	-> ShowWindow( SW_HIDE );
    //???CheckRadioButton( IDC_RADIO4, IDC_RADIO6, NULL );		// deselect processor
    //--------------------------------------------------------------
    // show the configuration of this boot-load
    //--------------------------------------------------------------
    OnClrBtn();
    //wsprintf( buf, "    <<<< Patience, erasing Proc \"%c\" >>>>", proc_letter[ bload_proc ] );
    st[ 13 ] = proc_letter[ bload_proc ];

    switch( bload_proc )	// 18 Sep 04: clear the chosen processor data string
    {
	case 0:
		m_cksmc_str = st; //_T(st);
		m_cksm_str  = ""; //_T("");
                DownloadRdrProgressBarC->Max = encIndex; //numLines;
		break;
	case 1:
		m_cksmd_str = st; //_T(st);
		m_cksm_str  = ""; //_T("");
                DownloadRdrProgressBarD->Max = encIndex;  //numLines;
		break;
	case 2:
		m_cksme_str = st; //_T(st);
		m_cksm_str  = ""; //_T("");
                DownloadRdrProgressBarE->Max = encIndex;  //numLines;
		break;
	/*case 4:
		m_procj_str = _T(st);
		m_cksum_str = _T("");
		break;
	case 5:
		m_prock_str = _T(st);
		m_cksum_str = _T("");
		break; */
	default:
		break;
    } // end switch

    //build_diag_string( buf, 0, 4 );

    //????UpdateData( FALSE );
    now_bootloading = TRUE;
    record_num = 0;
    bl_ending_state = 0;	// added 18 Aug 04 for failed bload attempts

    if( boot_proc_new )
    {
       fill_image_buf();
       proc_addrs = 0;
    }

    //StaticText->Caption = "Downloading the hex file";
    bootloading = true;

    cleanup_scheduled = 0;
    first_bload_cmd = TRUE;
    send_a_bload_cmd();		// this kicks off the process

}//StartBootLoader


void __fastcall TProgStationForm::open_hex_file( void )
{
    char  file_name[ 32 ];
    char buf[100];

    if (DownloadRdrFileNameEdit->Text.data() != NULL)
       strcpy( file_name, DownloadRdrFileNameEdit->Text.c_str());
    else
    {
        Application->MessageBox("Error: No Hex file", "Error", MB_OK);
        return;
    }
    //imbed_the_proc( file_name );
    if(( fptr = fopen( file_name, "r" )) == NULL )
    {
       //strcpy( file_name, "..\\" );
       //strcat( file_name, DownloadRdrFileNameEdit->Text.c_str());
       //imbed_the_proc( file_name );
       //if( ( fptr = fopen( file_name, "r" ) ) == NULL )
       //{
          wsprintf( buf, "Opening the hex File (\"%s\") failed.", file_name );
          //AfxMessageBox( buf );
          Application->MessageBox(buf, MB_OK);
          abort_thread = 1;
       //} // end if open of the alternative file failed
    } // end if open of the primary file failed

    numLines = 0;
    while(fgets(fbuf, 80, fptr ))
      numLines++;
    fclose(fptr);
    if(( fptr = fopen( file_name, "r" )) == NULL )
    {
       wsprintf( buf, "Opening the hex File (\"%s\") failed.", file_name );
       Application->MessageBox(buf, MB_OK);
       abort_thread = 1;
    }


} // end open_hex_file()

//------------------------------------------------------------------------------
  //Complete the hex file specification via the processor variable     29 Nov 02
//------------------------------------------------------------------------------
void __fastcall TProgStationForm:: imbed_the_proc( char *str )
{
    UINT i, j;

    j = strlen( str );
    for( i = 0; i < j; i++ )
    {
       if( str[ i ] == '?' )
       {
          str[ i ] = proc_letter[ bload_proc ];
       } // end if unknown found
    } // end for
} // end imbed_the_proc()
//------------------------------------------------------------------------------
  //30 Jan 03: by the time I get here, the image-buf is filled with 0x3FFF, and
  //the hex file is opened.   Because the PIC16F876A is different (requiring
  //boot-loading only on a 4 location boundary), this function will initially
  //fill the image-buf, and then this program will make boot-load commands to
  //processor "D" out of the image.  Filling the buf from the hex records is the
  //first step.
//------------------------------------------------------------------------------
/*void __fastcall TProgStationForm::fill_image_buf( void )
{
    bool address_is_ok;
    char c, checksum;  short unsigned int pvalue;
    UINT crpx, i, length, paddrs;

    while( TRUE )
    {
        if( fgets( fbuf, 80, fptr ) )
        {
	//----------------------------------------------------------------------------
	  //I see the byte value in the position following the hex record address to
	  //be mostly "00" for all data records, and (since MPLAB 6.1), an initial one
	  //of "04" (":02 0000 04 0000 FA"), and, of course, a "01" in the ending
	  //record (with the zero length byte immediately after the ':' (":00 0000 01 FF").
	//----------------------------------------------------------------------------
            if( i = str2byte( &fbuf[ 7 ] ) )	// if a non-zero record type ??
            {
                if( i == 0x01 )
                    break;    // from the while loop
            }
            else    // if a zero record type ??
            {
		//--------------------------------------------------------------
		// Get a new line from the specified hex file to send to the
		// reader and see if it's indicated length is non-zero
		//--------------------------------------------------------------
                if( length = str2byte( &fbuf[ 1 ] ) )	// if still a non-zero record length
                {
                    checksum = length;
                    crpx = 3;
                    paddrs = str2int( &fbuf[ crpx ] ) / 2;
                    address_is_ok =  ( paddrs >= procs[ bload_proc ].max_cksm_loc ) ? FALSE : TRUE;

                    for( i = 0; i < ( length + 3 ); i++ )
                    {
                       checksum += ( c = str2byte( &fbuf[ crpx ] ) );
                       if( address_is_ok && ( i > 2 ) )
                       {
                          if( i & 0x0001 )
                             pvalue = c & 0x0FF;
                          else
                          {
                             pvalue |= ( c << 8 ) & 0xFF00;
                             prog_image[ paddrs++ ] = pvalue;
                          } // end if on lower byte boundary of prog value
                       } // end if saving into the prog-image array, and if into the data
                       crpx += 2;
                    } // end for
                    if( checksum += str2byte(&fbuf[ crpx ]))
                    {
                       //AfxMessageBox( "Bad Hex-File Checksum" );  abort_thread = 1;
                       Application->MessageBox("Bad Hex-File Checksum", MB_OK);
                       abort_thread = 1;
                    } // end if bad checksum
                } // end if not an ending record (length of 0x00)
                else
                {
                   break;			// reached the zero length record (end of file)
                } // end if an ending record (length of 0x00)
            } // end if a zero record type
        } // end if another line read OK
        else
        {
           break;
        } // end if fgets() failed (EOF)
    } // end while
} // end fill_image_buf()
*/
void __fastcall TProgStationForm::fill_image_buf(void)
{
    bool address_is_ok;
    char c, checksum;  short unsigned int pvalue;
    UINT crpx, i, length, paddrs;
    UINT index = 0;

    while(index < encIndex)
    {
        //if( fgets( fbuf, 80, fptr ) )
        strcpy(fbuf, &encryptBuf[index][0]);
        {
           index += 1;
	//----------------------------------------------------------------------------
	  //I see the byte value in the position following the hex record address to
	  //be mostly "00" for all data records, and (since MPLAB 6.1), an initial one
	  //of "04" (":02 0000 04 0000 FA"), and, of course, a "01" in the ending
	  //record (with the zero length byte immediately after the ':' (":00 0000 01 FF").
	//----------------------------------------------------------------------------
            if( i == (UINT)str2byte( &fbuf[ 7 ] ) )	// if a non-zero record type ??
            {
                if( i == 0x01 )
                    break;    // from the while loop
            }
            else    // if a zero record type ??
            {
		//--------------------------------------------------------------
		// Get a new line from the specified hex file to send to the
		// reader and see if it's indicated length is non-zero
		//--------------------------------------------------------------
                if( length == (UINT)str2byte( &fbuf[ 1 ] ) )	// if still a non-zero record length
                {
                    checksum = length;
                    crpx = 3;
                    paddrs = str2int( &fbuf[ crpx ] ) / 2;
                    address_is_ok =  ( paddrs >= procs[ bload_proc ].max_cksm_loc ) ? FALSE : TRUE;

                    for( i = 0; i < ( length + 3 ); i++ )
                    {
                       checksum += ( c = str2byte( &fbuf[ crpx ] ) );
                       if( address_is_ok && ( i > 2 ) )
                       {
                          if( i & 0x0001 )
                             pvalue = c & 0x0FF;
                          else
                          {
                             pvalue |= ( c << 8 ) & 0xFF00;
                             prog_image[ paddrs++ ] = pvalue;
                          } // end if on lower byte boundary of prog value
                       } // end if saving into the prog-image array, and if into the data
                       crpx += 2;
                    } // end for
                    checksum += str2byte(&fbuf[ crpx ]);
                    if(checksum > 0)
                    {
                       //AfxMessageBox( "Bad Hex-File Checksum" );  abort_thread = 1;
                       Application->MessageBox("Bad Hex-File Checksum", MB_OK);
                       abort_thread = 1;
                    } // end if bad checksum
                } // end if not an ending record (length of 0x00)
                else
                {
                   break;			// reached the zero length record (end of file)
                } // end if an ending record (length of 0x00)
            } // end if a zero record type
        } // end if another line read OK  strcpy

        /////else
        /////{
           /////break;
        /////} // end if fgets() failed (EOF)

    } // end while
} // end fill_image_buf()

//------------------------------------------------------------------------------
  //Converts string "A987" h = 0xA987 or "A98" h = 0x0A98         25 Sep 92
//------------------------------------------------------------------------------
UINT str2int( char *str ) {
	UINT c, i, h = 0, n = strlen( str );  if( n > 4 ) n = 4;

	for( i = 0; i < n; i++ ) {
		c = str[i]  & 0xFF;  h += ( (c&0xF) + 9*(c>'9') ) << 4*((n-1)-i); }
	return( h );
} // end str2int()
//------------------------------------------------------------------------------
  //Converts string "A9" h = 0xA9 or "0A" h = 0x0A		       29 Nov 02
//------------------------------------------------------------------------------
unsigned char str2byte( char *str ) {
	UINT c, i, h = 0, n = strlen( str );  if( n > 2 ) n = 2;

	for( i = 0; i < n; i++ ) {
		c = str[i]  & 0xFF;  h += ( (c&0xF) + 9*(c>'9') ) << 4*((n-1)-i); }
	return( h );
} // end str2byte()

void __fastcall TProgStationForm::send_a_bload_cmd(void)
{
    UINT i;

    //----------------------------------------------------------------------------
    //   30 Jan 03: since the F876A is different, this code handles packet generation
    //----------------------------------------------------------------------------
    if(boot_proc_new)
    {
        while(true)
        {
            if(i == convert_image2_packet())
            {
                add2_send_queue(i + 1);

                test2->Caption = proc_addrs;
                test3->Caption = procs[bload_proc].max_cksm_loc;

                WriteToRS232Port(i+1);

                waiting4_reader_ack = FALSE;

                if( proc_addrs >= procs[bload_proc].max_cksm_loc )	// if finished
                {
                    bl_ending_state = 1;
                    lastDownloadPkt = true;
                    //BootloadTimer->Enabled = true;
                } // end if the end
                break;
            } // end if it said I built one, or I am done
        } // end while
    } // end if processor "D"
    else
    {	// it's not processor "D", but either "C" or "E" or "T"
        while(true)
        {
            //if(fgets(fbuf, 80, fptr ))
            test2->Caption = currIndex;
            test3->Caption = encIndex;
            if (currIndex <= encIndex)
            {
                strcpy(fbuf, &encryptBuf[currIndex][0]);
                currIndex += 1;
                if(!(i == (UINT)str2byte( &fbuf[7])))	// must be a zero record type
                {				// ie, :10 0C70 00 83128D0A03198F0A08000430A900F930 85
                //----------------------------------------------------------------------------
	        //Get a new line from the specified hex file to send to the reader and see
	        //if it's indicated length is non-zero.  Actually, the ending record is a
                //non-zero record type (which means that the following code doesn't hit,
	        //the fgets() fails).
	        //----------------------------------------------------------------------------
                    if(i == (UINT)str2byte(&fbuf[ 1 ]))	// if still a non-zero record length
                    {
                        i = convert_record2_packet(i);
                        if(i)
                        {
                            add2_send_queue(i);
                            //May be this is a good place to send the packet
                            WriteToRS232Port(i);
                            waiting4_reader_ack = FALSE;
                        }
                        break;
                    } // end if not an ending record (length of 0x00)
                    else
                    {
                       bl_ending_state = 1;	// reached the zero length record (end of file)
                       lastDownloadPkt = true;
                       //BootloadTimer->Enabled = true;
                       break;
                    } // end if an ending record (length of 0x00)
                } // end if a zero record type
            } // end if another line read OK
            else
            {
                bl_ending_state = 1;	// this is the one that is hit when the file is gone
                lastDownloadPkt = true;
                //BootloadTimer->Enabled = true;
                break;
            } // end if fgets() failed
        } // end while
    } // end if not "D" processor

    record_num++;   // moved here 16 Aug 04
    char buff[100];
    if (record_num > 1)
    {
      wsprintf( buff, "Downloading record number %d", record_num );
      StaticText->Caption = buff;
    }
    bload_update = TRUE;

} // end send_a_bload_cmd()

//------------------------------------------------------------------------------
  //30 Jan 03: special for processor "D" only
  //24 Jul 03: now for any and all
  //Makes -> :                                  NN-bytes-of-data
  //into  ->  7E 6? NN+5/6 0A/E HS RD(RL) AD-RS NN-bytes-of-data CH-CL

  //Returns 0 if no packet is built, N (the whole packet length) if one is
  //built, and the processor's maximum-checksum-location if the proc-address
  //reaches there.
//------------------------------------------------------------------------------
UINT __fastcall TProgStationForm::convert_image2_packet(void)
{
    UINT i, j, k, m, placmt = 0, x;

	//----------------------------------------------------------------------------
	  //first, sweep through 8 locations of the image array looking for data that
	  //is non-erased (not equal to 0x3FFF) either in none of the 8 locations, in
	  //the first 4 locations only, in the last 4 locations only, or in both the
	  //1st 4 and the last 4.  Any non-erased value in any section of the 8
	  //locations means that I have to send the entire 4 to enable programming
	  //of the one (or more) non-erased locations
	  //if the data is: 3FFF 3FFF 3FFF 3FFF 3FFF 3FFF 3FFF 3FFF, placmt = 0
	  //if the data is: 3FFF ???? 3FFF 3FFF 3FFF 3FFF 3FFF 3FFF, placmt = 1
	  //if the data is: 3FFF 3FFF 3FFF 3FFF ???? 3FFF 3FFF 3FFF, placmt = 2
	  //if the data is: 3FFF 3FFF 3FFF ???? ???? 3FFF 3FFF 3FFF, placmt = 3, etc.
	  //24 Jul 03: no longer true, see note below!!!
	//----------------------------------------------------------------------------
	for( i = 0; i < 8; i++ )
	{
		if( prog_image[ proc_addrs + i ] != PROG_LOC_ERASED )
		{
			if( i < 4 )
			{
				placmt = 1;
				i = 3;			// advance the look to the last 4 locations
			} // end if in the first 4 locations
			else
			{
				placmt = placmt ? 3 : 2;
				break;			// from the for loop, done
			} // end if in the last 4 locations
		} // end if some non-erased image
	} // end for

//
	//23 Jul 03: working on fixing the boot-load process for the reader processors.
	//Sometimes, I don't get the same checksum from the processor that BLH
	//predicted.  I finally figured it out.  Sometimes the new hex image does not
	//occupy the same program space that the old image did, and, since this
	//process isn't a bulk-erase operation, the old data is still there after
	//programming the new stuff, and, hence, BLH does not know about it and
	//thus does not generate the same checksum (making the process look like it
	//failed.  I changed this function() to send all code, even if it's all 0x3FFF.
	//This will force the entire load to be the same as BLH predicts.  It seems
	//to work!!
	//placmt = 3;		// force it regardless =====================
//


	//----------------------------------------------------------------------------
	  //now, placement is 0 to 3, indicating one of the four conditions listed above
	//----------------------------------------------------------------------------
	switch( placmt )
	{
	case 0:			// nothing over all 8 locations
//		j = 0;	for a breakpoint
		break;
	case 1:			// only something in the 1st four locations
		j = 0;  k = 4;  m = 8;
		break;
	case 2:			// only something in the last four locations
		j = 4;  k = 8;  m = 8;
		break;
	case 3:			// something in each half
		j = 0;  k = 8;  m = 16;
		break;
	} // end switch

	if( placmt )
	{
		x = bl_packet_prelims( m );
		m = proc_addrs + j;
		//???generate_crc(send_buf[++x] = ( ( ( m >> 8 )  & 0x0FF ) | ( boot4_real ? 0 : 0x80 ) ) );
		//???generate_crc(send_buf[++x] = ( m & 0x0FF ) );
                generate_crc((char)XBuf[++x] = ( ( ( m >> 8 )  & 0x0FF ) | ( boot4_real ? 0 : 0x80 ) ) );
		generate_crc((char)XBuf[++x] = ( m & 0x0FF ) );
		for( i = j; i < k; i++ )
		{
			placmt = prog_image[ proc_addrs + i ];
			//???generate_crc( send_buf[ ++x ] = (   placmt         & 0x0FF ) );
			//???generate_crc( send_buf[ ++x ] = ( ( placmt >> 8 )  & 0x0FF ) );
                        generate_crc((char)XBuf[++x] = (placmt & 0x0FF));
			generate_crc((char)XBuf[++x] = ((placmt >> 8)  & 0x0FF));
		} // end for
		finish_the_packet(&x, 0, 0);
	} // end if something to send
	else x = 0;

	proc_addrs += 8;
        //TestLabel->Caption = proc_addrs;
	return( x );
} // end convert_image2_packet()

void __fastcall TProgStationForm::add2_send_queue(UINT count)
{
	if( diagnostic_mode )
           build_diag_string((char*)XBuf, count, 0);	// sent, not rcvd
	something2_send	+= count;

	//???if(!(send_buf[ 1 ] & CMD_ACK))
        if(!(XBuf[1] & CMD_ACK))
	{
           wait4_ack_timer = TICKS_2WAIT_4ACK;
           waiting4_reader_ack = TRUE;
	} // end if not an ACK to the reader but a command expecting an ACK from...
} // end add2_send_queue()

//------------------------------------------------------------------------------
  //I won't be here unless the hex record type byte is 0x00
  //Makes -> :                          :NN 0080 00 NN-bytes-of-data CK
  //into  ->  7E 6? NN+5/6 0A/E HS RD(RL)   0080    NN-bytes-of-data    CH-CL
//------------------------------------------------------------------------------
UINT __fastcall TProgStationForm::convert_record2_packet(UINT byte_len)	// byte-len = NN
{
	bool address_is_ok;
	char c, checksum;  short unsigned int pvalue;
	UINT crpx = 3, i, ndx, paddrs;

	proc_addrs = paddrs = str2int( &fbuf[ crpx ] ) / 2;
	ndx = bl_packet_prelims( byte_len );

	//----------------------------------------------------------------------------
	  //If the processor's program address for this record is beyond the maximum
	  //address specified for this processor, skip storing the prog-value in the
	  //program space image.
	//----------------------------------------------------------------------------
	address_is_ok = ( paddrs >= procs[ bload_proc ].max_cksm_loc ) ? FALSE : TRUE;

	checksum = byte_len;
	for( i = 0; i < ( byte_len + 3 ); i++ )
	{
		if( i != 2 )	// pointing to the dummy 0x00 byte
		{
//			generate_crc( c = send_buf[ ++ndx ] = str2byte( &fbuf[ crpx ] ) );
//			checksum += c;
			c = str2byte( &fbuf[ crpx ] );
			checksum += c;
			if( crpx == 3 && !boot4_real ) c |= 0x80;	// 21 Aug 04: added fake bload
			//???generate_crc( send_buf[ ++ndx ] = c );
                        generate_crc((char)XBuf[ ++ndx ] = c );
		} // end if not at the dummy byte

	//----------------------------------------------------------------------------
	  //if into the data portion of the record, and if the record's address isn't
	  //greater than the location specified in the control file up to which the
	  //calculated checksum is formed, lay the current data value into an image
	  //array so that I can calculate locally the expected checksum reported
	  //by the processor after booting.
	//----------------------------------------------------------------------------
		if( address_is_ok && ( i > 2 ) )
		{
	//----------------------------------------------------------------------------
	  //if the address isn't on a b'??????00' boundary, or if the byte-len of
	  //the record is < 7 (a len of 8 is minimum), ...
	//----------------------------------------------------------------------------
			if( i & 0x0001 ) pvalue = c & 0x0FF;
			else
			{
				pvalue |= ( c << 8 ) & 0xFF00;
				prog_image[ paddrs++ ] = pvalue;
			} // end if on lower byte boundary of prog value
		} // end if saving into the program image array, and if into the data itself
		crpx += 2;
	} // end for

        checksum += str2byte( &fbuf[ crpx ] );
	if(checksum > 0)
	{
		//AfxMessageBox( "Bad Hex-File Checksum" );  abort_thread = 1;
                Application->MessageBox("Bad Hex-File Checksum", MB_OK);
                abort_thread = 1;
//		while( 1 );
	} // end if bad checksum
	finish_the_packet( &ndx, 0, 0 );
		// the packet is built out of the hex file record.  Send it now.
	return( ndx + 1 );
} // end convert_record2_packet()
/*------------------------------------------------------------------------------
 The "Clear Screen" button handler
------------------------------------------------------------------------------*/
void _fastcall TProgStationForm::OnClrBtn()
{
    UINT i;
    for( i = 0; i < NUM_OF_DISP_LINES; i++ )
       strcpy( rsbuf[ i ], "\r\n" );
    tag_rcvd_count = 0;		// 7 Mar 03: now clear the counter if clear screen
    build_diag_string( NULL, 0, 0 );
    bl_ending_state = 0;	// 28 Sep 04: clearing the screen will terminate the bload
    //???diags.in_terminal_mode = 0;
} // end OnClrBtn()
/*------------------------------------------------------------------------------
  30 Jan 03: separated (for processor "D" special work)
------------------------------------------------------------------------------*/
UINT _fastcall TProgStationForm::bl_packet_prelims(UINT bpp_len)
{
	char  bload_cmd[] = {0x6C,0x6D,0x6E,0x00,0x6C,0x6D};
	short unsigned int id;  UINT x;

	crc = CRC_INITIALIZE;
	//???generate_crc(send_buf[ 0 ] = HDLC_FLAG);
	//???generate_crc( send_buf[ x = 1 ] = bload_cmd[ bload_proc ] );
        generate_crc((char)XBuf[0] = HDLC_FLAG);
	generate_crc((char)XBuf[x = 1] = bload_cmd[bload_proc]);

	if( bload_proc < 3 )	// that is, in the reader (not TCop or SFGen)
	{
            //???generate_crc(send_buf[++x] = bpp_len + (itsan_ext_reader ? 6 : 5 ));
            //???generate_crc(send_buf[++x] = itsan_ext_reader ? HOST2_XREADER_PTYPE : HOST2_READER_PTYPE);
            generate_crc((char)XBuf[++x] = bpp_len + (itsan_ext_reader ? 6 : 5 ));
            generate_crc((char)XBuf[++x] = itsan_ext_reader ? HOST2_XREADER_PTYPE : HOST2_READER_PTYPE);

            //???generate_crc(send_buf[++x] = host_id);
            generate_crc((char)XBuf[++x] = host_id);

            //id = use_edit_rdr_id ? e16b_value : rdrs[currnt_rdr].raddr;
            id = rdrs[currnt_rdr].raddr;
            if( itsan_ext_reader )
            {
                //???generate_crc(send_buf[++x ] = ( id >> 8 ) & 0x0FF);
                generate_crc((char)XBuf[++x] = (id >> 8) & 0x0FF);
            } // end if it is an extended reader
	} // end if booting a reader processor
	else
	{
		//???generate_crc(send_buf[++x] = bpp_len + 5);
		//???generate_crc(send_buf[++x] = HOST2_FGEN_PTYPE);
		//???generate_crc(send_buf[++x] = host_id);
                generate_crc((char)XBuf[++x] = bpp_len + 5);
		generate_crc((char)XBuf[++x] = HOST2_FGEN_PTYPE);
		generate_crc((char)XBuf[++x] = host_id);
		id = fgen_id;
	} // end if booting a SFGen processor
	//???generate_crc(send_buf[++x] = id & 0x0FF );
        generate_crc((char)XBuf[++x] = id & 0x0FF );
	return( x );
} // end bl_packet_prelims()
/*------------------------------------------------------------------------------
 make the display string of the received and sent packets
 Note: decimal 164 is circle with 4 spokes, 169 is copyright, 174 is circle K
 215 is a wide "x"
//	ASSERT( !in_bps );
------------------------------------------------------------------------------*/
void _fastcall TProgStationForm::build_diag_string( char *src, UINT len, UINT rcvd )
{
    char buf[100];
    char nbuf[6] = "     ", new_string[SHOW_STR_LEN];
    UINT i;

    //???if( freeze_screen ) return;

    nbuf[0] = len ? (char)CHOSEN_MARKER : ' ';  nbuf[3] = 0;

    if(in_bps)
    {
       //AfxMessageBox( "Re-entered bps()!" );  abort_thread = 1;
       Application->MessageBox("Re-entered bps()!", MB_OK);
       abort_thread = 1;
    } // end if re-entered
    in_bps = TRUE;

    for(i = 0; i < (NUM_OF_DISP_LINES - 1); i++ )
       strcpy(rsbuf[ i ], rsbuf[i + 1] );

    if( rcvd == 4 )	// added 21 Aug 04, now annotating with special notes
    {
       strcpy( new_string, src );
    } // end if special use
    else
    {
       new_string[ 0 ] = 0;       // move over a bit if a received packet
       strcpy( new_string, rcvd ? "    " : nbuf );

       if( len )		 // called with zero len to clear screen
       {
           for( i = 0; i < len; i++ )
           {
              wsprintf( nbuf, "%02X", src[ i ] & 0xFF );
              if( i < ( len - 2 ) ) strcat( nbuf, " " );
              strcat( new_string, nbuf );
           } // end for
       } // end if some length

       if( src && ( src[ 1 ] == (char)RDR_CMD_TAG_DETECTED ) )
       {
          wsprintf( buf, "       #%04u", ++tag_rcvd_count );
          strcat( new_string, buf );
       } // end if a tag read
    } // end if a normal use (xmit or recvd packet, or clear()

    strcpy( rsbuf[ NUM_OF_DISP_LINES - 1 ], new_string );
    strcat( rsbuf[ NUM_OF_DISP_LINES - 1 ], "\r\n" );

    fsbuf[ 0 ] = 0;  for( i = 0; i < NUM_OF_DISP_LINES; i++ ) strcat( fsbuf, rsbuf[ i ] );
    //???update_show_screen = TRUE;
    in_bps = FALSE;

} // end build_diag_string()
/*-----------------------------------------------------------------------------
  31 Jan 03: used often, added the packet-ID and add-2-queue here 2 Jul 04
-----------------------------------------------------------------------------*/
void TProgStationForm::finish_the_packet(UINT *x, bool pid, bool add2q)
{
   if( pid )
      //???generate_crc( send_buf[ ++*x ] = rand() & 0x0FF );	// a "random" packet ID
      generate_crc((char)XBuf[++*x] = rand() & 0x0FF);	// a "random" packet ID
   //???send_buf[ ++*x ] = (char)(   crc        & 0x0FF ) ^ 0xFF;
   //???send_buf[ ++*x ] = (char)( ( crc >> 8 ) & 0x0FF ) ^ 0xFF;
   (char)XBuf[++*x] = (char)(crc & 0x0FF) ^ 0xFF;
   (char)XBuf[++*x] = (char)((crc >> 8) & 0x0FF) ^ 0xFF;
   if( add2q )
      add2_send_queue( *x + 1 );
} // end finish_the_packet()

void generate_crc(char ascii)
{
    unsigned char d, e, f, g, i;

    d = 0;
    e = (char)( crc & 0x0FF ) ^ ascii;

    for( i = 0; i < 8; i++ )
    {
       g   = d & 0x01;
       d >>= 1;
       d  &= 0x7F;

       f   = e & 0x01;
       e >>= 1;
       e  &= 0x7F;

       if( g )
         e |= 0x80;
       if( f )
       {
          d ^= CRC_MAGIC_HI;			// CRC-16 magic numbers
          e ^= CRC_MAGIC_LO;
       } // end if carry out of d
    } // end for
    e  ^=       (char)( ( crc >> 8 ) & 0x0FF );			// new CRC lo
    crc = (unsigned int)( ( d << 8 ) & 0xFF00 ) + (unsigned int)e;
} // end generate_crc()
void __fastcall TProgStationForm::DownloadRdrProcessCRadioButtonClick(
      TObject *Sender)
{
   bload_proc = 0;
   boot_proc_new = false;
   DownloadRdrFileNameLabel->Caption = "AWI501_C.BIN";
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::DownloadRdrProcessDRadioButtonClick(
      TObject *Sender)
{
   bload_proc = 1;
   boot_proc_new = true;
   DownloadRdrFileNameLabel->Caption = "AWI501_D.BIN";
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::DownloadRdrProcessERadioButtonClick(
      TObject *Sender)
{
   bload_proc = 2;
   boot_proc_new = false;
   DownloadRdrFileNameLabel->Caption = "AWI501_E.BIN";
}
//---------------------------------------------------------------------------
bool __fastcall TProgStationForm::IsDecryptFileOK(UINT p)
{
   AnsiString str;
   char *c;
   int index = -1;

   str = DownloadRdrFileNameEdit->Text;

   c = str.c_str();
   for (int i=0; i<str.Length(); i++)
   {
      if (*c == '\\')
         index = i;
      c++;
   }

   str = str.SubString (index+2, str.Length()-(index));
   str = str.SubString(str.Length()-5, str.Length());
   if (p == 0)  //c
   {
      if ((DownloadRdrFileNameEdit->Text.UpperCase() == "_C.BIN") ||
          (str.UpperCase() == "_C.BIN"))
         return (true);
      else
         return (false);

   }
   else if (p == 1)  //d
   {
       if ((DownloadRdrFileNameEdit->Text.UpperCase() == "_D.BIN") ||
           (str.UpperCase() == "_D.BIN"))
         return (true);
      else
         return (false);
   }
   else if (p == 2)  //e
   {
       if ((DownloadRdrFileNameEdit->Text.UpperCase() == "_E.BIN") ||
           (str.UpperCase() == "_E.BIN"))
         return (true);
      else
         return (false);
   }/*
   else if (p == 3)  //j
   {
       if ((DownloadRdrFileNameEdit->Text.UpperCase() == "AWI501_J.BIN") ||
           (str.UpperCase() == "AWI501_J.BIN"))
         return (true);
      else
         return (false);
   }
   else if (p == 4)  //k
   {
       if ((DownloadRdrFileNameEdit->Text.UpperCase() == "AWI501_K.BIN") ||
           (str.UpperCase() == "AWI501_K.BIN"))
         return (true);
      else
         return (false);
   }*/

   return (false);
}
AnsiString __fastcall TProgStationForm::IsEncryptFileOK(UINT p)
{
   AnsiString str;
   AnsiString fName;
   char *c;
   int index = -1;
   bool ret = false;

   str = EncryptFileNameEdit->Text;

   c = str.c_str();
   for (int i=0; i<str.Length(); i++)
   {
      if (*c == '\\')
         index = i;
      c++;
   }

   str = str.SubString (index+2, str.Length()-(index));

   if (p == 0)  //c
   {
      if ((EncryptFileNameEdit->Text.UpperCase() == "AWI501C.HEX") ||
          (str.UpperCase() == "AWI501C.HEX"))
      {
         ret = true;
      }
      else
         ret = false;

   }
   else if (p == 1)  //d
   {
       if ((EncryptFileNameEdit->Text.UpperCase() == "AWI501D.HEX") ||
           (str.UpperCase() == "AWI501D.HEX"))
         ret = true;
      else
         ret = false;
   }
   else if (p == 2)  //e
   {
       if ((EncryptFileNameEdit->Text.UpperCase() == "AWI501E.HEX") ||
           (str.UpperCase() == "AWI501E.HEX"))
         ret = true;
      else
         ret = false;
   }
   else if (p == 3)  //j
   {
       if ((EncryptFileNameEdit->Text.UpperCase() == "AWI501J.HEX") ||
           (str.UpperCase() == "AWI501J.HEX"))
         ret = true;
      else
         ret = false;
   }
   else   //k
   {
       if ((EncryptFileNameEdit->Text.UpperCase() == "AWI501K.HEX") ||
           (str.UpperCase() == "AWI501K.HEX"))
         ret = true;
      else
         ret = false;
   }

   if (ret)
      return(EncryptFileNameEdit->Text);
   else
      return(fName);
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::DownloadRdrBitBtnClick(TObject *Sender)
{
   if (!open_ctrl_file())
     return;

   bootloading = false;
   sendBootQuery = false;
   unsigned short pType;
   AnsiString str;
   int verC, verD, verE;

   verC = atoi(DownloadRdrPCVerLabel->Caption.c_str());
   verD = atoi(DownloadRdrPDVerLabel->Caption.c_str());
   verE = atoi(DownloadRdrPEVerLabel->Caption.c_str());

   if ((verC < 19) || (verD < 25) || (verE < 23))
   {
       str =  "ERROR: Can not download Reader Firware.\n";
       str += "Reader Boot Process versions must be equal or higher than follwing versions.\n";
       str += "\n";
       str += "Process C Version 19\n";
       str += "Process D Version 25\n";
       str += "Process E Version 23";
       Application->MessageBox(str.c_str(), "Download Error", MB_OK);
       return;
   }

   if (DownloadRdrFileNameEdit->Text.data() == NULL)
   {
       Application->MessageBox("Error: No BIN file", "Error", MB_OK);
       return;
   }

   if (DownloadRdrProcessCRadioButton->Checked)
   {
      if (!IsDecryptFileOK(0))
      {
        Application->MessageBox("Error: Wrong file for Process C", "Error", MB_OK);
        return;
      }

      pType = 0;
   }
   else if (DownloadRdrProcessDRadioButton->Checked)
   {
      if (!IsDecryptFileOK(1))
      {
        Application->MessageBox("Error: Wrong file for Process D", "Error", MB_OK);
        return;
      }

      pType = 1;
   }
   else if (DownloadRdrProcessERadioButton->Checked)
   {
      if (!IsDecryptFileOK(2))
      {
        Application->MessageBox("Error: Wrong file for Process E", "Error", MB_OK);
        return;
      }

      pType = 2;
   }

   unsigned short int rdr = (unsigned short int)atoi(DownloadRdrReaderComboBox->Text.c_str());
   if (rdr > 255)
      itsan_ext_reader = true;
   else
      itsan_ext_reader = false;
   host_id = atoi(DownloadRdrHostEdit->Text.c_str());
   rdrs[currnt_rdr].raddr = rdr;
   if (DownloadRdrProcessCRadioButton->Checked)
   {
      DownloadLabelC->Font->Color = clRed;
      DownloadLabelC->Caption = "Downloading";
   }
   else if (DownloadRdrProcessDRadioButton->Checked)
   {
      DownloadLabelD->Font->Color = clRed;
      DownloadLabelD->Caption = "Downloading";
   }
   else
   {
      DownloadLabelE->Font->Color = clRed;
      DownloadLabelE->Caption = "Downloading";
   }
   lastDownloadPkt = false;
   if (DecryptHexFile(pType, DownloadRdrFileNameEdit->Text))
      StartBootLoader();
}
//---------------------------------------------------------------------------
bool __fastcall TProgStationForm::WriteToRS232Port(unsigned int bytes)
{
    DWORD bytesSend;
    DWORD dwRes;
    AnsiString str;
    AnsiString str2;

    //if (XBuf[2] == 0x07)
       //lastPkt += 1;
    if (DownloadRdrTestCheckBox->Checked) // && !first_bload_cmd)
    {
      //////////////////////
      //for (int i=0; i<bytes; i++)
       //{
         // str2.Format("%02x", ((unsigned char)XBuf[i]));
         // str += str2;
         // str += ' ';
       //}
      //////////////////////

       for (unsigned int i=0; i<bytes; i++)
       {
          str += IntToHex(((int)(unsigned char)XBuf[i]), 2);
          str += ' ';
      }
      str += '\n';

       fwrite(str.c_str(), str.Length(), 1, wfPtr);
    }

    //for (int i=0; i<bytes; i++)
    {
        //if (!WriteFile(comPortID, &XBuf[i], 1, &bytesSend, &overlapRS232Write))
        if (!WriteFile(comPortID, &XBuf[0], bytes, &bytesSend, &overlapRS232Write))
        {
            if (GetLastError() != ERROR_IO_PENDING)
            {
               return (false);
            }
            else
            {
                dwRes = WaitForSingleObject(overlapRS232Write.hEvent, WRITE_TIMEOUT);
                switch (dwRes)
                {
                   case WAIT_OBJECT_0:
                   if(!GetOverlappedResult(comPortID, &overlapRS232Write, &bytesSend, true))
                      return (false);
                   break;

                   default:
                   break;

                 }//switch
             }
         }
         else //writrFile
            return (false);
    }//fo loop

    if (displayTx)
    {
       pktCounter++;
       DisplayTransmitPackets(XBuf, bytes, NULL);
    }
    return(true);
}
void __fastcall TProgStationForm::DownloadRdrBootQueryBitBtnClick(
      TObject *Sender)
{

   //DataCodeVerLabel->Caption = "";
   //ProgCodeVerLabel->Caption = "";
   //HostCodeVerLabel->Caption = "";

   DownloadRdrPCVerLabel->Caption = "";
   DownloadRdrPCDateLabel->Caption = "";

   DownloadRdrPDVerLabel->Caption = "";
   DownloadRdrPDDateLabel->Caption = "";

   DownloadRdrPEVerLabel->Caption = "";
   DownloadRdrPEDateLabel->Caption = "";

   TxClearTagCtrls();
   RxClearTagCtrls();
   StaticText->Caption = "";
   receivedResponse = false;

   if(networkOn)
   {
      int rdr = atoi(DownloadRdrReaderComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(BOOT_QUERY, 0, NULL, 0, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(BOOT_QUERY, 0, NULL, 0);
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::DisplayQueryBootData(UINT proc)
{
   char str[10];
   char str1[5];
   char c;
   UINT m, y;

   c = procs[ proc ].ucode_mnyr;
   m = ( ( c >> 4 ) & 0x0F ) - 1;
   y = 	c        & 0x0F;
   sprintf( str, "%02X %s %02d", procs[proc].ucode_day, mn[ m ], y );
   sprintf( str1, "%02d" , procs[proc].code_revsion & 0x0FF );

   if (proc == 0)
   {
      DownloadRdrPCDateLabel->Caption = str;
      DownloadRdrPCVerLabel->Caption = str1;
   }
   else if (proc == 1)
   {
      DownloadRdrPDDateLabel->Caption = str;
      DownloadRdrPDVerLabel->Caption = str1;
   }
   else if (proc == 2)
   {
      DownloadRdrPEDateLabel->Caption = str;
      DownloadRdrPEVerLabel->Caption = str1;
   }
}
//---------------------------------------------------------------------------
bool __fastcall TProgStationForm::open_ctrl_file(void)
{
    FILE *ocf_fpt;
    char buf[100];
    bool ret = false;

    //if( ( ocf_fpt = fopen( CTRL_FILE, "r" ) ) == NULL )
    if( ( ocf_fpt = fopen( "g:\\programming station\\debug\\bootldr.ctr", "r" ) ) == NULL )
    {
       wsprintf( buf, "..\\%s", CTRL_FILE );
       if( ( ocf_fpt = fopen( buf, "r" ) ) == NULL )
       {
           Application->MessageBox( "ERROR: Can't find the control file", MB_OK);
           abort_thread = 1;
           ret = false;
       }
    } // end if open of the control file failed
    else
    {
       while( fgets( fbuf, 90, ocf_fpt ) )
       {
          if( fbuf[ 0 ] != '*' ) fbuf[ 0 ] &= 0xDF;		// force upper case
          switch( fbuf[ 0 ] )
          {
             case '*':
             case LINE_FEED:
             case CARRIDGE_RETURN:
             case 'B':
             case 'C':
             case 'D':
             case 'F':
             case 'H':
                 break;

             case 'M':
                procs[ 0 ].max_cksm_loc = str2int( strtok( &fbuf[ 2 ], delim ) );
                procs[ 1 ].max_cksm_loc = str2int( strtok( NULL, delim ) );
                procs[ 2 ].max_cksm_loc = str2int( strtok( NULL, delim ) );
                procs[ 3 ].max_cksm_loc = str2int( strtok( NULL, delim ) );
                procs[ 4 ].max_cksm_loc = str2int( strtok( NULL, delim ) );
                procs[ 5 ].max_cksm_loc = str2int( strtok( NULL, delim ) );
                ret = true;
             break;

             case 'R':
                e16b_value = str2int( &fbuf[ 2 ] );
                ret = true;
             break;

             default:
                if( fbuf[ 0 ] == 0 )
                   fbuf[ 0 ] = '_';
                wsprintf( buf, "Unknown ID in Control File (%c)", fbuf[ 0 ] );
                Application->MessageBox(buf, MB_OK);
                ret = false;
             break;

          } // end switch

       } // end while

       fclose( ocf_fpt );

    } // end if opened fine

    return(ret);
} // end open_ctrl_file()


void __fastcall TProgStationForm::TimeTimer1Timer(TObject *Sender)
{
    TDateTime DateTime = Time();  // store the current date and time
   timeStr = TimeToStr(DateTime); // convert the time to a string
   MainStatusBar->Panels->Items[2]->Text = comStatusStr.c_str();
   MainStatusBar->Panels->Items[3]->Text = timeStr.c_str();

    if (displayElapsedTime)
    {
       elapsedTime += 1;
       AnsiString s = elapsedTime;
       s += "  sec";
       if (ReadMemoryGroupBox->Visible)
       {
          ReadTimeLabel->Caption = s;
          if (DisplayDataCheckBox->Checked && (largeDataDlg != NULL))
             largeDataDlg->UpdateElapsedTime(elapsedTime);
       }
       else
          WriteTimeLabel->Caption = s;
    }

   /*if (lastDownloadPkt)
   {
      lastDownloadPkt = false;

      if (bload_proc == 0)
          DownloadRdrProgressBarC->Position = numLines-1;
      else if (bload_proc == 1)
          DownloadRdrProgressBarD->Position = numLines-1;
      else if (bload_proc == 2)
          DownloadRdrProgressBarE->Position = numLines-1;

      if(networkOn)
      {
         int rdr = atoi(DownloadRdrReaderComboBox->Text.c_str());
         int index = GetSocketIndex(rdr);
         if (index >= 0)
         {
            WriteAWSocket(RESET_DEVICE, 0, NULL, 0, 'S', NULL, 0, index);
         }
         else
            StaticText->Caption = "No matching socket for the reader.";
      }
      else if (RS232On)
      {
         WriteRS232Comm(RESET_DEVICE, 0, NULL, 0);
      }
   }*/

   /*if (sendBootQuery && bootloading)
   {
      sendBootQuery = false;
      if(networkOn)
      {
         int rdr = atoi(DownloadRdrReaderComboBox->Text.c_str());
         int index = GetSocketIndex(rdr);
         if (index >= 0)
         {
            WriteAWSocket(BOOT_QUERY, 0, NULL, 0, 'S', NULL, 0, index);
         }
         else
            StaticText->Caption = "No matching socket for the reader.";
      }
      else if (RS232On)
      {
         WriteRS232Comm(BOOT_QUERY, 0, NULL, 0);
      }
   }*/
}
//---------------------------------------------------------------------------
int Encrypt(char *plaintext, int len, char *ciphertext, int method)
{
	int i, newlen;

			/* Seed random number generator */
	srand( (unsigned)time(NULL));
			/* Fill Initialization Vector with random data and copy
					it into the UDP payload */
	for (i = 0; i < 16; i++)
	    ive[i] = ciphertext[i] = rand();
			/* Add the data length to the payload */
	ciphertext[16] = len >> 8;
	ciphertext[17] = len & 0xff;
			/* Copy the plaintext into the payload because the
				encoder will perform the transformation in place */
	memcpy(&ciphertext[18], plaintext, len);
			/* Round up the length to a multiple of 16 (bytes per block) */
	newlen = ((len + 15) / 16) * 16;
			/* Pad blocks with random data */
	for (i = len; i < newlen; i++)
		ciphertext[i+18] = rand();
			/* CBC encrypt */
	blockEncrypt(ive, shared_key, newlen, &ciphertext[18], (method - 1));
			/* Return the payload length */
	return(newlen + 18);
}

int Decrypt(char *ciphertext, int len, char *plaintext, int method)
{
	int dlen;

			/* Do we have the Initialization Vector and length? */
	if (len < 18) return (0);
			/* Extract the payload Initialization Vector */
	memcpy(ivd, ciphertext, 16);
			/* Extract the payload data length */
	dlen = (((ciphertext[16] << 8) + ciphertext[17] + 15) / 16) * 16;
			/* Do we have a complete payload? */
	if (len < (dlen + 18)) return (0);
			/* Extract the payload real data length */
	len = (ciphertext[16] << 8) + ciphertext[17];
			/* Extract the ciphertext into the destination array because the
				decoder will perform the transformation in place */
	memcpy(plaintext, &ciphertext[18], dlen);
			/* Decrypt it by negating the encrypted data length */
	blockEncrypt(ivd, shared_key, -dlen, plaintext, (method - 1));
			/* Return the length of the real decrypted data */
	return(len);
}

void __fastcall TProgStationForm::EncryptHexFile(unsigned short pType, AnsiString fileName, int ver)
{
    AnsiString str = "AWI_V";
    char file_name1[32];
    char file_name2[32];
    char buf[100];
    char szDataIn1[49];
    char szDataIn[49];
    char szDataOut[49];
    char szHex[100];
    char end[1] = {'\n'};
    FILE* fp1;
    FILE* fp2;

    //if(( fp1 = fopen( "AWI501C.HEX", "r" )) == NULL )
    if(( fp1 = fopen( fileName.c_str(), "r" )) == NULL )
    {
       wsprintf( buf, "Opening the hex File (\"%s\") failed.", fileName.c_str() );
       Application->MessageBox(buf, MB_OK);
       return;
    }

    str += ver;

    if (pType == 0)
    {
       str += "_C.BIN";
       //if(( fp2 = fopen( "AWI501_C.BIN", "w" )) == NULL )
       if(( fp2 = fopen( str.c_str(), "w" )) == NULL )
       {
          //wsprintf( buf, "Opening the File (\"%s\") failed.", "AWI501_C.BIN" );
          wsprintf( buf, "Opening the File (\"%s\") failed.", str.c_str());
          Application->MessageBox(buf, MB_OK);
          return;
       }
       else
       {
           EncryptStatusCLabel->Caption = "";
           EncryptFNameCLabel->Caption = "";
           EncryptFNameCLabel->Visible = false;
       }
    }
    else if (pType == 1)
    {
       str += "_D.BIN";
       if(( fp2 = fopen( str.c_str(), "w" )) == NULL )
       {
          wsprintf( buf, "Opening the File (\"%s\") failed.", str.c_str());
          Application->MessageBox(buf, MB_OK);
          return;
       }
       else
       {
           EncryptStatusDLabel->Caption = "";
           EncryptFNameDLabel->Caption = "";
           EncryptFNameDLabel->Visible = false;
       }
    }
    else if (pType == 2)
    {
       str += "_E.BIN";
       if(( fp2 = fopen(str.c_str(), "w" )) == NULL )
       {
          wsprintf( buf, "Opening the File (\"%s\") failed.", str.c_str());
          Application->MessageBox(buf, MB_OK);
          return;
       }
       else
       {
           EncryptStatusELabel->Caption = "";
           EncryptFNameELabel->Caption = "";
           EncryptFNameELabel->Visible = false;
       }
    }
    else if (pType == 3)
    {
       str += "_J.BIN";
       if(( fp2 = fopen(str.c_str(), "w" )) == NULL )
       {
          wsprintf( buf, "Opening the File (\"%s\") failed.", str.c_str());
          Application->MessageBox(buf, MB_OK);
          return;
       }
       else
       {
           EncryptStatusJLabel->Caption = "";
           EncryptFNameJLabel->Caption = "";
           EncryptFNameJLabel->Visible = false;
       }
    }
    else if (pType == 4)
    {
       str += "_K.BIN";
       if(( fp2 = fopen(str.c_str(), "w" )) == NULL )
       {
          wsprintf( buf, "Opening the File (\"%s\") failed.", str.c_str());
          Application->MessageBox(buf, MB_OK);
          return;
       }
       else
       {
           EncryptStatusKLabel->Caption = "";
           EncryptFNameKLabel->Caption = "";
           EncryptFNameKLabel->Visible = false;
       }
    }

    CRijndael oRijndael;
    oRijndael.MakeKey("052457AWI-Boca99", CRijndael::sm_chain0, 16, 16);

    memset(szDataIn, 0, 49);
    memset(szDataIn1, 0, 49);
    memset(szDataOut, 0, 49);
    memset(szHex, 0, 100);

    while (fgets(szDataIn1, 48, fp1))
    {
       strcpy(szDataIn, szDataIn1);
       oRijndael.Encrypt(szDataIn, szDataOut, 48, CRijndael::ECB);
       CharStr2HexStr((unsigned char*)szDataOut, szHex, 48);

       fwrite(szHex, 96, 1, fp2);
       fwrite(end, 1, 1, fp2);

       memset(szDataIn1, 0, 49);
       memset(szDataIn, 0, 49);
       memset(szDataOut, 0, 49);
       memset(szHex, 0, 100);
    }
    fclose(fp1);
    fclose(fp2);

    if (pType == 0)
    {
       EncryptStatusCLabel->Font->Color = clGreen;
       EncryptStatusCLabel->Caption = "Completed.";
       EncryptFNameCLabel->Caption = str;
       EncryptFNameCLabel->Visible = true;
       StaticText->Caption = "File: awi501c.hex was encrypted successfully";
    }
    if (pType == 1)
    {
       EncryptStatusDLabel->Font->Color = clGreen;
       EncryptStatusDLabel->Caption = "Completed.";
       EncryptFNameDLabel->Caption = str;
       EncryptFNameDLabel->Visible = true;
       StaticText->Caption = "File: awi501d.hex was encrypted successfully";
    }
    if (pType == 2)
    {
       EncryptStatusELabel->Font->Color = clGreen;
       EncryptStatusELabel->Caption = "Completed.";
       EncryptFNameELabel->Caption = str;
       EncryptFNameELabel->Visible = true;
       StaticText->Caption = "File: awi501e.hex was encrypted successfully";
    }
    if (pType == 3)
    {
       EncryptStatusJLabel->Font->Color = clGreen;
       EncryptStatusJLabel->Caption = "Completed.";
       EncryptFNameJLabel->Caption = str;
       EncryptFNameJLabel->Visible = true;
       StaticText->Caption = "File: awi501j.hex was encrypted successfully";
    }
    if (pType == 4)
    {
       EncryptStatusKLabel->Font->Color = clGreen;
       EncryptStatusKLabel->Caption = "Completed.";
       EncryptFNameKLabel->Caption = str;
       EncryptFNameKLabel->Visible = true;
       StaticText->Caption = "File: awi501k.hex was encrypted successfully";
    }
}

bool __fastcall TProgStationForm::DecryptHexFile(unsigned short pType, AnsiString fileName)
{
    ///////////////////////////////////////////////////////////////////////////
    char file_name1[32];
    char file_name2[32];
    char buf[100];
    char szDataIn1[49];
    char szDataIn[49];
    char szDataOut[49];
    char szHex[100];
    char szChar[100];
    char end[1] = {'\n'};
    char ct[2] = {'\0', '\0'};
    int i, j, len;
    FILE* fp1;

    //if(( fp1 = fopen( "AWI501C.HEX", "r" )) == NULL )
    if(( fp1 = fopen( fileName.c_str(), "r" )) == NULL )
    {
       wsprintf( buf, "Opening the hex File (\"%s\") failed.", fileName.c_str());
       Application->MessageBox(buf, MB_OK);
       return (false);
    }

    CRijndael oRijndael;
    oRijndael.MakeKey("052457AWI-Boca99", CRijndael::sm_chain0, 16, 16);

    memset(szDataIn, 0, 100);
    memset(szDataOut, 0, 100);
    memset(szChar, 0, 100);
    encIndex = 0;
    for (i=0; i<MAX_ENCRYPT_SIZE; i++)
    {
       for (j=0; j<50; j++)
          encryptBuf[i][j] = '\0';
    }

    while (fgets(szDataIn, 100, fp1))
    {
       HexStr2CharStr(szDataIn, szChar, 48);
       oRijndael.Decrypt(szChar, szDataOut, 48, CRijndael::ECB);
       ct[0] = szDataOut[1];
       ct[1] = szDataOut[2];
       len = (HexToInt(ct, 2) + 6) * 2;
       for(i=0; i<len; i++)
          encryptBuf[encIndex][i] = szDataOut[i];
       encIndex += 1;

       memset(szDataIn, 0, 100);
       memset(szDataOut, 0, 100);
       memset(szChar, 0, 100);
    }

    fclose(fp1);
    return (true);


    /*if (pType == 0)
    {
       if(( fp2 = fopen( "AWI501I_C.BIN", "w" )) == NULL )
       {
          wsprintf( buf, "Opening the File (\"%s\") failed.", "AWI501I_C.BIN" );
          Application->MessageBox(buf, MB_OK);
          return;
       }
       else
       {
           EncryptStatusCLabel->Caption = "";
           EncryptFNameCLabel->Visible = false;
       }
    }
    else if (pType == 1)
    {
       if(( fp2 = fopen( "AWI501I_D.BIN", "w" )) == NULL )
       {
          wsprintf( buf, "Opening the File (\"%s\") failed.", "AWI501I_D.BIN" );
          Application->MessageBox(buf, MB_OK);
          return;
       }
       else
       {
           EncryptStatusDLabel->Caption = "";
           EncryptFNameDLabel->Visible = false;
       }
    }
    else if (pType == 2)
    {
       if(( fp2 = fopen( "AWI501I_E.BIN", "w" )) == NULL )
       {
          wsprintf( buf, "Opening the File (\"%s\") failed.", "AWI501I_E.BIN" );
          Application->MessageBox(buf, MB_OK);
          return;
       }
       else
       {
           EncryptStatusELabel->Caption = "";
           EncryptFNameELabel->Visible = false;
       }
    }
    else if (pType == 3)
    {
       if(( fp2 = fopen( "AWI501I_J.BIN", "w" )) == NULL )
       {
          wsprintf( buf, "Opening the File (\"%s\") failed.", "AWI501I_J.BIN" );
          Application->MessageBox(buf, MB_OK);
          return;
       }
       else
       {
           EncryptStatusJLabel->Caption = "";
           EncryptFNameJLabel->Visible = false;
       }
    }
    else if (pType == 4)
    {
       if(( fp2 = fopen( "AWI501I_K.BIN", "w" )) == NULL )
       {
          wsprintf( buf, "Opening the File (\"%s\") failed.", "AWI501I_K.BIN" );
          Application->MessageBox(buf, MB_OK);
          return;
       }
       else
       {
           EncryptStatusKLabel->Caption = "";
           EncryptFNameKLabel->Visible = false;
       }
    }*/

    /*CRijndael oRijndael;
    oRijndael.MakeKey("052457AWI-Boca99", CRijndael::sm_chain0, 16, 16);

    memset(szDataIn, 0, 49);
    memset(szDataIn1, 0, 49);
    memset(szDataOut, 0, 49);
    memset(szHex, 0, 100);

    while (fgets(szDataIn1, 48, fp1))
    {
       strcpy(szDataIn, szDataIn1);
       oRijndael.Encrypt(szDataIn, szDataOut, 48, CRijndael::ECB);
       CharStr2HexStr((unsigned char*)szDataOut, szHex, 48);

       fwrite(szHex, 96, 1, fp2);
       fwrite(end, 1, 1, fp2);

       memset(szDataIn1, 0, 49);
       memset(szDataIn, 0, 49);
       memset(szDataOut, 0, 49);
       memset(szHex, 0, 100);
    }
    fclose(fp1);
    fclose(fp2);

    if (pType == 0)
    {
       EncryptStatusCLabel->Font->Color = clGreen;
       EncryptStatusCLabel->Caption = "Completed.";
       EncryptFNameCLabel->Visible = true;
       StaticText->Caption = "File: awi501c.hex was encrypted successfully";
    }
    if (pType == 1)
    {
       EncryptStatusDLabel->Font->Color = clGreen;
       EncryptStatusDLabel->Caption = "Completed.";
       EncryptFNameDLabel->Visible = true;
       StaticText->Caption = "File: awi501d.hex was encrypted successfully";
    }
    if (pType == 2)
    {
       EncryptStatusELabel->Font->Color = clGreen;
       EncryptStatusELabel->Caption = "Completed.";
       EncryptFNameELabel->Visible = true;
       StaticText->Caption = "File: awi501e.hex was encrypted successfully";
    }
    if (pType == 3)
    {
       EncryptStatusJLabel->Font->Color = clGreen;
       EncryptStatusJLabel->Caption = "Completed.";
       EncryptFNameJLabel->Visible = true;
       StaticText->Caption = "File: awi501j.hex was encrypted successfully";
    }
    if (pType == 4)
    {
       EncryptStatusKLabel->Font->Color = clGreen;
       EncryptStatusKLabel->Caption = "Completed.";
       EncryptFNameKLabel->Visible = true;
       StaticText->Caption = "File: awi501k.hex was encrypted successfully";
    }
    ////////////////////////////////////////////////////////////////////////////

    char  file_name1[32];
    char  file_name2[32];
    char buf[128];
    char ct[2] = {'\0', '\0'};
    char end[1] = {'\n'};
    char szDataIn[100];
    char szDataOut[100];
    char szChar[100];
    int len;
    FILE* fp1;
    FILE* fp2;

    if(( fp1 = fopen( "AWI501I_C.HEX", "r" )) == NULL )
    {
       wsprintf( buf, "Opening the hex File (\"%s\") failed.", "AWI501I_C.HEX" );
       Application->MessageBox(buf, MB_OK);
       return;
    }

    if(( fp2 = fopen( "AWI501_C.HEX", "w" )) == NULL )
    {
       wsprintf( buf, "Opening the File (\"%s\") failed.", "AWI501_C.HEX" );
       Application->MessageBox(buf, MB_OK);
       return;
    }

    CRijndael oRijndael;
    oRijndael.MakeKey("052457AWI-Boca99", CRijndael::sm_chain0, 16, 16);

    memset(szDataIn, 0, 100);
    memset(szDataOut, 0, 100);
    memset(szChar, 0, 100);

    while (fgets(szDataIn, 100, fp1))
    {
       HexStr2CharStr(szDataIn, szChar, 48);
       oRijndael.Decrypt(szChar, szDataOut, 48, CRijndael::ECB);
       ct[0] = szDataOut[1];
       ct[1] = szDataOut[2];
       len = (HexToInt(ct, 2) + 6) * 2;
       fwrite(szDataOut, len, 1, fp2);

       memset(szDataIn, 0, 100);
       memset(szDataOut, 0, 100);
       memset(szChar, 0, 100);
    }

    fclose(fp1);
    fclose(fp2); */
}
//Function to convert string of length 2 to unsigned char
void TProgStationForm::Hex2Char(char const* szHex, unsigned char& rch)
{
   rch = 0;
   for(int i=0; i<2; i++)
   {
      if(*(szHex + i) >='0' && *(szHex + i) <= '9')
         rch = (rch << 4) + (*(szHex + i) - '0');
      else if(*(szHex + i) >='A' && *(szHex + i) <= 'F')
         rch = (rch << 4) + (*(szHex + i) - 'A' + 10);
      else
        break;
   }
}

//Function to convert string of unsigned chars to string of chars
void TProgStationForm::CharStr2HexStr(unsigned char const* pucCharStr, char* pszHexStr, int iSize)
{
   int i;
   char szHex[3];
   pszHexStr[0] = 0;
   for(i=0; i<iSize; i++)
   {
     Char2Hex(pucCharStr[i], szHex);
     strcat(pszHexStr, szHex);
   }
}

//Function to convert unsigned char to string of length 2
void TProgStationForm::Char2Hex(unsigned char ch, char* szHex)
{
  unsigned char byte[2];
  byte[0] = ch/16;
  byte[1] = ch%16;
  for(int i=0; i<2; i++)
  {
     if (byte[i] <= 9)
       szHex[i] = '0' + byte[i];
     else
       szHex[i] = 'A' + byte[i] - 10;
  }
  szHex[2] = 0;
}

//Function to convert string of chars to string of unsigned chars
void TProgStationForm::HexStr2CharStr(char const* pszHexStr, unsigned char* pucCharStr, int iSize)
{
   int i;
   unsigned char ch;
   for(i=0; i<iSize; i++)
   {
     Hex2Char(pszHexStr+2*i, ch);
     pucCharStr[i] = ch;
   }
}
void __fastcall TProgStationForm::EncryptPCRadioButtonClick(
      TObject *Sender)
{
    EncryptFileNameLabel->Caption = "awi501c.Hex ";
    DownloadRdrOpenDialog->Filter = "awi501c.Hex|*.HEX";
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::EncryptPDRadioButtonClick(
      TObject *Sender)
{
   EncryptFileNameLabel->Caption = "awi501d.Hex ";
   DownloadRdrOpenDialog->Filter = "awi501d.Hex|*.HEX";
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::EncryptPERadioButtonClick(
      TObject *Sender)
{
   EncryptFileNameLabel->Caption = "awi501e.Hex ";
   DownloadRdrOpenDialog->Filter = "awi501e.Hex|*.HEX";
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::EncryptPJRadioButtonClick(
      TObject *Sender)
{
   EncryptFileNameLabel->Caption = "awi501j.Hex ";
   DownloadRdrOpenDialog->Filter = "awi501j.Hex|*.HEX";
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::EncryptPKRadioButtonClick(
      TObject *Sender)
{
   EncryptFileNameLabel->Caption = "awi501k.Hex ";
   DownloadRdrOpenDialog->Filter = "awi501k.Hex|*.HEX";
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::EncryptGetFileBitBtnClick(
      TObject *Sender)
{
    DownloadRdrOpenDialog->Execute();
    EncryptFileNameEdit->Text = DownloadRdrOpenDialog->FileName;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::EncryptClearBitBtnClick(TObject *Sender)
{
    EncryptStatusCLabel->Font->Color = clBlue;
    EncryptStatusDLabel->Font->Color = clBlue;
    EncryptStatusELabel->Font->Color = clBlue;
    EncryptStatusJLabel->Font->Color = clBlue;
    EncryptStatusKLabel->Font->Color = clBlue;

    EncryptStatusCLabel->Caption = "Not Done ";
    EncryptStatusDLabel->Caption = "Not Done ";
    EncryptStatusELabel->Caption = "Not Done ";
    EncryptStatusJLabel->Caption = "Not Done ";
    EncryptStatusKLabel->Caption = "Not Done ";

    EncryptFNameCLabel->Visible = false;
    EncryptFNameDLabel->Visible = false;
    EncryptFNameELabel->Visible = false;
    EncryptFNameJLabel->Visible = false;
    EncryptFNameKLabel->Visible = false;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::EncryptToolButtonClick(TObject *Sender)
{
   if (!EncryptGroupBox->Visible)
   {
      EncryptGroupBox->Visible = true;
      TagTempListGroupBox->Visible = false;
      TagDetectedGroupBox->Visible = true;

      ResetReaderGroupBox->Visible = false;
      EnableReaderGroupBox->Visible = false;
      DisableReaderGroupBox->Visible = false;
      QueryReaderGroupBox->Visible = false;
      AssignReaderGroupBox->Visible = false;
      ReaderCodeVerGroupBox->Visible = false;
      DownloadRdrGroupBox->Visible = false;
      EnableFGenGroupBox->Visible = false;
      SetFStrengthGroupBox->Visible = false;
      RelayGroupBox->Visible = false;
      InputGroupBox->Visible = false;
      ConfigFGenGroupBox->Visible = false;
      ConfigSFGenGroupBox->Visible = false;
      QueryFGenGroupBox->Visible = false;
      QuerySFGenGroupBox->Visible = false;
      SmartFGenGroupBox->Visible = false;
      FGenResetGroupBox->Visible = false;
      ConfigReaderTxTimeGroupBox->Visible = false;
      AssignTagReaderGroupBox->Visible = false;
      ConfigTagRandGroupBox->Visible = false;
      ConfigTagGroupBox->Visible = false;
      EnableTagGroupBox->Visible = false;
      DisableTagGroupBox->Visible = false;
      QueryTagGroupBox->Visible = false;
      CallTagGroupBox->Visible = false;
      WriteMemoryGroupBox->Visible = false;
      ReadMemoryGroupBox->Visible = false;
      TagTempGroupBox->Visible = false;
      ConfigTagLEDGroupBox->Visible = false;
   }

   ResetReaderStaticText->Visible = true;
   EnableReaderStaticText->Visible = true;
   DisableReaderStaticText->Visible = true;
   QueryReaderStaticText->Visible = true;
   AssignReaderStaticText->Visible = true;
   ReaderVersionStaticText->Visible = true;
   //EnableRdrFGenStaticText->Visible = true;
   SetFStrengthStaticText->Visible = true;
   DownloadRdrStaticText->Visible = true;
   RelayStaticText->Visible = true;
   InputsStaticText->Visible = true;
   ConfigFGenStaticText->Visible = true;
   QueryFGenStaticText->Visible = true;
   QuerySFGenStaticText->Visible = true;
   SmartFGenStaticText->Visible = true;
   ConfigSFGenStaticText->Visible = true;
   FGenResetStaticText->Visible = true;
   ConfigTagStaticText->Visible = true;
   EnableTagStaticText->Visible = true;
   DisableTagStaticText->Visible = true;
   QueryTagStaticText->Visible = true;
   CallTagStaticText->Visible = true;
   AssignTagRdrStaticText->Visible = true;
   ConfigTagRNDStaticText->Visible = true;
   WriteMemoryStaticText->Visible = true;
   ReadMemoryStaticText->Visible = true;
   TagTempStaticText->Visible = true;
   ConfigTagLEDStaticText->Visible = true;

   ResetDeviceBitBtn->Visible = false;
   EnableReaderBitBtn->Visible = false;
   DisableReaderBitBtn->Visible = false;
   QueryReaderBitBtn->Visible = false;
   AssignReaderBitBtn->Visible = false;
   SetFStrengthBitBtn->Visible = false;
   DownloadRdrBitBtn->Visible = false;
   ReaderVersion->Visible = false;
   //EnableFGenBitBtn->Visible = false;
   ConfigTxTimeBitBtn->Visible = false;
   ConfigFGenBitBtn->Visible = false;
   QueryFGenBitBtn->Visible = false;
   QuerySFGenBitBtn->Visible = false;
   ConfigSFGenBitBtn->Visible = false;
   SmartFGenBitBtn->Visible = false;
   FGenResetBitBtn->Visible = false;
   RelayBitBtn->Visible = false;
   InputsBitBtn->Visible = false;
   ConfigTagBitBtn->Visible = false;
   EnableTagBitBtn->Visible = false;
   DisableTagBitBtn->Visible = false;
   QueryTagBitBtn->Visible = false;
   CallTagBitBtn->Visible = false;
   AssignTagRdrBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   ConfigTagRNDBitBtn->Visible = false;
   WriteMemoryBitBtn->Visible = false;
   ReadMemoryBitBtn->Visible = false;
   TagTempBitBtn->Visible = false;
   ConfigTagLEDBitBtn->Visible = false;

   ResetDeviceBitBtn->Enabled = true;
   EnableReaderBitBtn->Enabled = true;
   DisableReaderBitBtn->Enabled = true;
   QueryReaderBitBtn->Enabled = true;
   AssignReaderBitBtn->Enabled = true;
   ReaderVersion->Enabled = true;
   //EnableFGenBitBtn->Enabled = true;
   DownloadRdrBitBtn->Enabled = true;
   ConfigTxTimeBitBtn->Enabled = true;
   ConfigFGenBitBtn->Enabled = true;
   QueryFGenBitBtn->Enabled = true;
   FGenResetBitBtn->Enabled = true;
   SmartFGenBitBtn->Enabled = true;
   RelayBitBtn->Enabled = true;
   ConfigTagBitBtn->Enabled = true;
   EnableTagBitBtn->Enabled = true;
   DisableTagBitBtn->Enabled = true;
   QueryTagBitBtn->Enabled = true;
   CallTagBitBtn->Enabled = true;
   AssignTagRdrBitBtn->Enabled = true;
   ConfigTagRNDBitBtn->Enabled = true;
   WriteMemoryBitBtn->Enabled = true;
   ReadMemoryBitBtn->Enabled = true;
   TagTempBitBtn->Enabled = true;

   ResetDeviceBitBtn->Font->Color = clNavy;
   EnableReaderBitBtn->Font->Color = clNavy;
   DisableReaderBitBtn->Font->Color = clNavy;
   QueryReaderBitBtn->Font->Color = clNavy;
   AssignReaderBitBtn->Font->Color = clNavy;
   ReaderVersion->Font->Color = clNavy;
   DownloadRdrBitBtn->Font->Color = clNavy;
   ConfigTxTimeBitBtn->Font->Color = clNavy;
   ConfigFGenBitBtn->Font->Color = clPurple;
   QueryFGenBitBtn->Font->Color = clPurple;
   RelayBitBtn->Font->Color = clPurple;
   ConfigTagBitBtn->Font->Color = clTeal;
   EnableTagBitBtn->Font->Color = clTeal;
   DisableTagBitBtn->Font->Color = clTeal;
   QueryTagBitBtn->Font->Color = clTeal;
   CallTagBitBtn->Font->Color = clTeal;
   AssignTagRdrBitBtn->Font->Color = clTeal;
   ConfigTagRNDBitBtn->Font->Color = clTeal;
   WriteMemoryBitBtn->Font->Color = clTeal;
   ReadMemoryBitBtn->Font->Color = clTeal;
   TagTempBitBtn->Font->Color = clTeal;

   TxClearTagCtrls();
   RxClearTagCtrls();

   if (EncryptPCRadioButton->Checked)
      DownloadRdrOpenDialog->Filter = "awi501c.Hex|*.HEX";
   else if (EncryptPDRadioButton->Checked)
      DownloadRdrOpenDialog->Filter = "awi501d.Hex|*.HEX";
   else if (EncryptPERadioButton->Checked)
      DownloadRdrOpenDialog->Filter = "awi501e.Hex|*.HEX";
   else if (EncryptPJRadioButton->Checked)
      DownloadRdrOpenDialog->Filter = "awi501j.Hex|*.HEX";
   else
      DownloadRdrOpenDialog->Filter = "awi501k.Hex|*.HEX";
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::EncryptBitBtnClick(TObject *Sender)
{
   AnsiString fName;
   int ver;

   if (EncryptPCRadioButton->Checked)
   {
       if (EncryptPCVerEdit->Text.data() == NULL)
       {
          Application->MessageBox("Error: No Version Number!",
                                   "Programming Station Information Dialog",
                                   MB_OK | MB_ICONSTOP | MB_TOPMOST);
           return;
       }

       fName = IsEncryptFileOK(0);
       if (fName.data() == NULL)
       {
           Application->MessageBox("Error: Wrong File Name!",
                                   "Programming Station Information Dialog",
                                   MB_OK | MB_ICONSTOP | MB_TOPMOST);
           return;
       }
       ver = atoi(EncryptPCVerEdit->Text.c_str());
       EncryptHexFile(0, fName, ver);
   }
   else if (EncryptPDRadioButton->Checked)
   {
       if (EncryptPDVerEdit->Text.data() == NULL)
       {
          Application->MessageBox("Error: No Version Number!",
                                   "Programming Station Information Dialog",
                                   MB_OK | MB_ICONSTOP | MB_TOPMOST);
           return;
       }

       fName = IsEncryptFileOK(1);
       if (fName.data() == NULL)
       {
           Application->MessageBox("Error: Wrong File Name!",
                                   "Programming Station Information Dialog",
                                   MB_OK | MB_ICONSTOP | MB_TOPMOST);
           return;
       }
       ver = atoi(EncryptPDVerEdit->Text.c_str());
       EncryptHexFile(1, fName, ver);
   }
   else if (EncryptPERadioButton->Checked)
   {
       if (EncryptPEVerEdit->Text.data() == NULL)
       {
          Application->MessageBox("Error: No Version Number!",
                                   "Programming Station Information Dialog",
                                   MB_OK | MB_ICONSTOP | MB_TOPMOST);
           return;
       }

       fName = IsEncryptFileOK(2);
       if (fName.data() == NULL)
       {
           Application->MessageBox("Error: Wrong File Name!",
                                   "Programming Station Information Dialog",
                                   MB_OK | MB_ICONSTOP | MB_TOPMOST);
           return;
       }
       ver = atoi(EncryptPEVerEdit->Text.c_str());
       EncryptHexFile(2, fName, ver);
   }
   else if (EncryptPJRadioButton->Checked)
   {
       if (EncryptPJVerEdit->Text.data() == NULL)
       {
          Application->MessageBox("Error: No Version Number!",
                                   "Programming Station Information Dialog",
                                   MB_OK | MB_ICONSTOP | MB_TOPMOST);
           return;
       }

       fName = IsEncryptFileOK(3);
       if (fName.data() == NULL)
       {
           Application->MessageBox("Error: Wrong File Name!",
                                   "Programming Station Information Dialog",
                                   MB_OK | MB_ICONSTOP | MB_TOPMOST);
           return;
       }
       ver = atoi(EncryptPJVerEdit->Text.c_str());
       EncryptHexFile(3, fName, ver);
   }
   else if (EncryptPKRadioButton->Checked)
   {
       if (EncryptPKVerEdit->Text.data() == NULL)
       {
          Application->MessageBox("Error: No Version Number!",
                                   "Programming Station Information Dialog",
                                   MB_OK | MB_ICONSTOP | MB_TOPMOST);
           return;
       }

       fName = IsEncryptFileOK(4);
       if (fName.data() == NULL)
       {
           Application->MessageBox("Error: Wrong File Name!",
                                   "Programming Station Information Dialog",
                                   MB_OK | MB_ICONSTOP | MB_TOPMOST);
           return;
       }
       ver = atoi(EncryptPKVerEdit->Text.c_str());
       EncryptHexFile(4, fName, ver);
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::DownloadSFGenGetFileBitBtnClick(
      TObject *Sender)
{
    if (DownloadSFGenProcessJRadioButton->Checked)
      DownloadRdrOpenDialog->Filter = "awi501_J.BIN|*.BIN";
    else
      DownloadRdrOpenDialog->Filter = "awi501_K.BIN|*.BIN";

    DownloadRdrOpenDialog->Execute();
    DownloadSFGenFileNameEdit->Text = DownloadRdrOpenDialog->FileName;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::DownloadSFGenBitBtnClick(TObject *Sender)
{
   return;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::AssignReaderModifyTXCheckBoxClick(
      TObject *Sender)
{
    if (AssignReaderModifyTXCheckBox->State == cbChecked)
    {
       AssignReaderTXComboBox->Enabled = true;
       AssignReaderSetConfigBitBtn->Enabled = true;
    }
    else
    {
       AssignReaderTXComboBox->Enabled = false;
       AssignReaderSetConfigBitBtn->Enabled = false;
    }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::AssignReaderModifyWTCheckBoxClick(
      TObject *Sender)
{
   if (AssignReaderModifyWTCheckBox->State == cbChecked)
   {
      AssignReaderWTSecRadioButton->Enabled = true;
      AssignReaderWTHourRadioButton->Enabled = true;
      AssignReaderWTMinRadioButton->Enabled = true;
      AssignReaderSetConfigBitBtn->Enabled = true;
      AssignReaderWTComboBox->Enabled = true;
   }
   else
   {
      AssignReaderWTSecRadioButton->Enabled = false;
      AssignReaderWTHourRadioButton->Enabled = false;
      AssignReaderWTMinRadioButton->Enabled = false;
      AssignReaderSetConfigBitBtn->Enabled = false;
      AssignReaderWTComboBox->Enabled = false;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::AssignReaderModifyMDCheckBoxClick(
      TObject *Sender)
{
    if (AssignReaderModifyMDCheckBox->State == cbChecked)
    {
       AssignReaderEnableMDCheckBox->Enabled = true;
       AssignReaderMDActiveHiRadioButton->Enabled = true;
       AssignReaderMDActiveLoRadioButton->Enabled = true;
       AssignReaderSetConfigBitBtn->Enabled = true;
    }
    else
    {
       AssignReaderEnableMDCheckBox->Enabled = false;
       AssignReaderMDActiveHiRadioButton->Enabled = false;
       AssignReaderMDActiveLoRadioButton->Enabled = false;
       AssignReaderSetConfigBitBtn->Enabled = false;
    }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::AssignReaderGetConfigBitBtnClick(
      TObject *Sender)
{
   TxClearTagCtrls();
   RxClearTagCtrls();
   AssignReaderListView->Items->Clear();

   StaticText->Caption = "";
   receivedResponse = false;

   //CMDEnableTimer->Enabled = true;
   //DisableSmartFGenStaticCommands();
   //QuerySFGenBitBtn->Enabled = false;

   //if (lastReaderID > 0)
   if (AssignReaderIDComboBox->Text.data() == NULL)
      AssignReaderIDComboBox->Text = lastReaderID;
   for (unsigned int i=0; i<numReaderIDList; i++)
   {
      if (AssignReaderIDComboBox->Items->IndexOf(readerIDList[i]) == -1 )
         AssignReaderIDComboBox->Items->Add(readerIDList[i]);
   }

   if (allHostID)
   {
      if (lastHostID > 0)
         AssignReaderHostIDEdit->Text = lastHostID;
   }
   else
      AssignReaderHostIDEdit->Text = sysHostID;

   AssignReaderTXComboBox->Text = "";
   AssignReaderWTComboBox->Text = "";
   AssignReaderWTSecRadioButton->Checked = false;
   AssignReaderWTHourRadioButton->Checked = false;
   AssignReaderWTMinRadioButton->Checked = false;
   AssignReaderEnableMDCheckBox->Checked = false;
   AssignReaderMDActiveHiRadioButton->Checked = false;
   AssignReaderMDActiveLoRadioButton->Checked = false;
   AssignReaderBroadcastCheckBox->Checked = false;
   AssignReaderEnableCheckBox->Checked = false;
   AssignReaderRSSICheckBox->Checked = false;

   if(networkOn)
   {
      int rdr = atoi(AssignReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(QUERY_READER, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(QUERY_READER, 0, NULL, 0);
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::AssignReaderListViewDblClick(
      TObject *Sender)
{
   TListItem* item = AssignReaderListView->Selected;
   TStrings* str;
   AnsiString selectedTypeStr;
   unsigned short selectedTypeInt;

   if (item)
   {
      str = item->SubItems;
      AnsiString s;
      AnsiString s1;
      AssignReaderIDComboBox->Text = GetItem(str, 0);  //reader ID
      AssignReaderHostIDEdit->Text = GetItem(str, 1);  //host ID
      s = GetItem(str, 2);
      s.SetLength(s.Length() - 1);
      AssignReaderTXComboBox->Text = s;  //transmit time
      s = GetItem(str, 3);
      if (s == "All time")
         AssignReaderWTComboBox->Text = "0";
      else
      {
         s1 = s.SubString((s.Length() - 1), s.Length());
         s.SetLength(s.Length() - 1);
         AssignReaderWTComboBox->Text = s;   //wait time
         if (s1 == "s")
         {
            AssignReaderWTSecRadioButton->Checked = true;    //wait time type
            AssignReaderWTMinRadioButton->Checked = false;
            AssignReaderWTHourRadioButton->Checked = false;
         }
         else if (s1 == "m")
         {
            AssignReaderWTMinRadioButton->Checked = true;
            AssignReaderWTSecRadioButton->Checked = false;
            AssignReaderWTHourRadioButton->Checked = false;
         }
         else if (s1 == "h")
         {
            AssignReaderWTHourRadioButton->Checked = true;
            AssignReaderWTMinRadioButton->Checked = false;
            AssignReaderWTSecRadioButton->Checked = false;
         }
      }

      s = GetItem(str, 4);  //field strength
      //AssignReaderFSComboBox->Text = s;

      s = GetItem(str, 5);  //MD Enable
      if (s == "Enable")
         AssignReaderEnableMDCheckBox->Checked = true;
      else
         AssignReaderEnableMDCheckBox->Checked = false;

      s = GetItem(str, 6);  //Active
      if (s == "Low")
      {
         AssignReaderMDActiveLoRadioButton->Checked = true;
         AssignReaderMDActiveHiRadioButton->Checked = false;
      }
      else if (s == "High")
      {
         AssignReaderMDActiveHiRadioButton->Checked = true;
         AssignReaderMDActiveLoRadioButton->Checked = false;
      }
   }//item
}
//---------------------------------------------------------------------------


void __fastcall TProgStationForm::AssignReaderSetConfigBitBtnClick(
      TObject *Sender)
{
   TxClearTagCtrls();
   RxClearTagCtrls();
   AssignReaderListView->Items->Clear();

   StaticText->Caption = "";
   receivedResponse = false;

   //CMDEnableTimer->Enabled = true;
   //DisableSmartFGenStaticCommands();
   //QuerySFGenBitBtn->Enabled = false;

   //if (lastReaderID > 0)
   if (AssignReaderIDComboBox->Text.data() == NULL)
      AssignReaderIDComboBox->Text = lastReaderID;

   for (unsigned int i=0; i<numReaderIDList; i++)
   {
      if (AssignReaderIDComboBox->Items->IndexOf(readerIDList[i]) == -1 )
         AssignReaderIDComboBox->Items->Add(readerIDList[i]);
   }

   if (allHostID)
   {
      if (lastHostID > 0)
         AssignReaderHostIDEdit->Text = lastHostID;
   }
   else
      AssignReaderHostIDEdit->Text = sysHostID;

   if(networkOn)
   {
      int rdr = atoi(AssignReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(CONFIG_FIELD_GEN, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(CONFIG_FIELD_GEN, 0, NULL, 0);
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::CallTagIDRadioButtonClick(
      TObject *Sender)
{
   CallTagIDEdit->ReadOnly = false;
   CallTagIDEdit->Color = clWhite;
   CallTagIDEdit->Enabled = true;

   CallTagIDRangeComboBox->Color = clMenu;
   CallTagIDRangeComboBox->Enabled = false;
   CallTagIDRangeComboBox->Font->Color = clGray;

   CallTagRNLongRadioButton->Enabled = true;
   CallTagRNShortRadioButton->Enabled = true;

   CallTagEnableSpeakerRadioButton->Enabled = true;
   CallTagDisableSpeakerRadioButton->Enabled = true;

   CallTagEnableLEDRadioButton->Enabled = true;
   CallTagDisableLEDRadioButton->Enabled = true;
}
//---------------------------------------------------------------------------
int __fastcall TProgStationForm::IsReaderOffline(int rdr)
{
    for (int i=0; i<128; i++)
    {
       if (noResponseReaderID[i] == rdr)
         return (i);
    }

    return (-1);
}
//---------------------------------------------------------------------------
bool __fastcall TProgStationForm::IsAllReaderOffline()
{
    int counter = 0;
    for (int i=0; i<128; i++)
    {
       if (noResponseReaderID[i] > 0)
         counter += 1;
    }

    if ( counter >= listViewItemCount )
       return(true);
    else
       return (false);
}
/*//------------------------------------------------------------------------------
bool __fastcall TProgStationForm::IsNetworkOffline()
{


    int counter = 0;
    for (int i=0; i<128; i++)
    {
       if (noResponseReaderID[i] > 0)
         counter += 1;
    }

    if ( counter >= listViewItemCount )
       return(true);
    else
       return (false);
} */
//---------------------------------------------------------------------------
bool __fastcall TProgStationForm::IsReaderOffline()
{
    for (int i=0; i<128; i++)
    {
       if (noResponseReaderID[i] != 0)
         return (true);
    }

    return (false);
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::BootloadTimerTimer(TObject *Sender)
{
   if (IsAllReaderOffline())
   {
     readerOffLine = true;
     readerOnLine = false;
     fieldGenOffLine = true;
     fieldGenOnLine = false;
   }
   BootloadTimer->Enabled = false;
   int index;
   bool found = false;
   //if ((index=GetNetworkInfoIndex(callingReaderID)) >= 0)
   if ((index=GetListViewInfoIndex(callingReaderID)) >= 0)
   {
      for (int i=0; i<128; i++)
      {
          if (noResponseReaderID[i] == 0)
          {
              noResponseReaderID[i] = callingReaderID;
              found = true;
              break;
          }
      }

      if (found)
         networkOffline = false;
      else
         networkOffline = true;

      if (IsReaderOffline(callingReaderID) >= 0)
          strcpy(listViewInfo[index].rdrStatus, "Offline");
   }

   /*if (lastDownloadPkt)
   {
      lastDownloadPkt = false;

      if (bload_proc == 0)
          DownloadRdrProgressBarC->Position = numLines-1;
      else if (bload_proc == 1)
          DownloadRdrProgressBarD->Position = numLines-1;
      else if (bload_proc == 2)
          DownloadRdrProgressBarE->Position = numLines-1;

      if(networkOn)
      {
         int rdr = atoi(DownloadRdrReaderComboBox->Text.c_str());
         int index = GetSocketIndex(rdr);
         if (index >= 0)
         {
            WriteAWSocket(RESET_DEVICE, 0, NULL, 0, 'S', NULL, 0, index);
         }
         else
            StaticText->Caption = "No matching socket for the reader.";
      }
      else if (RS232On)
      {
         WriteRS232Comm(RESET_DEVICE, 0, NULL, 0);
      }
   }
   else if (sendBootQuery) // && bootloading)
   {
      BootloadTimer->Enabled = false;
      sendBootQuery = false;
      if(networkOn)
      {
         int rdr = atoi(DownloadRdrReaderComboBox->Text.c_str());
         int index = GetSocketIndex(rdr);
         if (index >= 0)
         {
            WriteAWSocket(BOOT_QUERY, 0, NULL, 0, 'S', NULL, 0, index);
         }
         else
            StaticText->Caption = "No matching socket for the reader.";
      }
      else if (RS232On)
      {
         WriteRS232Comm(BOOT_QUERY, 0, NULL, 0);
      }
   }*/
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::DownloadRdrTestCheckBoxClick(
      TObject *Sender)
{
   if(( wfPtr = fopen("g:\\debugBootPS.txt", "w" )) == NULL )
          Application->MessageBox("faile to open", MB_OK);
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::QueryTagClearListButtonClick(
      TObject *Sender)
{
   QueryTagListView->Items->Clear();
}
//---------------------------------------------------------------------------
bool __fastcall TProgStationForm::IsItemInList(unsigned int item)
{
   TListItem* listItem;
   TStrings* str;
   AnsiString idStr;
   AnsiString s;

   for (int i=0; i<QueryTagListView->Items->Count; i++)
   {
      listItem = QueryTagListView->Items->Item[i];
      if (listItem)
      {
         str = listItem->SubItems;
         s = str->Text;
         idStr = GetItem(str, 0);
         if ((unsigned int)atoi(idStr.c_str()) == item)
            return (true);
     }
   }

   return (false);
}
void __fastcall TProgStationForm::QueryTagListViewColumnClick(
      TObject *Sender, TListColumn *Column)
{
    columnToSort = Column->Index;
  ((TCustomListView *)Sender)->AlphaSort();
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::QueryTagListViewCompare(TObject *Sender,
      TListItem *Item1, TListItem *Item2, int Data, int &Compare)
{
    int index;
    AnsiString selectedItem1;
    AnsiString selectedItem2;
    AnsiString s;
    TStrings* str;
    int n1, n2;

    if (columnToSort == 1)  //tag id
    {
       str = Item1->SubItems;
       selectedItem1 = GetItem(str, 0);

       str = Item2->SubItems;
       selectedItem2 = GetItem(str, 0);

       n1 = atoi(selectedItem1.c_str());
       n2 = atoi(selectedItem2.c_str());
       if (n1 == n2)
            Compare = 0;
       else if (n1 > n2)
            Compare = 1;
       else
           Compare = -1;
    }
    else if (columnToSort == 2) //type
    {
       str = Item1->SubItems;
       selectedItem1 = GetItem(str, 1);
       str = Item2->SubItems;
       selectedItem2 = GetItem(str, 1);
       Compare = CompareText(selectedItem1, selectedItem2);
    }
    else if (columnToSort == 3) //status
    {
       str = Item1->SubItems;
       selectedItem1 = GetItem(str, 2);
       str = Item2->SubItems;
       selectedItem2 = GetItem(str, 2);
       Compare = CompareText(selectedItem1, selectedItem2);
    }
    else if (columnToSort == 4) //battery
    {
       str = Item1->SubItems;
       selectedItem1 = GetItem(str, 3);
       str = Item2->SubItems;
       selectedItem2 = GetItem(str, 3);
       Compare = CompareText(selectedItem1, selectedItem2);
    }
    else if (columnToSort == 5)  //resend time
    {
       str = Item1->SubItems;
       selectedItem1 = GetItem(str, 4);

       str = Item2->SubItems;
       selectedItem2 = GetItem(str, 4);

       n1 = atoi(selectedItem1.c_str());
       n2 = atoi(selectedItem2.c_str());
       if (n1 == n2)
            Compare = 0;
       else if (n1 > n2)
            Compare = 1;
       else
           Compare = -1;
    }
    else if (columnToSort == 6)  //TIF
    {
         str = Item1->SubItems;
       selectedItem1 = GetItem(str, 5);

       str = Item2->SubItems;
       selectedItem2 = GetItem(str, 5);

       n1 = atoi(selectedItem1.c_str());
       n2 = atoi(selectedItem2.c_str());
       if (n1 == n2)
            Compare = 0;
       else if (n1 > n2)
            Compare = 1;
       else
           Compare = -1;
    }
    else if (columnToSort == 7)  //GC
    {
         str = Item1->SubItems;
       selectedItem1 = GetItem(str, 6);

       str = Item2->SubItems;
       selectedItem2 = GetItem(str, 6);

       n1 = atoi(selectedItem1.c_str());
       n2 = atoi(selectedItem2.c_str());
       if (n1 == n2)
            Compare = 0;
       else if (n1 > n2)
            Compare = 1;
       else
           Compare = -1;
    }
    else if (columnToSort == 8)  //Tampered
    {
       str = Item1->SubItems;
       selectedItem1 = GetItem(str, 7);
       str = Item2->SubItems;
       selectedItem2 = GetItem(str, 7);
       Compare = CompareText(selectedItem1, selectedItem2);
    }
    else if (columnToSort == 9)  //Version
    {
         str = Item1->SubItems;
       selectedItem1 = GetItem(str, 8);

       str = Item2->SubItems;
       selectedItem2 = GetItem(str, 8);

       n1 = atoi(selectedItem1.c_str());
       n2 = atoi(selectedItem2.c_str());
       if (n1 == n2)
            Compare = 0;
       else if (n1 > n2)
            Compare = 1;
       else
           Compare = -1;
    }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::QueryTagListViewCustomDrawItem(
      TCustomListView *Sender, TListItem *Item, TCustomDrawState State,
      bool &DefaultDraw)
{
   if (QueryTagKeepItemsCheckBox->Checked)
   {
      if ((Item->Index >= listCount) && (listCount > 0))
        QueryTagListView->Canvas->Font->Color = clBlue;
      else
        QueryTagListView->Canvas->Font->Color = clGreen;
   }
   else
     QueryTagListView->Canvas->Font->Color = clGreen;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::EnableRelay1RadioButtonClick(
      TObject *Sender)
{
    EnableRelay2RadioButton->Checked = false;
    DisableRelay2RadioButton->Checked = false;
    RelayBitBtn->Caption = "Enable Relay";
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::DisableRelay1RadioButtonClick(
      TObject *Sender)
{
    EnableRelay2RadioButton->Checked = false;
    DisableRelay2RadioButton->Checked = false;
    RelayBitBtn->Caption = "Disable Relay";
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::EnableRelay2RadioButtonClick(
      TObject *Sender)
{
   EnableRelay1RadioButton->Checked = false;
   DisableRelay1RadioButton->Checked = false;
   RelayBitBtn->Caption = "Enable Relay";
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::DisableRelay2RadioButtonClick(
      TObject *Sender)
{
   EnableRelay1RadioButton->Checked = false;
   DisableRelay1RadioButton->Checked = false;
   RelayBitBtn->Caption = "Disable Relay";
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ConfigLEDRadioButtonClick(
      TObject *Sender)
{
    ConfigTagLEDSpeakerEdit->Color = clMenu;
    ConfigTagLEDSpeakerEdit->ReadOnly = true;
    ConfigTagLEDNumCyclesEdit->Color = clWhite;
    ConfigTagLEDNumCyclesEdit->ReadOnly = false;

    ConfigLEDRadioButton->Font->Color = clRed;
    ConfigLEDSpeakerRadioButton->Font->Color = clTeal;
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ConfigLEDSpeakerRadioButtonClick(
      TObject *Sender)
{
    ConfigTagLEDSpeakerEdit->Color = clWhite;
    ConfigTagLEDSpeakerEdit->ReadOnly = false;
    ConfigTagLEDNumCyclesEdit->Color = clMenu;
    ConfigTagLEDNumCyclesEdit->ReadOnly = true;

    ConfigLEDRadioButton->Font->Color = clTeal;
    ConfigLEDSpeakerRadioButton->Font->Color = clRed;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagSpeakerGetBitBtnClick(
      TObject *Sender)
{
    programming = true;

    if (!NewListItemCheckBox->Checked)
   {
      TxClearTagCtrls();
      RxClearTagCtrls();
      ProgammingMode = true;
      StaticText->Caption = "";
      DetectedMsg->Caption = "";
      TamperSWMsg->Caption = "";
      TagDetectedGroupBox->Caption = "Detected Tags";
      tagDetectCount = 0;
      type1Count = 0;
      type2Count = 0;
      type3Count = 0;
      type4Count = 0;
      type5Count = 0;
      type6Count = 0;
      typeFacCount = 0;
      ReportType1Label->Caption = "";
      ReportType2Label->Caption = "";
      ReportType3Label->Caption = "";
      ReportType4Label->Caption = "";
      ReportType5Label->Caption = "";
      ReportType6Label->Caption = "";
      ReportFACTLabel->Caption = "";
      ReportTotalLabel->Caption = "";
      ReportNDupLabel->Caption = "";
      DetectedTagListView->Items->Clear();
      for (int i=0; i<MAX_TAG_DETECTED; i++)
      {
          tagDetectedArray[i].tagID = 0;
          tagDetectedArray[i].tagType = 6;
          tagDetectedArray[i].cmd = 0;
          tagDetectedArray[i].fGenID = 0xFF;
          tagDetectedArray[i].gID = false;
          tagDetectedArray[i].lastDetectTime = Now();
      }
   }
   //StaticText->Caption = "";
   programming = true;

   progStr = "Please wait. Getting Speaker Config. for ";

   tagTypeStr = ConfigTagLEDTagTypeComboBox->Text;
   progStr += ConfigTagLEDTagTypeComboBox->Text;
   progStr += " Tag";

   /*progStr = "Please wait. ";
   if (ConfigTagLEDAccRadioButton->Checked)
   {
      tagTypeStr = "Access";
      progStr += "Getting Speaker Configuration for Access Tag";
   }
   else if (ConfigTagLEDAssRadioButton->Checked)
   {
      tagTypeStr = "Asset";
      progStr += "Getting Speaker Configuration for Asset Tag";
   }
   else if (ConfigTagLEDInvRadioButton->Checked)
   {
      tagTypeStr = "Inventory";
      progStr += "Getting Speaker Configuration for Inventory Tag";
   }

   if (CallTagAnyTagIDRadioButton->Checked)
      progStr += "s";
   else
      progStr += " ";
   */

   ConfigTagLEDSpeakerEdit->Text = "";

   StaticText->Caption = progStr;

   if (!ConfigTagSpeakerKeepListCheckBox->Checked)
        ConfigTagSpeakerListView->Items->Clear();
   else
   {
      spkListCount = ConfigTagSpeakerListView->Items->Count;
      ConfigTagSpeakerListView->Invalidate();
   }

   if(networkOn)
   {
      int rdr = atoi(ConfigTagLEDReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(GET_CONFIG_TAG_SPEAKER, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(GET_CONFIG_TAG_SPEAKER, 0, NULL, 0);
   }
}
//---------------------------------------------------------------------------
void __fastcall TProgStationForm::ChangeConfigReaderSTDControls(bool b)
{
   AssignReaderEnableLabel->Enabled = b;
   AssignReaderActiveHiLabel->Enabled = b;
   AssignReaderActiveLoLabel->Enabled = b;
   AssignReaderSecLabel->Enabled = b;
   AssignReaderHourLabel->Enabled = b;
   AssignReaderMinLabel->Enabled = b;
   AssignReaderTimeLabel->Enabled = b;

   AssignReaderWTComboBox->Enabled = b;
   AssignReaderWTSecRadioButton->Enabled = b;
   AssignReaderWTHourRadioButton->Enabled = b;
   AssignReaderEnableMDCheckBox->Enabled = b;
   AssignReaderMDActiveHiRadioButton->Enabled = b;
   AssignReaderMDActiveLoRadioButton->Enabled = b;
   AssignReaderModifyWTCheckBox->Enabled = b;
   AssignReaderModifyMDCheckBox->Enabled = b;
   AssignReaderSetConfigBitBtn->Enabled = b;
   AssignReaderWTGroupBox->Enabled = b;
   AssignReaderMDGroupBox->Enabled = b;
   AssignReaderWTComboBox->Enabled = b;
   if (b)
     AssignReaderWTComboBox->Color = clWhite;
   else
     AssignReaderWTComboBox->Color = clMenu;
}


void __fastcall TProgStationForm::AssignReaderIDComboBoxChange(
      TObject *Sender)
{
   TxClearTagCtrls();
   RxClearTagCtrls();
   AssignReaderListView->Items->Clear();

   StaticText->Caption = "";
   receivedResponse = false;

   //CMDEnableTimer->Enabled = true;
   //DisableSmartFGenStaticCommands();
   //QuerySFGenBitBtn->Enabled = false;

   if (AssignReaderIDComboBox->Text.data() == NULL)
   //if (lastReaderID > 0)
      AssignReaderIDComboBox->Text = lastReaderID;

   for (unsigned int i=0; i<numReaderIDList; i++)
   {
      if (AssignReaderIDComboBox->Items->IndexOf(readerIDList[i]) == -1 )
         AssignReaderIDComboBox->Items->Add(readerIDList[i]);
   }

   if (allHostID)
   {
      if (lastHostID > 0)
         AssignReaderHostIDEdit->Text = lastHostID;
   }
   else
      AssignReaderHostIDEdit->Text = sysHostID;

   if(networkOn)
   {
      int rdr = atoi(AssignReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(QUERY_READER, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(QUERY_READER, 0, NULL, 0);
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::AssignReaderBroadcastReaderCheckBoxClick(
      TObject *Sender)
{
    if (AssignReaderBroadcastReaderCheckBox->Checked)
    {
       AssignReaderIDComboBox->Color = clMenu;
       AssignReaderIDComboBox->Enabled = false;
    }
    else
    {
       AssignReaderIDComboBox->Color = clWhite;
       AssignReaderIDComboBox->Enabled = true;
    }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::RelayBroadcastRdrCheckBoxClick(
      TObject *Sender)
{
   if (RelayBroadcastRdrCheckBox->Checked)
   {
      RelayReaderIDComboBox->Enabled = false;
      RelayReaderIDComboBox->Color = clMenu;
   }
   else
   {
      RelayReaderIDComboBox->Enabled = true;
      RelayReaderIDComboBox->Color = clWhite;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::InputBroadCastCheckBoxClick(
      TObject *Sender)
{
   if (InputBroadCastCheckBox->Checked)
   {
      InputReaderIDComboBox->Enabled = false;
      InputReaderIDComboBox->Color = clMenu;
   }
   else
   {
      InputReaderIDComboBox->Enabled = true;
      InputReaderIDComboBox->Color = clWhite;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::EnableTagBroadcastRdrCheckBoxClick(
      TObject *Sender)
{
   if (EnableTagBroadcastRdrCheckBox->Checked)
   {
      EnableTagIDComboBox->Enabled = false;
      EnableTagIDComboBox->Color = clMenu;
   }
   else
   {
      EnableTagIDComboBox->Enabled = true;
      EnableTagIDComboBox->Color = clWhite;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::DisableTagBroadcastRdrCheckBoxClick(
      TObject *Sender)
{
   if (DisableTagBroadcastRdrCheckBox->Checked)
   {
      DisableTagIDComboBox->Enabled = false;
      DisableTagIDComboBox->Color = clMenu;
   }
   else
   {
      DisableTagIDComboBox->Enabled = true;
      DisableTagIDComboBox->Color = clWhite;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::QueryTagBroadcastRdrCheckBoxClick(
      TObject *Sender)
{
   if (QueryTagBroadcastRdrCheckBox->Checked)
   {
      QueryTagReaderIDComboBox->Enabled = false;
      QueryTagReaderIDComboBox->Color = clMenu;
   }
   else
   {
      QueryTagReaderIDComboBox->Enabled = true;
      QueryTagReaderIDComboBox->Color = clWhite;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::CallTagBroadcastRdrCheckBoxClick(
      TObject *Sender)
{
   if (CallTagBroadcastRdrCheckBox->Checked)
   {
      CallTagReaderIDComboBox->Enabled = false;
      CallTagReaderIDComboBox->Color = clMenu;
   }
   else
   {
      CallTagReaderIDComboBox->Enabled = true;
      CallTagReaderIDComboBox->Color = clWhite;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ReadMemoryBroadcastRdrCheckBoxClick(
      TObject *Sender)
{
   if (ReadMemoryBroadcastRdrCheckBox->Checked)
   {
      ReadMemoryReaderIDComboBox->Enabled = false;
      ReadMemoryReaderIDComboBox->Color = clMenu;
   }
   else
   {
      ReadMemoryReaderIDComboBox->Enabled = true;
      ReadMemoryReaderIDComboBox->Color = clWhite;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagLEDBroadcastReaderCheckBoxClick(
      TObject *Sender)
{
   if (ConfigTagLEDBroadcastReaderCheckBox->Checked)
   {
       ConfigTagLEDReaderIDComboBox->Enabled = false;
       ConfigTagLEDReaderIDComboBox->Color = clMenu;
   }
   else
   {
      ConfigTagLEDReaderIDComboBox->Enabled = true;
       ConfigTagLEDReaderIDComboBox->Color = clWhite;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::SmartFGenBroadcastAllRdrCheckBoxClick(
      TObject *Sender)
{
   if (SmartFGenBroadcastAllRdrCheckBox->Checked)
   {
      SmartFGenReaderIDComboBox->Enabled = false;
      SmartFGenReaderIDComboBox->Color = clMenu;
   }
   else
   {
      SmartFGenReaderIDComboBox->Enabled = true;
      SmartFGenReaderIDComboBox->Color = clWhite;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::TagTempBroadcastRdrCheckBoxClick(
      TObject *Sender)
{
   if (TagTempBroadcastRdrCheckBox->Checked)
   {
      TagTempReaderIDComboBox->Enabled = false;
      TagTempReaderIDComboBox->Color = clMenu;
   }
   else
   {
      TagTempReaderIDComboBox->Enabled = true;
      TagTempReaderIDComboBox->Color = clWhite;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::FGenResetBroadcastRdrCheckBoxClick(
      TObject *Sender)
{
    if (FGenResetBroadcastRdrCheckBox->Checked)
    {
        FGenResetReaderIDComboBox->Enabled = false;
        FGenResetReaderIDComboBox->Color = clMenu;
    }
    else
    {
        FGenResetReaderIDComboBox->Enabled = true;
        FGenResetReaderIDComboBox->Color = clWhite;
    }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::FGenResetBroadcastSmartFGenCheckBoxClick(
      TObject *Sender)
{
    if (FGenResetBroadcastSmartFGenCheckBox->Checked)
    {
       FGenResetIDComboBox->Enabled = false;
       FGenResetIDComboBox->Color = clMenu;
    }
    else
    {
       FGenResetIDComboBox->Enabled = true;
       FGenResetIDComboBox->Color = clWhite;
    }
}
//---------------------------------------------------------------------------


void __fastcall TProgStationForm::ConfigTagSpeakerClearListBitBtnClick(
      TObject *Sender)
{
    ConfigTagSpeakerListView->Items->Clear();
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagLEDClearListBitBtnClick(
      TObject *Sender)
{
   ConfigTagLEDListView->Items->Clear();
}
//---------------------------------------------------------------------------
 bool __fastcall TProgStationForm::IsInSpkList(unsigned int id, AnsiString type)
 {
    TListItem* item;
    TStrings* str;
    AnsiString tagID;
    AnsiString tagType;

    for (int i=0; i<ConfigTagSpeakerListView->Items->Count; i++)
    {
       item  = ConfigTagSpeakerListView->Items->Item[i];

      if (item)
      {
         str = item->SubItems;
         //AnsiString s = str->Text;
         tagID = GetItem(str, 1);       //ID
         tagType = GetItem(str, 2);    //Type
         if ((tagID == id) && (tagType == type))
            return (true);
      }
    }

    return (false);
}
//------------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagSpeakerListViewColumnClick(
      TObject *Sender, TListColumn *Column)
{
    columnToSort = Column->Index;
   ((TCustomListView *)Sender)->AlphaSort();
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagSpeakerListViewCompare(
      TObject *Sender, TListItem *Item1, TListItem *Item2, int Data,
      int &Compare)
{
    int index;
    AnsiString selectedItem1;
    AnsiString selectedItem2;
    AnsiString s;
    TStrings* str;
    int n1, n2;
    float f1, f2;

    if (columnToSort == 1)  //reader ID
    {
         str = Item1->SubItems;
         selectedItem1 = GetItem(str, 0);

         str = Item2->SubItems;
         selectedItem2 = GetItem(str, 0);

         n1 = atoi(selectedItem1.c_str());
         n2 = atoi(selectedItem2.c_str());
         if (n1 == n2)
            Compare = 0;
         else if (n1 > n2)
            Compare = 1;
         else
           Compare = -1;
    }
    else if (columnToSort == 2)  //tag ID
    {
         str = Item1->SubItems;
         selectedItem1 = GetItem(str, 1);

         str = Item2->SubItems;
         selectedItem2 = GetItem(str, 1);

         n1 = atoi(selectedItem1.c_str());
         n2 = atoi(selectedItem2.c_str());
         if (n1 == n2)
            Compare = 0;
         else if (n1 > n2)
            Compare = 1;
         else
           Compare = -1;
    }
    else if (columnToSort == 3) //tag type
    {
         str = Item1->SubItems;
         selectedItem1 = GetItem(str, 2);
         str = Item2->SubItems;
         selectedItem2 = GetItem(str, 2);
         Compare = CompareText(selectedItem1, selectedItem2);
    }
    else if (columnToSort == 4)  //# beep
    {
         str = Item1->SubItems;
         selectedItem1 = GetItem(str, 3);

         str = Item2->SubItems;
         selectedItem2 = GetItem(str, 3);

         n1 = atoi(selectedItem1.c_str());
         n2 = atoi(selectedItem2.c_str());
         if (n1 == n2)
            Compare = 0;
         else if (n1 > n2)
            Compare = 1;
         else
           Compare = -1;
    }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagLEDListViewCompare(
      TObject *Sender, TListItem *Item1, TListItem *Item2, int Data,
      int &Compare)
{
    int index;
    AnsiString selectedItem1;
    AnsiString selectedItem2;
    AnsiString s;
    TStrings* str;
    int n1, n2;
    float f1, f2;

    if (columnToSort == 1)  //reader ID
    {
         str = Item1->SubItems;
         selectedItem1 = GetItem(str, 0);

         str = Item2->SubItems;
         selectedItem2 = GetItem(str, 0);

         n1 = atoi(selectedItem1.c_str());
         n2 = atoi(selectedItem2.c_str());
         if (n1 == n2)
            Compare = 0;
         else if (n1 > n2)
            Compare = 1;
         else
           Compare = -1;
    }
    else if (columnToSort == 2)  //tag ID
    {
         str = Item1->SubItems;
         selectedItem1 = GetItem(str, 1);

         str = Item2->SubItems;
         selectedItem2 = GetItem(str, 1);

         n1 = atoi(selectedItem1.c_str());
         n2 = atoi(selectedItem2.c_str());
         if (n1 == n2)
            Compare = 0;
         else if (n1 > n2)
            Compare = 1;
         else
           Compare = -1;
    }
    else if (columnToSort == 3) //tag type
    {
         str = Item1->SubItems;
         selectedItem1 = GetItem(str, 2);
         str = Item2->SubItems;
         selectedItem2 = GetItem(str, 2);
         Compare = CompareText(selectedItem1, selectedItem2);
    }
    else if (columnToSort == 4)  //# flash
    {
         str = Item1->SubItems;
         selectedItem1 = GetItem(str, 3);

         str = Item2->SubItems;
         selectedItem2 = GetItem(str, 3);

         n1 = atoi(selectedItem1.c_str());
         n2 = atoi(selectedItem2.c_str());
         if (n1 == n2)
            Compare = 0;
         else if (n1 > n2)
            Compare = 1;
         else
           Compare = -1;
    }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagLEDListViewColumnClick(
      TObject *Sender, TListColumn *Column)
{
   columnToSort = Column->Index;
   ((TCustomListView *)Sender)->AlphaSort();
}
bool __fastcall TProgStationForm::IsInLEDList(unsigned int id, AnsiString type)
 {
    TListItem* item;
    TStrings* str;
    AnsiString tagID;
    AnsiString tagType;

    for (int i=0; i<ConfigTagLEDListView->Items->Count; i++)
    {
       item  = ConfigTagLEDListView->Items->Item[i];

      if (item)
      {
         str = item->SubItems;
         tagID = GetItem(str, 1);       //ID
         tagType = GetItem(str, 2);    //Type
         if ((tagID == id) && (tagType == type))
            return (true);
      }
    }

    return (false);
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagSpeakerListViewCustomDrawItem(
      TCustomListView *Sender, TListItem *Item, TCustomDrawState State,
      bool &DefaultDraw)
{
   if (ConfigTagSpeakerKeepListCheckBox->Checked)
   {
      if ((Item->Index >= spkListCount) && (spkListCount > 0))
        ConfigTagSpeakerListView->Canvas->Font->Color = clBlue;
      else
        ConfigTagSpeakerListView->Canvas->Font->Color = clGreen;
   }
   else
     ConfigTagSpeakerListView->Canvas->Font->Color = clGreen;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagLEDListViewCustomDrawItem(
      TCustomListView *Sender, TListItem *Item, TCustomDrawState State,
      bool &DefaultDraw)
{
   if (ConfigTagLEDKeepListCheckBox->Checked)
   {
      if ((Item->Index >= ledListCount) && (ledListCount > 0))
        ConfigTagLEDListView->Canvas->Font->Color = clBlue;
      else
        ConfigTagLEDListView->Canvas->Font->Color = clGreen;
   }
   else
     ConfigTagLEDListView->Canvas->Font->Color = clGreen;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagSpeakerListViewDblClick(
      TObject *Sender)
{
   TListItem* item = ConfigTagSpeakerListView->Selected;
   TStrings* str;
   AnsiString selectedType;
   AnsiString selectedId;
   AnsiString beepNum;

   if (item)
   {
      str = item->SubItems;
      AnsiString s = str->Text;
      beepNum = GetItem(str, 3);
      selectedType = GetItem(str, 2);
      selectedId = GetItem(str, 1);

      int p;
      if ((p=GetTagTypeComboBoxIndex(selectedType)) >= 0)
             ConfigTagLEDTagTypeComboBox->ItemIndex = p;

      /*if (selectedType == "ACC")
         ConfigTagLEDAccRadioButton->Checked = true;
      else if (selectedType == "AST")
         ConfigTagLEDAssRadioButton->Checked = true;
      else if (selectedType == "INV")
         ConfigTagLEDInvRadioButton->Checked = true;*/

      ConfigTagLEDTagIDRadioButton->Checked = true;
      ConfigTagLEDTagIDEdit->Text = selectedId;

      ConfigTagLEDSpeakerEdit->Text = beepNum;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagLEDListViewDblClick(
      TObject *Sender)
{
   TListItem* item = ConfigTagLEDListView->Selected;
   TStrings* str;
   AnsiString selectedType;
   AnsiString selectedId;
   AnsiString flashNum;

   if (item)
   {
      str = item->SubItems;
      AnsiString s = str->Text;
      flashNum = GetItem(str, 3);
      selectedType = GetItem(str, 2);
      selectedId = GetItem(str, 1);

      /*if (selectedType == "ACC")
         ConfigTagLEDAccRadioButton->Checked = true;
      else if (selectedType == "AST")
         ConfigTagLEDAssRadioButton->Checked = true;
      else if (selectedType == "INV")
         ConfigTagLEDInvRadioButton->Checked = true;*/

      int p;
      if ((p=GetTagTypeComboBoxIndex(selectedType)) >= 0)
             ConfigTagLEDTagTypeComboBox->ItemIndex = p;

      ConfigTagLEDTagIDRadioButton->Checked = true;
      ConfigTagLEDTagIDEdit->Text = selectedId;

      ConfigTagLEDNumCyclesEdit->Text = flashNum;
   }
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::FGenConfigTagRdrIDModifyCheckBoxClick(
      TObject *Sender)
{
    if (FGenConfigTagRdrIDModifyCheckBox->Checked)
    {
       FGenConfigTagRdrIDCheckBox->Enabled = true;
       FGenConfigTagRdrIDModifyCheckBox->Font->Color = clRed;
    }
    else
    {
       FGenConfigTagRdrIDCheckBox->Enabled = false;
       FGenConfigTagRdrIDCheckBox->Checked = false;
       FGenConfigTagRdrIDModifyCheckBox->Font->Color = clOlive;
    }
}
//------------------------------------------------------------------------------

void __fastcall TProgStationForm::Input1ModifyCheckBoxClick(
      TObject *Sender)
{
   if (Input1ModifyCheckBox->Checked)
   {
      Input1NoReportRadioButton->Enabled = true;
      Input1ReportRadioButton->Enabled = true;
      Input1SupervisedCheckBox->Enabled = true;
   }
   else
   {
      Input1NoReportRadioButton->Enabled = false;
      Input1ReportRadioButton->Enabled = false;
      Input1SupervisedCheckBox->Enabled = false;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::Input2ModifyCheckBoxClick(
      TObject *Sender)
{
   if (Input2ModifyCheckBox->Checked)
   {
      Input2NoReportRadioButton->Enabled = true;
      Input2ReportRadioButton->Enabled = true;
      Input2SupervisedCheckBox->Enabled = true;
   }
   else
   {
      Input2NoReportRadioButton->Enabled = false;
      Input2ReportRadioButton->Enabled = false;
      Input2SupervisedCheckBox->Enabled = false;
   }
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::EnableTagIDRangeRadioButtonClick(
      TObject *Sender)
{
    EnableTagIDRangeComboBox->Color = clWhite;
    EnableTagIDRangeComboBox->Font->Color = clBlue;
    EnableTagIDRangeComboBox->Enabled = true;

    EnableTagIDEdit->ReadOnly = false;
    EnableTagIDEdit->Color = clWhite;
    EnableTagIDEdit->Enabled = true;

    EnableTagRNLongRadioButton->Enabled = false;
    EnableTagRNShortRadioButton->Enabled = false;
    EnableTagEnableLEDRadioButton->Enabled = false;
    EnableTagDisableLEDRadioButton->Enabled = false;
    EnableTagEnableSpeakerRadioButton->Enabled = false;
    EnableTagDisableSpeakerRadioButton->Enabled = false;
}
//------------------------------------------------------------------------------

void __fastcall TProgStationForm::EnableTagIDRangeComboBoxExit(
      TObject *Sender)
{
    unsigned short range = atoi(EnableTagIDRangeComboBox->Text.c_str());
    AnsiString str = range;
    str += " is not a valid Range value.";
    if (!IsInRange(range))
    {
         Application->MessageBox(str.c_str(), "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         EnableTagIDRangeComboBox->Text = "";
    }
}
//---------------------------------------------------------------------------
bool __fastcall TProgStationForm::IsInRange(unsigned short range)
{
    unsigned short rangeTbl[16] = {2, 3, 4, 5, 6, 7, 8, 10, 15, 20, 40, 60, 80, 100, 150, 200};
    for (int i=0; i<16; i++)
    {
       if (rangeTbl[i] == range)
          return (true);
    }
    return (false);
}
//---------------------------------------------------------------------------
unsigned char __fastcall TProgStationForm::GetRangeIndex(unsigned short range)
{
    unsigned char index = 0x00;
    switch (range)
    {
       case 2:
          index = 0x00;
       break;

       case 3:
          index = 0x01;
       break;

       case 4:
          index = 0x02;
       break;

       case 5:
          index = 0x03;
       break;

       case 6:
          index = 0x04;
       break;

       case 7:
          index = 0x05;
       break;

       case 8:
          index = 0x06;
       break;

       case 10:
          index = 0x07;
       break;

       case 15:
          index = 0x08;
       break;

       case 20:
          index = 0x09;
       break;

       case 40:
          index = 0x0A;
       break;

       case 60:
          index = 0x0B;
       break;

       case 80:
          index = 0x0C;
       break;

       case 100:
          index = 0x0D;
       break;

       case 150:
          index = 0x0E;
       break;

       case 200:
          index = 0x0F;
       break;
    }

    return (index);
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::DisableTagIDRangeRadioButtonClick(
      TObject *Sender)
{
    DisableTagIDRangeComboBox->Color = clWhite;
    DisableTagIDRangeComboBox->Font->Color = clBlue;
    DisableTagIDRangeComboBox->Enabled = true;

    DisableTagIDEdit->ReadOnly = false;
    DisableTagIDEdit->Color = clWhite;
    DisableTagIDEdit->Enabled = true;

    DisableTagRNLongRadioButton->Enabled = false;
    DisableTagRNShortRadioButton->Enabled = false;
    DisableTagEnableLEDRadioButton->Enabled = false;
    DisableTagDisableLEDRadioButton->Enabled = false;
    DisableTagEnableSpeakerRadioButton->Enabled = false;
    DisableTagDisableSpeakerRadioButton->Enabled = false;
}
//------------------------------------------------------------------------------

void __fastcall TProgStationForm::CallTagIDRangeRadioButtonClick(
      TObject *Sender)
{
   CallTagIDEdit->ReadOnly = false;
   CallTagIDEdit->Color = clWhite;
   CallTagIDEdit->Enabled = true;

   CallTagIDRangeComboBox->Color = clWhite;
   CallTagIDRangeComboBox->Enabled = true;
   CallTagIDRangeComboBox->Font->Color = clBlue;

   CallTagRNLongRadioButton->Enabled = false;
   CallTagRNShortRadioButton->Enabled = false;

   CallTagEnableSpeakerRadioButton->Enabled = false;
   CallTagDisableSpeakerRadioButton->Enabled = false;

   CallTagEnableLEDRadioButton->Enabled = false;
   CallTagDisableLEDRadioButton->Enabled = false;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::CallTagIDRangeComboBoxExit(
      TObject *Sender)
{
    unsigned short range = atoi(CallTagIDRangeComboBox->Text.c_str());
    AnsiString str = range;
    str += " is not a valid Range value.";
    if (!IsInRange(range))
    {
         Application->MessageBox(str.c_str(), "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         CallTagIDRangeComboBox->Text = "";
    }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::QueryTagIDRangeRadioButtonClick(
      TObject *Sender)
{
   QueryTagIDEdit->ReadOnly = false;
   QueryTagIDEdit->Color = clWhite;
   QueryTagIDEdit->Enabled = true;

   QueryTagIDRangeComboBox->Enabled = true;
   QueryTagIDRangeComboBox->Color = clWhite;
   QueryTagIDRangeComboBox->Font->Color = clBlue;

   QueryTagRNLongRadioButton->Enabled = false;
   QueryTagRNShortRadioButton->Enabled = false;

   QueryTagEnableLEDRadioButton->Enabled = false;
   QueryTagDisableLEDRadioButton->Enabled = false;

   QueryTagEnableSpeakerRadioButton->Enabled = false;
   QueryTagDisableSpeakerRadioButton->Enabled = false;
}
//------------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagIDRangeRadioButtonClick(
      TObject *Sender)
{
   ConfigTagTagIDEdit->Enabled = true;
   ConfigTagTagIDEdit->ReadOnly = false;
   ConfigTagTagIDEdit->Color = clWhite;

   ConfigTagIDRangeComboBox->Enabled = true;
   ConfigTagIDRangeComboBox->Color = clWhite;
   ConfigTagIDRangeComboBox->Font->Color = clBlue;

   ConfigTagModifyRNCheckBox->Checked = false;
   ConfigTagModifyRNCheckBox->Enabled = false;
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::ConfigTagIDRangeComboBoxExit(
      TObject *Sender)
{
   unsigned short range = atoi(ConfigTagIDRangeComboBox->Text.c_str());
    AnsiString str = range;
    str += " is not a valid Range value.";
    if (!IsInRange(range))
    {
         Application->MessageBox(str.c_str(), "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         ConfigTagIDRangeComboBox->Text = "";
    }
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::QueryTagIDRangeComboBoxExit(
      TObject *Sender)
{
    unsigned short range = atoi(QueryTagIDRangeComboBox->Text.c_str());
    AnsiString str = range;
    str += " is not a valid Range value.";
    if (!IsInRange(range))
    {
         Application->MessageBox(str.c_str(), "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         QueryTagIDRangeComboBox->Text = "";
    }
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::TagTempTagIDRangeComboBoxExit(
      TObject *Sender)
{
    unsigned short range = atoi(TagTempTagIDRangeComboBox->Text.c_str());
    AnsiString str = range;
    str += " is not a valid Range value.";
    if (!IsInRange(range))
    {
         Application->MessageBox(str.c_str(), "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         TagTempTagIDRangeComboBox->Text = "";
    }
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::TagTempTagIDRangeRadioButtonClick(
      TObject *Sender)
{
   TagTempTagIDEdit->ReadOnly = false;
   TagTempTagIDEdit->Color = clWhite;
   TagTempTagIDEdit->Enabled = true;

   TagTempTagIDRangeComboBox->Color = clWhite;
   TagTempTagIDRangeComboBox->Enabled = true;
   TagTempTagIDRangeComboBox->Font->Color = clBlue;

   TagTempTagRNLongRadioButton->Enabled = false;
   TagTempTagRNShortRadioButton->Enabled = false;
}
//------------------------------------------------------------------------------

void __fastcall TProgStationForm::ReadMemoryTagIDRangeComboBoxExit(
      TObject *Sender)
{
    unsigned short range = atoi(ReadMemoryTagIDRangeComboBox->Text.c_str());
    AnsiString str = range;
    str += " is not a valid Range value.";
    if (!IsInRange(range))
    {
         Application->MessageBox(str.c_str(), "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         ReadMemoryTagIDRangeComboBox->Text = "";
    }
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::ReadMemoryTagIDRangeRadioButtonClick(
      TObject *Sender)
{
   ReadMemoryTagIDEdit->ReadOnly = false;
   ReadMemoryTagIDEdit->Color = clWhite;
   ReadMemoryTagIDEdit->Enabled = true;

   ReadMemoryTagIDRangeComboBox->Color = clWhite;
   ReadMemoryTagIDRangeComboBox->Font->Color = clBlue;
   ReadMemoryTagIDRangeComboBox->Enabled = true;

   ReadMemoryTagRNLongRadioButton->Enabled = false;
   ReadMemoryTagRNShortRadioButton->Enabled = false;
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::WriteMemoryTagIDRangeRadioButtonClick(
      TObject *Sender)
{
    WriteMemoryTagIDEdit->ReadOnly = false;
    WriteMemoryTagIDEdit->Color = clWhite;
    WriteMemoryTagIDEdit->Enabled = true;

    WriteMemoryTagIDRangeComboBox->Color = clWhite;
    WriteMemoryTagIDRangeComboBox->Font->Color = clBlue;
    WriteMemoryTagIDRangeComboBox->Enabled = true;

    WriteMemoryTagRNLongRadioButton->Enabled = false;
    WriteMemoryTagRNShortRadioButton->Enabled = false;
}
//------------------------------------------------------------------------------

void __fastcall TProgStationForm::WriteMemoryTagIDRangeComboBoxExit(
      TObject *Sender)
{
    unsigned short range = atoi(WriteMemoryTagIDRangeComboBox->Text.c_str());
    AnsiString str = range;
    str += " is not a valid Range value.";
    if (!IsInRange(range))
    {
         Application->MessageBox(str.c_str(), "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         WriteMemoryTagIDRangeComboBox->Text = "";
    }
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::AssignTagRdrTagIDRadioButtonClick(
      TObject *Sender)
{
    AssignTagRdrTagIDEdit->Color = clWhite;
    AssignTagRdrTagIDEdit->ReadOnly = false;
    AssignTagRdrTagIDEdit->Enabled = true;

    AssignTagRdrTagIDRangeComboBox->Color = clMenu;
    AssignTagRdrTagIDRangeComboBox->Enabled = false;
    AssignTagRdrTagIDRangeComboBox->Font->Color = clGray;

    AssignTagRdrLongRNDRadioButton->Enabled = true;
    AssignTagRdrShortRNDRadioButton->Enabled = true;
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::AssignTagRdrTagIDRangeRadioButtonClick(
      TObject *Sender)
{
    AssignTagRdrTagIDEdit->Color = clWhite;
    AssignTagRdrTagIDEdit->ReadOnly = false;
    AssignTagRdrTagIDEdit->Enabled = true;

    AssignTagRdrTagIDRangeComboBox->Color = clWhite;
    AssignTagRdrTagIDRangeComboBox->Enabled = true;
    AssignTagRdrTagIDRangeComboBox->Font->Color = clBlue;

    AssignTagRdrLongRNDRadioButton->Enabled = false;
    AssignTagRdrShortRNDRadioButton->Enabled = false;
}
//------------------------------------------------------------------------------

void __fastcall TProgStationForm::AssignTagRdrAnyTagIDRadioButtonClick(
      TObject *Sender)
{
    AssignTagRdrTagIDEdit->Color = clMenu;
    AssignTagRdrTagIDEdit->ReadOnly = true;
    AssignTagRdrTagIDEdit->Enabled = false;

    AssignTagRdrTagIDRangeComboBox->Color = clMenu;
    AssignTagRdrTagIDRangeComboBox->Enabled = false;
    AssignTagRdrTagIDRangeComboBox->Font->Color = clGray;

    AssignTagRdrLongRNDRadioButton->Enabled = true;
    AssignTagRdrShortRNDRadioButton->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::AssignTagRdrTagIDRangeComboBoxExit(
      TObject *Sender)
{
    unsigned short range = atoi(AssignTagRdrTagIDRangeComboBox->Text.c_str());
    AnsiString str = range;
    str += " is not a valid Range value.";
    if (!IsInRange(range))
    {
         Application->MessageBox(str.c_str(), "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         AssignTagRdrTagIDRangeComboBox->Text = "";
    }
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::ConfigTagRNDTagIDRangeComboBoxExit(
      TObject *Sender)
{
    unsigned short range = atoi(ConfigTagRNDTagIDRangeComboBox->Text.c_str());
    AnsiString str = range;
    str += " is not a valid Range value.";
    if (!IsInRange(range))
    {
         Application->MessageBox(str.c_str(), "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         ConfigTagRNDTagIDRangeComboBox->Text = "";
    }
}
//------------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagRNDTagIDRadioButtonClick(
      TObject *Sender)
{
   ConfigTagRNDTagIDEdit->Color = clWhite;
   ConfigTagRNDTagIDEdit->Font->Color = clBlue;
   ConfigTagRNDTagIDEdit->Enabled = true;

   ConfigTagRNDTagIDRangeComboBox->Color = clMenu;
   ConfigTagRNDTagIDRangeComboBox->Font->Color = clGray;
   ConfigTagRNDTagIDRangeComboBox->Enabled = false;

   ConfigTagRNDLongRespRadioButton->Enabled = true;
   ConfigTagRNDShortRespRadioButton->Enabled = true;
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::ConfigTagRNDTagIDRangeRadioButtonClick(
      TObject *Sender)
{
   ConfigTagRNDTagIDEdit->Color = clWhite;
   ConfigTagRNDTagIDEdit->Font->Color = clBlue;
   ConfigTagRNDTagIDEdit->Enabled = true;

   ConfigTagRNDTagIDRangeComboBox->Color = clWhite;
   ConfigTagRNDTagIDRangeComboBox->Font->Color = clBlue;
   ConfigTagRNDTagIDRangeComboBox->Enabled = true;

   ConfigTagRNDLongRespRadioButton->Enabled = false;
   ConfigTagRNDShortRespRadioButton->Enabled = false;
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::ConfigTagRNDAnyTagIDRadioButtonClick(
      TObject *Sender)
{
   ConfigTagRNDTagIDEdit->Color = clMenu;
   ConfigTagRNDTagIDEdit->Font->Color = clGray;
   ConfigTagRNDTagIDEdit->Enabled = false;

   ConfigTagRNDTagIDRangeComboBox->Color = clMenu;
   ConfigTagRNDTagIDRangeComboBox->Font->Color = clGray;
   ConfigTagRNDTagIDRangeComboBox->Enabled = false;

   ConfigTagRNDLongRespRadioButton->Enabled = true;
   ConfigTagRNDShortRespRadioButton->Enabled = true;
}
//------------------------------------------------------------------------------

void __fastcall TProgStationForm::ConfigTagLEDTagIDRangeComboBoxExit(
      TObject *Sender)
{
    unsigned short range = atoi(ConfigTagLEDTagIDRangeComboBox->Text.c_str());
    AnsiString str = range;
    str += " is not a valid Range value.";
    if (!IsInRange(range))
    {
         Application->MessageBox(str.c_str(), "Programming Station Information Dialog",
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
         ConfigTagLEDTagIDRangeComboBox->Text = "";
    }
}
//------------------------------------------------------------------------------
void __fastcall TProgStationForm::ConfigTagLEDTagIDRangeRadioButtonClick(
      TObject *Sender)
{
   ConfigTagLEDTagIDEdit->ReadOnly = false;
   ConfigTagLEDTagIDEdit->Color = clWhite;
   ConfigTagLEDTagIDEdit->Enabled = true;

   ConfigTagLEDTagIDRangeComboBox->Font->Color = clBlue;
   ConfigTagLEDTagIDRangeComboBox->Color = clWhite;
   ConfigTagLEDTagIDRangeComboBox->Enabled = true;

   ConfigTagLEDRNLongRadioButton->Enabled = false;
   ConfigTagLEDRNShortRadioButton->Enabled = false;
}
//------------------------------------------------------------------------------

void __fastcall TProgStationForm::GeneralTimerTimer(TObject *Sender)
{
    //send the last pkt again - check for # times sent - reached max quit
    //this section of code is for testing the write tag memory for large data >= 2k
    /*if (retry > 5)
    {
       GeneralTimer->Enabled = false;
       displayElapsedTime = false;
       Application->MessageBox("No response from the tag. Quiting write tag process", "Error", MB_OK);
       return;
    }*/

    /*if (retry == 10)
    {
       retry = 0;
       WriteRS232Comm(RESET_DEVICE, 0, NULL, 0);
       StaticText->Caption = "POWER UP";
    }
    else
       retry += 1;*/

    if (totByteWritten <= atoi(WriteMemoryNumByteEdit->Text.c_str()))
    {
    if (!largeDataWriteAck && writeTagData)
    {
       if((largeDataWriteAckCounter >= 3) && (!largeDataWriteRetry))
       {
          largeDataWriteRetry = true;
          largeDataWriteAckCounter = 0;
       }
       else
          largeDataWriteAckCounter += 1;
    }
    else if (!largeDataReadAck && writeTagData)
    {
       if((largeDataReadAckCounter >= 3) && (!largeDataReadRetry))
       {
          largeDataReadRetry = true;
          largeDataReadAckCounter = 0;
       }
       else
          largeDataReadAckCounter += 1;
    }
    }
    else
      GeneralTimer->Enabled = false;


    /*if(networkOn)
    {
      int rdr = atoi(WriteMemoryReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(WRITE_TAG_MEMORY, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      /*if (nextPkt)
      {
         WriteRS232Comm(WRITE_TAG_MEMORY, 0, NULL, 0);
         retry = 0;
      }
      else
         WriteRS232Comm(WRITE_TAG_MEMORY, 0, NULL, 1);
      numWritePkts += 1;
      numWriteRetry += 1;
      AnsiString s = "#Pkts: ";
      s += numWritePkts;
      WriteNumPKtLabel->Caption = s;
      */

      //s = "#Reties: ";
      //s += numWriteRetry;
      //WriteNumRetryLabel->Caption = s;
      //WriteNumPKtLabel->Invalidate();
      //WriteNumRetryLabel->Invalidate();
   //}
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::LargeDataCheckBoxClick(TObject *Sender)
{
   if (LargeDataCheckBox->Checked)
   {
      MaxWDataLabel->Caption = "N * 12 bytes";
      BytesWrittenLabel->Visible = true;
      WriteTimeLabel->Visible = true;
      //WriteNumPKtLabel->Visible = true;
      //WriteNumRetryLabel->Visible = true;
      WriteMemoryClearBitBtn->Caption = "STOP";
      WriteMemoryNumByteEdit->MaxLength = 4;
   }
   else
   {
      MaxWDataLabel->Caption = "Max 12";
      BytesWrittenLabel->Visible = false;
      WriteMemoryClearBitBtn->Caption = "Clear";
      WriteMemoryNumByteEdit->MaxLength = 2;
      BytesWrittenLabel->Visible = false;
      WriteTimeLabel->Visible = false;
      WriteNumPKtLabel->Visible = false;
      WriteNumRetryLabel->Visible = false;
   }
}
//---------------------------------------------------------------------------


void __fastcall TProgStationForm::WriteTimerTimer(TObject *Sender)
{
    WriteTimer->Enabled = false;
    largeDataWriteAck = false;
    largeDataWriteAckCounter = 0;
    WriteRS232Comm(WRITE_TAG_MEMORY, 0, NULL, 0);
    //largeDataWriteAck = false;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ReadTimerTimer(TObject *Sender)
{
    ReadTimer->Enabled = false;
    largeDataReadAck = false;
    largeDataReadAckCounter = 0;
    WriteRS232Comm(READ_TAG_MEMORY, 0, NULL, 0);
    //largeDataReadAck = false;
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::RetryTimerTimer(TObject *Sender)
{
   if (largeDataWriteRetry)
   {
       largeDataWriteRetryCt += 1;
       largeDataReadRetryCt = 0;

       if ( largeDataWriteRetryCt > 5)
       {
          RetryTimer->Enabled = false;
          largeDataWriteRetry = false;
          ReadTimer->Enabled = false;
          WriteTimer->Enabled = false;
          writeTagData = false;
          displayElapsedTime = false;
          GeneralTimer->Enabled = false;
          Application->MessageBox("No response from the tag. Quiting write tag process", "Error", MB_OK);
          return;
       }
       AnsiString s = "#W: ";
       s += largeDataWriteRetryCt;
       //WriteNumRetryLabel->Caption = s;

       for (int i=0; i<largeDataLastWriteBuf[2]+5; i++)
          XBuf[i] = largeDataLastWriteBuf[i];

       pktLenToTransmit = largeDataLastWriteBuf[2]+5;
       pktCommandToTransmit = WRITE_TAG_MEMORY;
       txWriteThread->Resume();
   }
   else if (largeDataReadRetry)
   {
       largeDataReadRetryCt += 1;
       largeDataWriteRetryCt = 0;

       if (largeDataReadRetryCt > 5)
       {
          RetryTimer->Enabled = false;
          GeneralTimer->Enabled = false;
          largeDataWriteRetry = false;
          ReadTimer->Enabled = false;
          WriteTimer->Enabled = false;
          writeTagData = false;
          displayElapsedTime = false;
          Application->MessageBox("No response from the tag. Quiting write tag process", "Error", MB_OK);
          return;
       }

       AnsiString s = "#R: ";
       s += largeDataReadRetryCt;
       //ReadNumRetryLabel->Caption = s;

       for (int i=0; i<largeDataLastReadBuf[2]+5; i++)
          XBuf[i] = largeDataLastReadBuf[i];

       pktLenToTransmit = largeDataLastReadBuf[2]+5;
       pktCommandToTransmit = READ_TAG_MEMORY;
       txWriteThread->Resume();
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ReadTagLargeDataCheckBoxClick(
      TObject *Sender)
{
   if (!ReadTagLargeDataCheckBox->Checked)
   {
        MaxReadLabel->Visible = false;
        ReadTagReadLabel->Visible = false;
        ReadTimeLabel->Visible = false;
        DisplayDataCheckBox->Visible = false;
        ReadMemoryNumByteEdit->MaxLength = 2;
        ReadMemLargeDataStopBitBtn->Visible = false;
   }
   else
   {
        MaxReadLabel->Visible = true;
        ReadTagReadLabel->Visible = true;
        ReadTimeLabel->Visible = true;
        DisplayDataCheckBox->Visible = true;
        displayElapsedTime = false;
        ReadMemLargeDataStopBitBtn->Visible = true;
        ReadMemoryNumByteEdit->MaxLength = 4;
   }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ReadLargDataTimerTimer(TObject *Sender)
{
    if (gotFF)
    {
         gotFF = false;
         noResponseCounter = 0;
         if (numReadLargeData < MaxReadLargeData)
         {
            if (lastNumReadLargeData == numReadLargeData)
               readLargeDataCounter += 1;
            else
            {
               lastNumReadLargeData = numReadLargeData;
               readLargeDataCounter = 0;
            }

            if (readLargeDataCounter > 5)
            {
               ReadLargDataTimer->Enabled = false;
               displayElapsedTime = false;
               //send msg no respond - quiting
            }
            else
            {
               WriteRS232Comm(READ_TAG_MEMORY, 0, NULL, 0);
            }
         }
         else
         {
           ReadLargDataTimer->Enabled = false;
         }
    }
    else
    {
       noResponseCounter += 1;
       if (noResponseCounter >= 5)
       {
           noResponseCounter = 0;
           readLargeDataCounter = 0;
           WriteRS232Comm(READ_TAG_MEMORY, 0, NULL, 0);
       }
    }

}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::ReadMemLargeDataStopBitBtnClick(
      TObject *Sender)
{
    ReadLargDataTimer->Enabled = false;
    displayElapsedTime = false;
}
//---------------------------------------------------------------------------
bool __fastcall TProgStationForm::CheckVaildTagType(AnsiString type)
{
   if (type.data() == NULL)
      return (false);
   else if ((type == "All Types") || (type == "Factory"))
      return (true);

   for (int i=0; i<6; i++)  //numTagTypes
   {
      if (tagTypes[i] == type)
         return (true);
   }
   return (false);
}
//---------------------------------------------------------------------------
bool __fastcall TProgStationForm::CheckVaildTagTypeAbr(AnsiString type)
{
   if (type.data() == NULL)
      return (false);

   for (int i=0; i<6; i++)  //numTagTypes
   {
      if (tagTypesAbr[i] == type)
         return (true);
   }
   return (false);
}
//---------------------------------------------------------------------------
int __fastcall TProgStationForm::GetTagTypeValue(int index)
{
   if (index < 0)
      return (-1);

    return ((index+1)*0x20);
}
//---------------------------------------------------------------------------
//Get the tag type num value index in tagtypes[] given the recvBuf[byte] coming from the reader
int __fastcall  TProgStationForm::GetTagTypesIndex(unsigned char byte)
{
     int n = byte & 0xE0;

     if (n == 0)
        return (-1);

     n = ((n/0x20)- 1);
     if ((n<0) || (n>7))
        return (-1);
     else
        return (n);
}
//---------------------------------------------------------------------------
//Get the combobox index number given the recvBuf[byte] coming from the reader
int __fastcall  TProgStationForm::GetTagTypeComboBoxIndex(unsigned char byte)
{
     int n = byte & 0xE0;

     if (n == 0)
        return (-1);

     n = ((n/0x20)- 1);
     //return ((n/0x20)- 1);   //index of combobox
     for (int i=0; i<6; i++)   //numTagTypes
     {
        if (ConfigTagTypeComboBox->Items->Text == tagTypes[n])
           return (i);
     }

     return (-1);
}
//---------------------------------------------------------------------------
//Get the combobox index number given the type val coming from the reader
int __fastcall  TProgStationForm::GetTagTypeComboBoxIndex(int typeVal)
{
     if (typeVal == 0)
        return (-1);

     for (int i=0; i<6; i++)   //numTagTypes
     {
        if (ConfigTagTypeComboBox->Items->Text == tagTypes[typeVal-1])
           return (i);
     }

     return (-1);
}
//---------------------------------------------------------------------------
//Get the combobox selected Text number given the abberviation
int __fastcall  TProgStationForm::GetTagTypeComboBoxIndex(AnsiString abr)
{
     if (abr.data() == NULL)
        return (NULL);

     for (int i=0; i<6; i++)   //numTagTypes
     {
        if (abr == tagTypesAbr[i])
        {
           for (int j=0; j<numTagTypes; j++)
           {
              //ConfigTagTypeComboBox->ItemIndex = j;
              if (ConfigTagTypeComboBox->Items->Strings[j] == tagTypes[i])
                 return (j);
           }
           return (-1);
        }
     }

     return (-1);
}
// --------------------------------------------------------------------------
//Gets index of array in the TagTypeAbr given tag abbreviation
int __fastcall TProgStationForm::GetIndexTagTypeAbr(AnsiString type)
{
    if (!CheckVaildTagTypeAbr(type))
        return (-1);

    for (int i=0; i<6; i++)   //numTagTypes
    {
      if (tagTypesAbr[i] == type)
         return (i);
    }
    return (-1);
}
//----------------------------------------------------------------------------
void __fastcall TProgStationForm::InitializeAWSockets()
{
   for (int i=0; i<MAX_DESCRIPTOR; i++)
   {
       if (AWSockets[i] != NULL)
       {
          delete AWSockets[i];
          AWSockets[i] = NULL;
       }
       //AWSockets[i]->AWClientSocket->Address.SetLength(0);
       //AWSockets[i]->reader = 0;
       //AWSockets[i]->host = 0;
       //AWSockets[i]->rdrStatus = "";
       //AWSockets[i]->index = 0;
   }
}
//----------------------------------------------------------------------------
void __fastcall TProgStationForm::InitializeListViewInfo()
{
    for (int i=0; i<MAX_DESCRIPTOR; i++)
    {
       listViewInfo[i].selected = false;
       listViewInfo[i].ip.SetLength(0);
       listViewInfo[i].reader = 0;
       listViewInfo[i].host = 0;
       strcpy (listViewInfo[i].netStatus, "");
       strcpy (listViewInfo[i].rdrStatus, "");
       listViewInfo[i].full = false;
    }
}
//---------------------------------------------------------------------------
//Gets index of array in the TagTypes given tag name
int __fastcall TProgStationForm::GetIndexTagType(AnsiString type)
{
   if (!CheckVaildTagType(type))
        return (-1);

    for (int i=0; i<6; i++)   //numTagTypes
    {
      if (tagTypes[i] == type)
         return (i);
    }
    return (-1);
}

/*
void __fastcall TProgStationForm::ReaderOffLineTimerTimer(TObject *Sender)
{
   readerOffLine = true;
   readerOnLine = false;
}*/

//---------------------------------------------------------------------------


void __fastcall TProgStationForm::TagTempLoggingCheckBoxClick(
      TObject *Sender)
{
      if (TagTempLoggingCheckBox->Checked && mouseClicked)
      {
          mouseClicked = false;
          TagTempWarpAroundCheckBox->Enabled = true;
          TagTempTimeStampBitBtn->Enabled = true;
      }
      else if (!TagTempLoggingCheckBox->Checked && mouseClicked)
      {
          mouseClicked = false;
          TagTempWarpAroundCheckBox->Enabled = false;
          TagTempWarpAroundCheckBox->Checked = false;
          TagTempTimeStampBitBtn->Enabled = false;
      }
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::TagTempLoggingCheckBoxMouseDown(
      TObject *Sender, TMouseButton Button, TShiftState Shift, int X,
      int Y)
{
   mouseClicked = true;
}
//---------------------------------------------------------------------------


void __fastcall TProgStationForm::FGenConfigWaitTimeCheckBoxClick(
      TObject *Sender)
{
     /*if (FGenConfigWaitTimeCheckBox->Checked)
        FGenConfigWaitTimeComboBox->Enabled = true;
     else
        FGenConfigWaitTimeComboBox->Enabled = false;
     AnsiString str = "";*/

     /*if (FGenConfigWaitTimeSecRadioButton->Checked)
        str = "sec";
     else if (FGenConfigWaitTimeMinRadioButton->Checked)
        str = "min";
     else if (FGenConfigWaitTimeHourRadioButton->Checked)
        str = "hour";

     if (str.data() != NULL)
     {
         FGenConfigWaitTimeLabel->Caption = str;
     }*/
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::FGenConfigHoldTimeCheckBoxClick(
      TObject *Sender)
{
     /*if (FGenConfigHoldTimeCheckBox->Checked)
        FGenConfigHoldTimeComboBox->Enabled = true;
     else
        FGenConfigHoldTimeComboBox->Enabled = false; */

     /*AnsiString str = "";

     if (FGenConfigWaitTimeSecRadioButton->Checked)
        str = "sec";
     else if (FGenConfigWaitTimeMinRadioButton->Checked)
        str = "min";
     else if (FGenConfigWaitTimeHourRadioButton->Checked)
        str = "hour";

     if (str.data() != NULL)
     {
         FGenConfigHoldTimeLabel->Caption = str;
     }*/
}
//---------------------------------------------------------------------------

void __fastcall TProgStationForm::TagTempTimeStampBitBtnClick(
      TObject *Sender)
{
       //WriteRS232Comm(WRITE_TAG_LOG_TIME, 99, NULL, 0);


       bool b;

   if (!NewListItemCheckBox->Checked)
   {
      TxClearTagCtrls();
      RxClearTagCtrls();
      ProgammingMode = true;
      StaticText->Caption = "";
      DetectedMsg->Caption = "";
      TamperSWMsg->Caption = "";
      TagDetectedGroupBox->Caption = "Detected Tags";
      tagDetectCount = 0;
      type1Count = 0;
      type2Count = 0;
      type3Count = 0;
      type4Count = 0;
      type5Count = 0;
      type6Count = 0;
      typeFacCount = 0;
      ReportType1Label->Caption = "";
      ReportType2Label->Caption = "";
      ReportType3Label->Caption = "";
      ReportType4Label->Caption = "";
      ReportType5Label->Caption = "";
      ReportType6Label->Caption = "";
      ReportFACTLabel->Caption = "";
      ReportTotalLabel->Caption = "";
      ReportNDupLabel->Caption = "";
      DetectedTagListView->Items->Clear();
      for (int i=0; i<MAX_TAG_DETECTED; i++)
      {
          tagDetectedArray[i].tagID = 0;
          tagDetectedArray[i].tagType = 6;
          tagDetectedArray[i].cmd = 0;
          tagDetectedArray[i].fGenID = 0xFF;
          tagDetectedArray[i].gID = false;
          tagDetectedArray[i].lastDetectTime = Now();
      }
   }
   //StaticText->Caption = "";
   programming = true;
   progStr = "Please wait. ";

   tagTypeStr = WriteMemoryTagTypeComboBox->Text;
   progStr += "configuring temp. for ";
   progStr += WriteMemoryTagTypeComboBox->Text;
   progStr += " Tag";


   if ((ConfigTagIDRangeRadioButton->Checked) && (ConfigTagTagIDEdit->Text.data() == NULL))
   {
       Application->MessageBox("Error: Need Tag ID",
                               "Programming Station Information Dialog",
                               MB_OK | MB_ICONSTOP | MB_TOPMOST);
       ConfigTagBitBtn->Enabled = true;
       return;
   }

   if ((TagTempTagTypeComboBox->Text == "All Types") && (TagTempAnyTagIDRadioButton->Checked))
    {
        int ret = Application->MessageBox ("Do you want to Configure ALL tags?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "All Tags";
        progStr = "Please wait. Configuring All Tags";
    }
    else if (TagTempTagTypeComboBox->Text == "All Types")
    {
       int ret = Application->MessageBox ("Do you want to Configure All Tag Types?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        tagTypeStr = "All Types";
        progStr = "Please wait. Configuring All Tag Types";
    }
    else if (TagTempAnyTagIDRadioButton->Checked)
    {
       int ret = Application->MessageBox ("Do you want to Configure Any Tag ID?",
                                         "Programming Station Information Dialog",
                                         MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
        if (ret == IDNO)
             return;
        progStr = "Please wait. Configuring Any Tag ID";
    }
    else
       progStr = "Please wait, configuring tag temperature timestamp. ";

   StaticText->Caption = progStr;

   TagTempBitBtn->Font->Color = clRed;
   programming = true;

   DisableTagStaticCommands();
   CMDEnableTimer->Enabled = true;
   TagTempBitBtn->Enabled = false;

   if(networkOn)
   {
      int rdr = atoi(TagTempReaderIDComboBox->Text.c_str());
      int index = GetSocketIndex(rdr);
      if (index >= 0)
      {
         WriteAWSocket(WRITE_TAG_LOG_TIME, 0, NULL, index, 'S', NULL, 0, index);
      }
      else
         StaticText->Caption = "No matching socket for the reader.";
   }
   else if (RS232On)
   {
      WriteRS232Comm(WRITE_TAG_LOG_TIME, 0, NULL, 0);
   }

   //EnableTagBitBtn->Enabled = false;
   EnableReaderStaticText->Enabled = false;
   DisableReaderStaticText->Enabled = false;
   QueryReaderStaticText->Enabled = false;
   AssignReaderStaticText->Enabled = false;
   ReaderVersionStaticText->Enabled = false;
   ConfigTxTimeStaticText->Enabled = false;
   RelayStaticText->Enabled = false;
   //EnableRdrFGenStaticText->Enabled = false;
   ConfigFGenStaticText->Enabled = false;
   QueryFGenStaticText->Enabled = false;
   ConfigTagStaticText->Enabled = false;
   EnableTagStaticText->Enabled = false;
   DisableTagStaticText->Enabled = false;
   QueryTagStaticText->Enabled = false;
   CallTagStaticText->Enabled = false;
   AssignTagRdrStaticText->Enabled = false;
   ConfigTagRNDStaticText->Enabled = false;
   WriteMemoryStaticText->Enabled = false;
   ReadMemoryStaticText->Enabled = false;
   TagTempStaticText->Enabled = false;
   TagTempReadTempValueBitBtn->Enabled = false;
   TagTempRefreshBitBtn->Enabled = false;
   TagTempBitBtn->Enabled = false;
   first = true;
}
//---------------------------------------------------------------------------







